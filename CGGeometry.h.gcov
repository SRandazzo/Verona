        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.0.sdk/System/Library/Frameworks/CoreGraphics.framework/Headers/CGGeometry.h
        -:    0:Graph:/Users/Sal/Library/Developer/Xcode/DerivedData/Verona-fgfbmnilklhvdihbxoslbfynjgbp/Build/Intermediates/Pods.build/Debug-iphonesimulator/FBSnapshotTestCase.build/Objects-normal/x86_64/UIImage+Diff.gcno
        -:    0:Data:/Users/Sal/Library/Developer/Xcode/DerivedData/Verona-fgfbmnilklhvdihbxoslbfynjgbp/Build/Intermediates/Pods.build/Debug-iphonesimulator/FBSnapshotTestCase.build/Objects-normal/x86_64/UIImage+Diff.gcda
        -:    0:Runs:9
        -:    0:Programs:1
        -:    1:/* CoreGraphics - CGGeometry.h
        -:    2:   Copyright (c) 1998-2011 Apple Inc.
        -:    3:   All rights reserved. */
        -:    4:
        -:    5:#ifndef CGGEOMETRY_H_
        -:    6:#define CGGEOMETRY_H_
        -:    7:
        -:    8:#include <CoreGraphics/CGBase.h>
        -:    9:#include <CoreFoundation/CFDictionary.h>
        -:   10:#include <CoreFoundation/CFBase.h>
        -:   11:#include <CoreFoundation/CFAvailability.h>
        -:   12:#include <stdint.h>
        -:   13:
        -:   14:CF_IMPLICIT_BRIDGING_ENABLED
        -:   15:
        -:   16:CF_ASSUME_NONNULL_BEGIN
        -:   17:
        -:   18:/* Points. */
        -:   19:
        -:   20:struct CGPoint {
        -:   21:    CGFloat x;
        -:   22:    CGFloat y;
        -:   23:};
        -:   24:typedef struct CGPoint CGPoint;
        -:   25:
        -:   26:/* Sizes. */
        -:   27:
        -:   28:struct CGSize {
        -:   29:    CGFloat width;
        -:   30:    CGFloat height;
        -:   31:};
        -:   32:typedef struct CGSize CGSize;
        -:   33:
        -:   34:/* Vectors. */
        -:   35:
        -:   36:#define CGVECTOR_DEFINED 1
        -:   37:
        -:   38:struct CGVector {
        -:   39:    CGFloat dx;
        -:   40:    CGFloat dy;
        -:   41:};
        -:   42:typedef struct CGVector CGVector;
        -:   43:
        -:   44:/* Rectangles. */
        -:   45:
        -:   46:struct CGRect {
        -:   47:    CGPoint origin;
        -:   48:    CGSize size;
        -:   49:};
        -:   50:typedef struct CGRect CGRect;
        -:   51:
        -:   52:/* Rectangle edges. */
        -:   53:
        -:   54:typedef CF_ENUM(uint32_t, CGRectEdge) {
        -:   55:    CGRectMinXEdge, CGRectMinYEdge, CGRectMaxXEdge, CGRectMaxYEdge
        -:   56:};
        -:   57:
        -:   58:/* The "zero" point -- equivalent to CGPointMake(0, 0). */ 
        -:   59:
        -:   60:CG_EXTERN const CGPoint CGPointZero
        -:   61:      CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:   62:
        -:   63:/* The "zero" size -- equivalent to CGSizeMake(0, 0). */ 
        -:   64:
        -:   65:CG_EXTERN const CGSize CGSizeZero
        -:   66:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:   67:
        -:   68:/* The "zero" rectangle -- equivalent to CGRectMake(0, 0, 0, 0). */ 
        -:   69:
        -:   70:CG_EXTERN const CGRect CGRectZero
        -:   71:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:   72:
        -:   73:/* The "empty" rect. This is the rectangle returned when, for example, we
        -:   74:   intersect two disjoint rectangles. Note that the null rect is not the
        -:   75:   same as the zero rect. */
        -:   76:
        -:   77:CG_EXTERN const CGRect CGRectNull
        -:   78:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:   79:
        -:   80:/* The infinite rectangle. */
        -:   81:
        -:   82:CG_EXTERN const CGRect CGRectInfinite
        -:   83:    CG_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);
        -:   84:
        -:   85:/* Make a point from `(x, y)'. */
        -:   86:
        -:   87:CG_INLINE CGPoint CGPointMake(CGFloat x, CGFloat y);
        -:   88:
        -:   89:/* Make a size from `(width, height)'. */
        -:   90:
        -:   91:CG_INLINE CGSize CGSizeMake(CGFloat width, CGFloat height);
        -:   92:
        -:   93:/* Make a vector from `(dx, dy)'. */
        -:   94:
        -:   95:CG_INLINE CGVector CGVectorMake(CGFloat dx, CGFloat dy);
        -:   96:
        -:   97:/* Make a rect from `(x, y; width, height)'. */
        -:   98:
        -:   99:CG_INLINE CGRect CGRectMake(CGFloat x, CGFloat y, CGFloat width,
        -:  100:  CGFloat height);
        -:  101:
        -:  102:/* Return the leftmost x-value of `rect'. */
        -:  103:
        -:  104:CG_EXTERN CGFloat CGRectGetMinX(CGRect rect)
        -:  105:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  106:
        -:  107:/* Return the midpoint x-value of `rect'. */
        -:  108:
        -:  109:CG_EXTERN CGFloat CGRectGetMidX(CGRect rect)
        -:  110:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  111:
        -:  112:/* Return the rightmost x-value of `rect'. */
        -:  113:
        -:  114:CG_EXTERN CGFloat CGRectGetMaxX(CGRect rect)
        -:  115:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  116:
        -:  117:/* Return the bottommost y-value of `rect'. */
        -:  118:
        -:  119:CG_EXTERN CGFloat CGRectGetMinY(CGRect rect)
        -:  120:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  121:
        -:  122:/* Return the midpoint y-value of `rect'. */
        -:  123:
        -:  124:CG_EXTERN CGFloat CGRectGetMidY(CGRect rect)
        -:  125:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  126:
        -:  127:/* Return the topmost y-value of `rect'. */
        -:  128:
        -:  129:CG_EXTERN CGFloat CGRectGetMaxY(CGRect rect)
        -:  130:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  131:
        -:  132:/* Return the width of `rect'. */
        -:  133:
        -:  134:CG_EXTERN CGFloat CGRectGetWidth(CGRect rect)
        -:  135:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  136:
        -:  137:/* Return the height of `rect'. */
        -:  138:
        -:  139:CG_EXTERN CGFloat CGRectGetHeight(CGRect rect)
        -:  140:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  141:
        -:  142:/* Return true if `point1' and `point2' are the same, false otherwise. */
        -:  143:
        -:  144:CG_EXTERN bool CGPointEqualToPoint(CGPoint point1, CGPoint point2)
        -:  145:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  146:
        -:  147:/* Return true if `size1' and `size2' are the same, false otherwise. */
        -:  148:
        -:  149:CG_EXTERN bool CGSizeEqualToSize(CGSize size1, CGSize size2)
        -:  150:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  151:
        -:  152:/* Return true if `rect1' and `rect2' are the same, false otherwise. */
        -:  153:
        -:  154:CG_EXTERN bool CGRectEqualToRect(CGRect rect1, CGRect rect2)
        -:  155:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  156:
        -:  157:/* Standardize `rect' -- i.e., convert it to an equivalent rect which has
        -:  158:   positive width and height. */
        -:  159:
        -:  160:CG_EXTERN CGRect CGRectStandardize(CGRect rect)
        -:  161:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  162:
        -:  163:/* Return true if `rect' is empty (that is, if it has zero width or height),
        -:  164:   false otherwise. A null rect is defined to be empty. */
        -:  165:
        -:  166:CG_EXTERN bool CGRectIsEmpty(CGRect rect)
        -:  167:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  168:
        -:  169:/* Return true if `rect' is the null rectangle, false otherwise. */
        -:  170:
        -:  171:CG_EXTERN bool CGRectIsNull(CGRect rect)
        -:  172:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  173:
        -:  174:/* Return true if `rect' is the infinite rectangle, false otherwise. */
        -:  175:
        -:  176:CG_EXTERN bool CGRectIsInfinite(CGRect rect)
        -:  177:    CG_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);
        -:  178:
        -:  179:/* Inset `rect' by `(dx, dy)' -- i.e., offset its origin by `(dx, dy)', and
        -:  180:   decrease its size by `(2*dx, 2*dy)'. */
        -:  181:
        -:  182:CG_EXTERN CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)
        -:  183:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  184:
        -:  185:/* Expand `rect' to the smallest rect containing it with integral origin and
        -:  186:   size. */
        -:  187:
        -:  188:CG_EXTERN CGRect CGRectIntegral(CGRect rect)
        -:  189:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  190:
        -:  191:/* Return the union of `r1' and `r2'. */
        -:  192:
        -:  193:CG_EXTERN CGRect CGRectUnion(CGRect r1, CGRect r2)
        -:  194:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  195:
        -:  196:/* Return the intersection of `r1' and `r2'. This may return a null rect. */
        -:  197:
        -:  198:CG_EXTERN CGRect CGRectIntersection(CGRect r1, CGRect r2)
        -:  199:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  200:
        -:  201:/* Offset `rect' by `(dx, dy)'. */
        -:  202:
        -:  203:CG_EXTERN CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)
        -:  204:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  205:
        -:  206:/* Make two new rectangles, `slice' and `remainder', by dividing `rect' with
        -:  207:   a line that's parallel to one of its sides, specified by `edge' -- either
        -:  208:   `CGRectMinXEdge', `CGRectMinYEdge', `CGRectMaxXEdge', or
        -:  209:   `CGRectMaxYEdge'. The size of `slice' is determined by `amount', which
        -:  210:   measures the distance from the specified edge. */
        -:  211:
        -:  212:CG_EXTERN void CGRectDivide(CGRect rect, CGRect *  slice,
        -:  213:    CGRect *  remainder, CGFloat amount, CGRectEdge edge)
        -:  214:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  215:
        -:  216:/* Return true if `point' is contained in `rect', false otherwise. */
        -:  217:
        -:  218:CG_EXTERN bool CGRectContainsPoint(CGRect rect, CGPoint point)
        -:  219:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  220:
        -:  221:/* Return true if `rect2' is contained in `rect1', false otherwise. `rect2'
        -:  222:   is contained in `rect1' if the union of `rect1' and `rect2' is equal to
        -:  223:   `rect1'. */
        -:  224:
        -:  225:CG_EXTERN bool CGRectContainsRect(CGRect rect1, CGRect rect2)
        -:  226:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  227:
        -:  228:/* Return true if `rect1' intersects `rect2', false otherwise. `rect1'
        -:  229:   intersects `rect2' if the intersection of `rect1' and `rect2' is not the
        -:  230:   null rect. */
        -:  231:
        -:  232:CG_EXTERN bool CGRectIntersectsRect(CGRect rect1, CGRect rect2)
        -:  233:    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
        -:  234:
        -:  235:/*** Persistent representations. ***/
        -:  236:
        -:  237:/* Return a dictionary representation of `point'. */
        -:  238:
        -:  239:CG_EXTERN CFDictionaryRef  CGPointCreateDictionaryRepresentation(
        -:  240:    CGPoint point)
        -:  241:    CG_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
        -:  242:
        -:  243:/* Make a CGPoint from the contents of `dict' (presumably returned earlier
        -:  244:   from `CGPointCreateDictionaryRepresentation') and store the value in
        -:  245:   `point'. Returns true on success; false otherwise. */
        -:  246:
        -:  247:CG_EXTERN bool CGPointMakeWithDictionaryRepresentation(
        -:  248:    CFDictionaryRef __nullable dict, CGPoint * __nullable point)
        -:  249:    CG_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
        -:  250:
        -:  251:/* Return a dictionary representation of `size'. */
        -:  252:
        -:  253:CG_EXTERN CFDictionaryRef  CGSizeCreateDictionaryRepresentation(CGSize size)
        -:  254:    CG_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
        -:  255:
        -:  256:/* Make a CGSize from the contents of `dict' (presumably returned earlier
        -:  257:   from `CGSizeCreateDictionaryRepresentation') and store the value in
        -:  258:   `size'. Returns true on success; false otherwise. */
        -:  259:
        -:  260:CG_EXTERN bool CGSizeMakeWithDictionaryRepresentation(
        -:  261:    CFDictionaryRef __nullable dict, CGSize * __nullable size)
        -:  262:    CG_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
        -:  263:
        -:  264:/* Return a dictionary representation of `rect'. */
        -:  265:
        -:  266:CG_EXTERN CFDictionaryRef  CGRectCreateDictionaryRepresentation(CGRect)
        -:  267:    CG_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
        -:  268:
        -:  269:/* Make a CGRect from the contents of `dict' (presumably returned earlier
        -:  270:   from `CGRectCreateDictionaryRepresentation') and store the value in
        -:  271:   `rect'. Returns true on success; false otherwise. */
        -:  272:
        -:  273:CG_EXTERN bool CGRectMakeWithDictionaryRepresentation(
        -:  274:    CFDictionaryRef __nullable dict, CGRect * __nullable rect)
        -:  275:    CG_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
        -:  276:
        -:  277:/*** Definitions of inline functions. ***/
        -:  278:
        -:  279:CG_INLINE CGPoint
        -:  280:CGPointMake(CGFloat x, CGFloat y)
        -:  281:{
        -:  282:  CGPoint p; p.x = x; p.y = y; return p;
        -:  283:}
        -:  284:
        -:  285:CG_INLINE CGSize
        -:  286:CGSizeMake(CGFloat width, CGFloat height)
        -:  287:{
    #####:  288:  CGSize size; size.width = width; size.height = height; return size;
        -:  289:}
        -:  290:
        -:  291:CG_INLINE CGVector
        -:  292:CGVectorMake(CGFloat dx, CGFloat dy)
        -:  293:{
        -:  294:  CGVector vector; vector.dx = dx; vector.dy = dy; return vector;
        -:  295:}
        -:  296:
        -:  297:CG_INLINE CGRect
        -:  298:CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height)
        -:  299:{
        -:  300:  CGRect rect;
    #####:  301:  rect.origin.x = x; rect.origin.y = y;
    #####:  302:  rect.size.width = width; rect.size.height = height;
    #####:  303:  return rect;
        -:  304:}
        -:  305:
        -:  306:CG_INLINE bool
        -:  307:__CGPointEqualToPoint(CGPoint point1, CGPoint point2)
        -:  308:{
        -:  309:  return point1.x == point2.x && point1.y == point2.y;
        -:  310:}
        -:  311:#define CGPointEqualToPoint __CGPointEqualToPoint
        -:  312:
        -:  313:CG_INLINE bool
        -:  314:__CGSizeEqualToSize(CGSize size1, CGSize size2)
        -:  315:{
        -:  316:  return size1.width == size2.width && size1.height == size2.height;
        -:  317:}
        -:  318:
        -:  319:#define CGSizeEqualToSize __CGSizeEqualToSize
        -:  320:
        -:  321:CF_ASSUME_NONNULL_END
        -:  322:
        -:  323:CF_IMPLICIT_BRIDGING_DISABLED
        -:  324:
        -:  325:#endif /* CGGEOMETRY_H_ */

/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.0.sdk/System/Library/Frameworks/Foundation.framework/Headers/NSException.h:
       |    1|/*	NSException.h
       |    2|	Copyright (c) 1994-2015, Apple Inc. All rights reserved.
       |    3|*/
       |    4|
       |    5|#import <Foundation/NSObject.h>
       |    6|#import <Foundation/NSString.h>
       |    7|#import <stdarg.h>
       |    8|#import <setjmp.h>
       |    9|
       |   10|@class NSString, NSDictionary, NSArray<ObjectType>, NSNumber;
       |   11|
       |   12|NS_ASSUME_NONNULL_BEGIN
       |   13|
       |   14|/***************	Generic Exception names		***************/
       |   15|
       |   16|FOUNDATION_EXPORT NSString * const NSGenericException;
       |   17|FOUNDATION_EXPORT NSString * const NSRangeException;
       |   18|FOUNDATION_EXPORT NSString * const NSInvalidArgumentException;
       |   19|FOUNDATION_EXPORT NSString * const NSInternalInconsistencyException;
       |   20|
       |   21|FOUNDATION_EXPORT NSString * const NSMallocException;
       |   22|
       |   23|FOUNDATION_EXPORT NSString * const NSObjectInaccessibleException;
       |   24|FOUNDATION_EXPORT NSString * const NSObjectNotAvailableException;
       |   25|FOUNDATION_EXPORT NSString * const NSDestinationInvalidException;
       |   26|    
       |   27|FOUNDATION_EXPORT NSString * const NSPortTimeoutException;
       |   28|FOUNDATION_EXPORT NSString * const NSInvalidSendPortException;
       |   29|FOUNDATION_EXPORT NSString * const NSInvalidReceivePortException;
       |   30|FOUNDATION_EXPORT NSString * const NSPortSendException;
       |   31|FOUNDATION_EXPORT NSString * const NSPortReceiveException;
  ------------------
  | -[OCProtocolMockObject initWithProtocol:]:
  |      0|   26|    
  |      0|   27|FOUNDATION_EXPORT NSString * const NSPortTimeoutException;
  |      0|   28|FOUNDATION_EXPORT NSString * const NSInvalidSendPortException;
  |      0|   29|FOUNDATION_EXPORT NSString * const NSInvalidReceivePortException;
  |      0|   30|FOUNDATION_EXPORT NSString * const NSPortSendException;
  |      0|   31|FOUNDATION_EXPORT NSString * const NSPortReceiveException;
  ------------------
       |   32|
       |   33|FOUNDATION_EXPORT NSString * const NSOldStyleException;
       |   34|
  ------------------
  | -[OCClassMockObject initWithClass:]:
  |     19|   28|FOUNDATION_EXPORT NSString * const NSInvalidSendPortException;
  |     19|   29|FOUNDATION_EXPORT NSString * const NSInvalidReceivePortException;
  |     19|   30|FOUNDATION_EXPORT NSString * const NSPortSendException;
  |     19|   31|FOUNDATION_EXPORT NSString * const NSPortReceiveException;
  |     19|   32|
  |     19|   33|FOUNDATION_EXPORT NSString * const NSOldStyleException;
  |     19|   34|
  ------------------
       |   35|/***************	Exception object	***************/
       |   36|
       |   37|#if __OBJC2__
       |   38|__attribute__((__objc_exception__))
  ------------------
  | -[OCPartialMockObject initWithObject:]:
  |      8|   31|FOUNDATION_EXPORT NSString * const NSPortReceiveException;
  |      8|   32|
  |      8|   33|FOUNDATION_EXPORT NSString * const NSOldStyleException;
  |      8|   34|
  |      8|   35|/***************	Exception object	***************/
  |      8|   36|
  |      8|   37|#if __OBJC2__
  |      8|   38|__attribute__((__objc_exception__))
  ------------------
       |   39|#endif
       |   40|@interface NSException : NSObject <NSCopying, NSCoding> {
       |   41|    @private
       |   42|    NSString		*name;
       |   43|    NSString		*reason;
       |   44|    NSDictionary	*userInfo;
       |   45|    id			reserved;
       |   46|}
       |   47|
       |   48|+ (NSException *)exceptionWithName:(NSString *)name reason:(nullable NSString *)reason userInfo:(nullable NSDictionary *)userInfo;
       |   49|- (instancetype)initWithName:(NSString *)aName reason:(nullable NSString *)aReason userInfo:(nullable NSDictionary *)aUserInfo NS_DESIGNATED_INITIALIZER;
       |   50|
       |   51|@property (readonly, copy) NSString *name;
       |   52|@property (nullable, readonly, copy) NSString *reason;
       |   53|@property (nullable, readonly, copy) NSDictionary *userInfo;
       |   54|
       |   55|@property (readonly, copy) NSArray<NSNumber *> *callStackReturnAddresses NS_AVAILABLE(10_5, 2_0);
       |   56|@property (readonly, copy) NSArray<NSString *> *callStackSymbols NS_AVAILABLE(10_6, 4_0);
       |   57|
       |   58|- (void)raise;
       |   59|
       |   60|@end
       |   61|
       |   62|@interface NSException (NSExceptionRaisingConveniences)
       |   63|
       |   64|+ (void)raise:(NSString *)name format:(NSString *)format, ... NS_FORMAT_FUNCTION(2,3);
       |   65|+ (void)raise:(NSString *)name format:(NSString *)format arguments:(va_list)argList NS_FORMAT_FUNCTION(2,0);
       |   66|
       |   67|@end
       |   68|
       |   69|
       |   70|#define NS_DURING		@try {
       |   71|#define NS_HANDLER		} @catch (NSException *localException) {
       |   72|#define NS_ENDHANDLER		}
       |   73|#define NS_VALUERETURN(v,t)	return (v)
       |   74|#define NS_VOIDRETURN		return
       |   75|
       |   76|
       |   77|typedef void NSUncaughtExceptionHandler(NSException *exception);
       |   78|
       |   79|FOUNDATION_EXPORT NSUncaughtExceptionHandler * __nullable NSGetUncaughtExceptionHandler(void);
       |   80|FOUNDATION_EXPORT void NSSetUncaughtExceptionHandler(NSUncaughtExceptionHandler * __nullable);
       |   81|
       |   82|
       |   83|#if __clang__
       |   84|#define __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |   85|    _Pragma("clang diagnostic push") \
       |   86|    _Pragma("clang diagnostic ignored \"-Wformat-extra-args\"")
       |   87|
       |   88|#define __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS _Pragma("clang diagnostic pop")
       |   89|#else
       |   90|#define __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS
       |   91|#define __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |   92|#endif
       |   93|
       |   94|@class NSAssertionHandler;
       |   95|
       |   96|#if (defined(__STDC_VERSION__) && (199901L <= __STDC_VERSION__)) || (defined(__cplusplus) && (201103L <= __cplusplus))
       |   97|
       |   98|#if !defined(NS_BLOCK_ASSERTIONS)
       |   99|
       |  100|#if !defined(_NSAssertBody)
       |  101|#define NSAssert(condition, desc, ...)	\
     27|  102|    do {				\
     27|  103|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
     27|  104|	if (!(condition)) {		\
      0|  105|            NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \
      0|  106|            __assert_file__ = __assert_file__ ? __assert_file__ : @"<Unknown File>"; \
      0|  107|	    [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \
      0|  108|		object:self file:__assert_file__ \
      0|  109|	    	lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \
      0|  110|	}				\
     19|  111|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \
     27|  112|    } while(0)
       |  113|#endif
       |  114|
       |  115|#if !defined(_NSCAssertBody)
       |  116|#define NSCAssert(condition, desc, ...) \
       |  117|    do {				\
       |  118|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  119|	if (!(condition)) {		\
       |  120|            NSString *__assert_fn__ = [NSString stringWithUTF8String:__PRETTY_FUNCTION__]; \
       |  121|            __assert_fn__ = __assert_fn__ ? __assert_fn__ : @"<Unknown Function>"; \
       |  122|            NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \
       |  123|            __assert_file__ = __assert_file__ ? __assert_file__ : @"<Unknown File>"; \
       |  124|	    [[NSAssertionHandler currentHandler] handleFailureInFunction:__assert_fn__ \
       |  125|		file:__assert_file__ \
       |  126|	    	lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \
       |  127|	}				\
       |  128|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \
       |  129|    } while(0)
       |  130|#endif
       |  131|
       |  132|#else // NS_BLOCK_ASSERTIONS defined
       |  133|
       |  134|#if !defined(_NSAssertBody)
       |  135|#define NSAssert(condition, desc, ...) do {} while (0)
       |  136|#endif
       |  137|
       |  138|#if !defined(_NSCAssertBody)
       |  139|#define NSCAssert(condition, desc, ...) do {} while (0)
       |  140|#endif
       |  141|
       |  142|#endif
       |  143|
       |  144|#if !defined(_NSAssertBody)
       |  145|#define NSAssert1(condition, desc, arg1) NSAssert((condition), (desc), (arg1))
       |  146|#define NSAssert2(condition, desc, arg1, arg2) NSAssert((condition), (desc), (arg1), (arg2))
       |  147|#define NSAssert3(condition, desc, arg1, arg2, arg3) NSAssert((condition), (desc), (arg1), (arg2), (arg3))
       |  148|#define NSAssert4(condition, desc, arg1, arg2, arg3, arg4) NSAssert((condition), (desc), (arg1), (arg2), (arg3), (arg4))
       |  149|#define NSAssert5(condition, desc, arg1, arg2, arg3, arg4, arg5) NSAssert((condition), (desc), (arg1), (arg2), (arg3), (arg4), (arg5))
     19|  150|#define NSParameterAssert(condition) NSAssert((condition), @"Invalid parameter not satisfying: %@", @#condition)
       |  151|#endif
       |  152|
       |  153|#if !defined(_NSCAssertBody)
       |  154|#define NSCAssert1(condition, desc, arg1) NSCAssert((condition), (desc), (arg1))
       |  155|#define NSCAssert2(condition, desc, arg1, arg2) NSCAssert((condition), (desc), (arg1), (arg2))
       |  156|#define NSCAssert3(condition, desc, arg1, arg2, arg3) NSCAssert((condition), (desc), (arg1), (arg2), (arg3))
       |  157|#define NSCAssert4(condition, desc, arg1, arg2, arg3, arg4) NSCAssert((condition), (desc), (arg1), (arg2), (arg3), (arg4))
       |  158|#define NSCAssert5(condition, desc, arg1, arg2, arg3, arg4, arg5) NSCAssert((condition), (desc), (arg1), (arg2), (arg3), (arg4), (arg5))
       |  159|#define NSCParameterAssert(condition) NSCAssert((condition), @"Invalid parameter not satisfying: %@", @#condition)
       |  160|#endif
       |  161|
       |  162|#endif
       |  163|
       |  164|
       |  165|/* Non-vararg implementation of asserts (ignore) */
       |  166|#if !defined(NS_BLOCK_ASSERTIONS)
       |  167|#if !defined(_NSAssertBody)
       |  168|#define _NSAssertBody(condition, desc, arg1, arg2, arg3, arg4, arg5)	\
       |  169|    do {						\
       |  170|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  171|	if (!(condition)) {				\
       |  172|            NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \
       |  173|            __assert_file__ = __assert_file__ ? __assert_file__ : @"<Unknown File>"; \
       |  174|	    [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd object:self file:__assert_file__ \
       |  175|	    	lineNumber:__LINE__ description:(desc), (arg1), (arg2), (arg3), (arg4), (arg5)];	\
       |  176|	}						\
       |  177|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \
       |  178|    } while(0)
       |  179|#endif
       |  180|#if !defined(_NSCAssertBody)
       |  181|#define _NSCAssertBody(condition, desc, arg1, arg2, arg3, arg4, arg5)	\
       |  182|    do {						\
       |  183|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  184|	if (!(condition)) {				\
       |  185|            NSString *__assert_fn__ = [NSString stringWithUTF8String:__PRETTY_FUNCTION__]; \
       |  186|            __assert_fn__ = __assert_fn__ ? __assert_fn__ : @"<Unknown Function>"; \
       |  187|            NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \
       |  188|            __assert_file__ = __assert_file__ ? __assert_file__ : @"<Unknown File>"; \
       |  189|	    [[NSAssertionHandler currentHandler] handleFailureInFunction:__assert_fn__ file:__assert_file__ \
       |  190|	    	lineNumber:__LINE__ description:(desc), (arg1), (arg2), (arg3), (arg4), (arg5)];	\
       |  191|	}						\
       |  192|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \
       |  193|    } while(0)
       |  194|#endif
       |  195|#else
       |  196|#if !defined(_NSAssertBody)
       |  197|#define _NSAssertBody(condition, desc, arg1, arg2, arg3, arg4, arg5)
       |  198|#endif
       |  199|#if !defined(_NSCAssertBody)
       |  200|#define _NSCAssertBody(condition, desc, arg1, arg2, arg3, arg4, arg5)
       |  201|#endif
       |  202|#endif
       |  203|
       |  204|
       |  205|/*
       |  206| * Asserts to use in Objective-C method bodies
       |  207| */
       |  208| 
       |  209|#if !defined(NSAssert)
       |  210|#define NSAssert5(condition, desc, arg1, arg2, arg3, arg4, arg5)	\
       |  211|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  212|    _NSAssertBody((condition), (desc), (arg1), (arg2), (arg3), (arg4), (arg5)) \
       |  213|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  214|
       |  215|#define NSAssert4(condition, desc, arg1, arg2, arg3, arg4)	\
       |  216|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  217|    _NSAssertBody((condition), (desc), (arg1), (arg2), (arg3), (arg4), 0) \
       |  218|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  219|
       |  220|#define NSAssert3(condition, desc, arg1, arg2, arg3)	\
       |  221|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  222|    _NSAssertBody((condition), (desc), (arg1), (arg2), (arg3), 0, 0) \
       |  223|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  224|
       |  225|#define NSAssert2(condition, desc, arg1, arg2)		\
       |  226|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  227|    _NSAssertBody((condition), (desc), (arg1), (arg2), 0, 0, 0) \
       |  228|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  229|
       |  230|#define NSAssert1(condition, desc, arg1)		\
       |  231|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  232|    _NSAssertBody((condition), (desc), (arg1), 0, 0, 0, 0) \
       |  233|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  234|
       |  235|#define NSAssert(condition, desc)			\
       |  236|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  237|    _NSAssertBody((condition), (desc), 0, 0, 0, 0, 0) \
       |  238|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  239|#endif
       |  240|
       |  241|#if !defined(NSParameterAssert)
       |  242|#define NSParameterAssert(condition)			\
       |  243|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  244|    _NSAssertBody((condition), @"Invalid parameter not satisfying: %s", #condition, 0, 0, 0, 0) \
       |  245|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  246|#endif
       |  247|
       |  248|
       |  249|#if !defined(NSCAssert)
       |  250|#define NSCAssert5(condition, desc, arg1, arg2, arg3, arg4, arg5)	\
       |  251|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  252|    _NSCAssertBody((condition), (desc), (arg1), (arg2), (arg3), (arg4), (arg5)) \
       |  253|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  254|
       |  255|#define NSCAssert4(condition, desc, arg1, arg2, arg3, arg4)	\
       |  256|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  257|    _NSCAssertBody((condition), (desc), (arg1), (arg2), (arg3), (arg4), 0) \
       |  258|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  259|
       |  260|#define NSCAssert3(condition, desc, arg1, arg2, arg3)	\
       |  261|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  262|    _NSCAssertBody((condition), (desc), (arg1), (arg2), (arg3), 0, 0) \
       |  263|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  264|
       |  265|#define NSCAssert2(condition, desc, arg1, arg2)	\
       |  266|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  267|    _NSCAssertBody((condition), (desc), (arg1), (arg2), 0, 0, 0) \
       |  268|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  269|
       |  270|#define NSCAssert1(condition, desc, arg1)		\
       |  271|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  272|    _NSCAssertBody((condition), (desc), (arg1), 0, 0, 0, 0) \
       |  273|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  274|
       |  275|#define NSCAssert(condition, desc)			\
       |  276|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  277|    _NSCAssertBody((condition), (desc), 0, 0, 0, 0, 0) \
       |  278|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  279|#endif
       |  280|
       |  281|#if !defined(NSCParameterAssert)
       |  282|#define NSCParameterAssert(condition)			\
       |  283|	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
       |  284|    _NSCAssertBody((condition), @"Invalid parameter not satisfying: %s", #condition, 0, 0, 0, 0) \
       |  285|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS
       |  286|#endif
       |  287|
       |  288|
       |  289|FOUNDATION_EXPORT NSString * const NSAssertionHandlerKey NS_AVAILABLE(10_6, 4_0);
       |  290|
       |  291|@interface NSAssertionHandler : NSObject {
       |  292|    @private
       |  293|    void *_reserved;
       |  294|}
       |  295|
       |  296|+ (NSAssertionHandler *)currentHandler;
       |  297|
       |  298|- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(nullable NSString *)format,... NS_FORMAT_FUNCTION(5,6);
       |  299|
       |  300|- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)fileName lineNumber:(NSInteger)line description:(nullable NSString *)format,... NS_FORMAT_FUNCTION(4,5);
       |  301|
       |  302|@end
       |  303|
       |  304|NS_ASSUME_NONNULL_END

/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.0.sdk/usr/include/MacTypes.h:
       |    1|/*
       |    2| * Copyright (c) 1985-2011 by Apple Inc.. All rights reserved.
       |    3| *
       |    4| * @APPLE_LICENSE_HEADER_START@
       |    5| * 
       |    6| * This file contains Original Code and/or Modifications of Original Code
       |    7| * as defined in and that are subject to the Apple Public Source License
       |    8| * Version 2.0 (the 'License'). You may not use this file except in
       |    9| * compliance with the License. Please obtain a copy of the License at
       |   10| * http://www.opensource.apple.com/apsl/ and read it before using this
       |   11| * file.
       |   12| * 
       |   13| * The Original Code and all software distributed under the License are
       |   14| * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
       |   15| * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
       |   16| * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
       |   17| * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
       |   18| * Please see the License for the specific language governing rights and
       |   19| * limitations under the License.
       |   20| * 
       |   21| * @APPLE_LICENSE_HEADER_END@
       |   22| */
       |   23| 
       |   24|/*
       |   25|     File:       MacTypes.h
       |   26| 
       |   27|     Contains:   Basic Macintosh data types.
       |   28| 
       |   29|     Version:    CarbonCore-769~1
       |   30|  
       |   31|     Bugs?:      For bug reports, consult the following page on
       |   32|                 the World Wide Web:
       |   33| 
       |   34|                     http://developer.apple.com/bugreporter/
       |   35| 
       |   36|*/
       |   37|#ifndef __MACTYPES__
       |   38|#define __MACTYPES__
       |   39|
       |   40|#ifndef __CONDITIONALMACROS__
       |   41|#include <ConditionalMacros.h>
       |   42|#endif
  ------------------
  | +[OCMMacroState endStubMacro]:
  |     51|   38|#define __MACTYPES__
  |     51|   39|
  |     51|   40|#ifndef __CONDITIONALMACROS__
  |     51|   41|#include <ConditionalMacros.h>
  |     51|   42|#endif
  ------------------
       |   43|
       |   44|#include <stdbool.h>
  ------------------
  | -[OCMBlockCaller handleInvocation:]:
  |      1|   39|
  |      1|   40|#ifndef __CONDITIONALMACROS__
  |      1|   41|#include <ConditionalMacros.h>
  |      1|   42|#endif
  |      1|   43|
  |      1|   44|#include <stdbool.h>
  ------------------
       |   45|
       |   46|#include <sys/types.h>
       |   47|
       |   48|#include <Availability.h>
  ------------------
  | +[OCMConstraint constraintWithSelector:onObject:]:
  |      0|   38|#define __MACTYPES__
  |      0|   39|
  |      0|   40|#ifndef __CONDITIONALMACROS__
  |      0|   41|#include <ConditionalMacros.h>
  |      0|   42|#endif
  |      0|   43|
  |      0|   44|#include <stdbool.h>
  |      0|   45|
  |      0|   46|#include <sys/types.h>
  |      0|   47|
  |      0|   48|#include <Availability.h>
  ------------------
       |   49|
       |   50|#if PRAGMA_ONCE
       |   51|#pragma once
  ------------------
  | -[OCProtocolMockObject methodSignatureForSelector:]:
  |      0|   42|#endif
  |      0|   43|
  |      0|   44|#include <stdbool.h>
  |      0|   45|
  |      0|   46|#include <sys/types.h>
  |      0|   47|
  |      0|   48|#include <Availability.h>
  |      0|   49|
  |      0|   50|#if PRAGMA_ONCE
  |      0|   51|#pragma once
  ------------------
       |   52|#endif
       |   53|
  ------------------
  | -[OCMReturnValueProvider handleInvocation:]:
  |     28|   41|#include <ConditionalMacros.h>
  |     28|   42|#endif
  |      0|   43|
  |      0|   44|#include <stdbool.h>
  |      0|   45|
  |     28|   46|#include <sys/types.h>
  |     28|   47|
  |      0|   48|#include <Availability.h>
  |      0|   49|
  |      0|   50|#if PRAGMA_ONCE
  |      0|   51|#pragma once
  |     28|   52|#endif
  |     28|   53|
  ------------------
       |   54|#ifdef __cplusplus
       |   55|extern "C" {
  ------------------
  | +[NSObject(OCMAdditions) instanceMethodForwarderForSelector:]:
  |    435|   24|/*
  |    435|   25|     File:       MacTypes.h
  |    435|   26| 
  |    435|   27|     Contains:   Basic Macintosh data types.
  |    435|   28| 
  |    435|   29|     Version:    CarbonCore-769~1
  |    435|   30|  
  |    435|   31|     Bugs?:      For bug reports, consult the following page on
  |      1|   32|                 the World Wide Web:
  |    435|   33| 
  |    435|   34|                     http://developer.apple.com/bugreporter/
  |    435|   35| 
  |    435|   36|*/
  |    435|   37|#ifndef __MACTYPES__
  |    435|   38|#define __MACTYPES__
  |    435|   39|
  |    124|   40|#ifndef __CONDITIONALMACROS__
  |    124|   41|#include <ConditionalMacros.h>
  |    124|   42|#endif
  |    124|   43|
  |    124|   44|#include <stdbool.h>
  |    435|   45|
  |    311|   46|#include <sys/types.h>
  |    311|   47|
  |    311|   48|#include <Availability.h>
  |    435|   49|
  |    435|   50|#if PRAGMA_ONCE
  |      3|   51|#pragma once
  |    435|   52|#endif
  |    435|   53|
  |    432|   54|#ifdef __cplusplus
  |    435|   55|extern "C" {
  ------------------
       |   56|#endif
       |   57|
       |   58|#pragma pack(push, 2)
       |   59|
  ------------------
  | -[OCClassMockObject stopMocking]:
  |     26|   55|extern "C" {
  |     26|   56|#endif
  |     11|   57|
  |     26|   58|#pragma pack(push, 2)
  |     26|   59|
  ------------------
       |   60|
       |   61|/*
  ------------------
  | -[OCProtocolMockObject respondsToSelector:]:
  |      0|   59|
  |      0|   60|
  |      0|   61|/*
  ------------------
       |   62|        CarbonCore Deprecation flags.
       |   63|
       |   64|     Certain Carbon API functions are deprecated in 10.3 and later
  ------------------
  | OCMNumberForValue:
  |      0|   45|
  |      0|   46|#include <sys/types.h>
  |      0|   47|
  |      0|   48|#include <Availability.h>
  |      0|   49|
  |      0|   50|#if PRAGMA_ONCE
  |      0|   51|#pragma once
  |      0|   52|#endif
  |      0|   53|
  |      0|   54|#ifdef __cplusplus
  |      0|   55|extern "C" {
  |      0|   56|#endif
  |      0|   57|
  |      0|   58|#pragma pack(push, 2)
  |      0|   59|
  |      0|   60|
  |      0|   61|/*
  |      0|   62|        CarbonCore Deprecation flags.
  |      0|   63|
  |      0|   64|     Certain Carbon API functions are deprecated in 10.3 and later
  ------------------
       |   65|      systems.  These will produce a warning when compiling on 10.3.
       |   66|
  ------------------
  | -[OCClassMockObject restoreMetaClass]:
  |     18|   62|        CarbonCore Deprecation flags.
  |     18|   63|
  |     18|   64|     Certain Carbon API functions are deprecated in 10.3 and later
  |     18|   65|      systems.  These will produce a warning when compiling on 10.3.
  |     18|   66|
  ------------------
       |   67|        Other functions and constants do not produce meaningful
  ------------------
  | +[OCMMacroState endVerifyMacro]:
  |      0|   65|      systems.  These will produce a warning when compiling on 10.3.
  |      0|   66|
  |      0|   67|        Other functions and constants do not produce meaningful
  ------------------
       |   68|        results when building Carbon for Mac OS X.  For these
       |   69|      functions, no-op macros are provided, but only when the
       |   70|        ALLOW_OBSOLETE_CARBON flag is defined to be 0: eg
  ------------------
  | -[OCPartialMockObject assertClassIsSupported:]:
  |      8|   60|
  |      8|   61|/*
  |      8|   62|        CarbonCore Deprecation flags.
  |      8|   63|
  |      0|   64|     Certain Carbon API functions are deprecated in 10.3 and later
  |      8|   65|      systems.  These will produce a warning when compiling on 10.3.
  |      0|   66|
  |      8|   67|        Other functions and constants do not produce meaningful
  |      8|   68|        results when building Carbon for Mac OS X.  For these
  |      0|   69|      functions, no-op macros are provided, but only when the
  |      8|   70|        ALLOW_OBSOLETE_CARBON flag is defined to be 0: eg
  ------------------
       |   71|      -DALLOW_OBSOLETE_CARBON=0.
       |   72|*/
       |   73|
  ------------------
  | +[NSObject(OCMAdditions) enumerateMethodsInClass:usingBlock:]:
  |     27|   59|
  |     99|   60|
  |     72|   61|/*
  |     72|   62|        CarbonCore Deprecation flags.
  |     72|   63|
  |      7|   64|     Certain Carbon API functions are deprecated in 10.3 and later
  |     72|   65|      systems.  These will produce a warning when compiling on 10.3.
  |  34.1k|   66|
  |  34.0k|   67|        Other functions and constants do not produce meaningful
  |  34.0k|   68|        results when building Carbon for Mac OS X.  For these
  |  34.0k|   69|      functions, no-op macros are provided, but only when the
  |  34.0k|   70|        ALLOW_OBSOLETE_CARBON flag is defined to be 0: eg
  |     65|   71|      -DALLOW_OBSOLETE_CARBON=0.
  |     65|   72|*/
  |     27|   73|
  ------------------
       |   74|#if  ! defined(ALLOW_OBSOLETE_CARBON) || ! ALLOW_OBSOLETE_CARBON
       |   75|
       |   76|#define ALLOW_OBSOLETE_CARBON_MACMEMORY        0
       |   77|#define ALLOW_OBSOLETE_CARBON_OSUTILS     0
       |   78|
       |   79|#else
       |   80|
  ------------------
  | -[OCObserverMockObject verify]:
  |      0|   78|
  |      0|   79|#else
  |      0|   80|
  ------------------
       |   81|#define ALLOW_OBSOLETE_CARBON_MACMEMORY       1       /* Removes obsolete constants; turns HLock/HUnlock into no-op macros */
       |   82|#define ALLOW_OBSOLETE_CARBON_OSUTILS       1       /* Removes obsolete structures */
       |   83|
       |   84|#endif
  ------------------
  | -[OCMObserverRecorder argument:matchesArgument:]:
  |      0|   63|
  |      0|   64|     Certain Carbon API functions are deprecated in 10.3 and later
  |      0|   65|      systems.  These will produce a warning when compiling on 10.3.
  |      0|   66|
  |      0|   67|        Other functions and constants do not produce meaningful
  |      0|   68|        results when building Carbon for Mac OS X.  For these
  |      0|   69|      functions, no-op macros are provided, but only when the
  |      0|   70|        ALLOW_OBSOLETE_CARBON flag is defined to be 0: eg
  |      0|   71|      -DALLOW_OBSOLETE_CARBON=0.
  |      0|   72|*/
  |      0|   73|
  |      0|   74|#if  ! defined(ALLOW_OBSOLETE_CARBON) || ! ALLOW_OBSOLETE_CARBON
  |      0|   75|
  |      0|   76|#define ALLOW_OBSOLETE_CARBON_MACMEMORY        0
  |      0|   77|#define ALLOW_OBSOLETE_CARBON_OSUTILS     0
  |      0|   78|
  |      0|   79|#else
  |      0|   80|
  |      0|   81|#define ALLOW_OBSOLETE_CARBON_MACMEMORY       1       /* Removes obsolete constants; turns HLock/HUnlock into no-op macros */
  |      0|   82|#define ALLOW_OBSOLETE_CARBON_OSUTILS       1       /* Removes obsolete structures */
  |      0|   83|
  |      0|   84|#endif
  ------------------
  | -[OCMIsNilConstraint evaluate:]:
  |      0|   82|#define ALLOW_OBSOLETE_CARBON_OSUTILS       1       /* Removes obsolete structures */
  |      0|   83|
  |      0|   84|#endif
  ------------------
       |   85|
  ------------------
  | -[OCPartialMockObject stopMocking]:
  |     16|   76|#define ALLOW_OBSOLETE_CARBON_MACMEMORY        0
  |     16|   77|#define ALLOW_OBSOLETE_CARBON_OSUTILS     0
  |      8|   78|
  |      8|   79|#else
  |      8|   80|
  |      8|   81|#define ALLOW_OBSOLETE_CARBON_MACMEMORY       1       /* Removes obsolete constants; turns HLock/HUnlock into no-op macros */
  |      8|   82|#define ALLOW_OBSOLETE_CARBON_OSUTILS       1       /* Removes obsolete structures */
  |      8|   83|
  |     16|   84|#endif
  |     16|   85|
  ------------------
       |   86|#ifndef NULL
       |   87|#define NULL    __DARWIN_NULL
       |   88|#endif /* ! NULL */
       |   89|#ifndef nil
       |   90|  #if defined(__has_feature) 
       |   91|    #if __has_feature(cxx_nullptr)
       |   92|      #define nil nullptr
       |   93|    #else
  2.77k|   94|      #define nil __DARWIN_NULL
       |   95|    #endif
  ------------------
  | -[OCMRecorder methodSignatureForSelector:]:
  |     59|   79|#else
  |     59|   80|
  |      5|   81|#define ALLOW_OBSOLETE_CARBON_MACMEMORY       1       /* Removes obsolete constants; turns HLock/HUnlock into no-op macros */
  |     59|   82|#define ALLOW_OBSOLETE_CARBON_OSUTILS       1       /* Removes obsolete structures */
  |     54|   83|
  |     54|   84|#endif
  |      0|   85|
  |      0|   86|#ifndef NULL
  |      0|   87|#define NULL    __DARWIN_NULL
  |      0|   88|#endif /* ! NULL */
  |      0|   89|#ifndef nil
  |      0|   90|  #if defined(__has_feature) 
  |      0|   91|    #if __has_feature(cxx_nullptr)
  |      0|   92|      #define nil nullptr
  |      0|   93|    #else
  |     54|   94|      #define nil __DARWIN_NULL
  |     59|   95|    #endif
  ------------------
       |   96|  #else
  ------------------
  | -[OCMMacroState dealloc]:
  |     51|   91|    #if __has_feature(cxx_nullptr)
  |     51|   92|      #define nil nullptr
  |     51|   93|    #else
  |      0|   94|      #define nil __DARWIN_NULL
  |     51|   95|    #endif
  |     51|   96|  #else
  ------------------
       |   97|    #define nil __DARWIN_NULL
  ------------------
  | -[OCMIsNotNilConstraint evaluate:]:
  |      0|   95|    #endif
  |      0|   96|  #else
  |      0|   97|    #define nil __DARWIN_NULL
  ------------------
       |   98|  #endif
       |   99|#endif
       |  100|
       |  101|/********************************************************************************
  ------------------
  | -[OCMRecorder forwardInvocation:]:
  |     59|   98|  #endif
  |     59|   99|#endif
  |     59|  100|
  |     59|  101|/********************************************************************************
  ------------------
       |  102|
       |  103|    Base integer types for all target OS's and CPU's
       |  104|    
       |  105|        UInt8            8-bit unsigned integer 
       |  106|        SInt8            8-bit signed integer
       |  107|        UInt16          16-bit unsigned integer 
       |  108|        SInt16          16-bit signed integer           
       |  109|        UInt32          32-bit unsigned integer 
       |  110|        SInt32          32-bit signed integer   
       |  111|        UInt64          64-bit unsigned integer 
       |  112|        SInt64          64-bit signed integer   
       |  113|
       |  114|*********************************************************************************/
       |  115|typedef unsigned char                   UInt8;
       |  116|typedef signed char                     SInt8;
       |  117|typedef unsigned short                  UInt16;
       |  118|typedef signed short                    SInt16;
       |  119|
       |  120|#if __LP64__
       |  121|typedef unsigned int                    UInt32;
       |  122|typedef signed int                      SInt32;
  ------------------
  | __41-[OCMStubRecorder(Properties) _andReturn]_block_invoke:
  |     41|  111|        UInt64          64-bit unsigned integer 
  |     41|  112|        SInt64          64-bit signed integer   
  |     30|  113|
  |     30|  114|*********************************************************************************/
  |     30|  115|typedef unsigned char                   UInt8;
  |     30|  116|typedef signed char                     SInt8;
  |     30|  117|typedef unsigned short                  UInt16;
  |     41|  118|typedef signed short                    SInt16;
  |     11|  119|
  |     11|  120|#if __LP64__
  |     11|  121|typedef unsigned int                    UInt32;
  |     41|  122|typedef signed int                      SInt32;
  ------------------
       |  123|#else
       |  124|typedef unsigned long                   UInt32;
       |  125|typedef signed long                     SInt32;
       |  126|#endif
       |  127|
       |  128|/* avoid redeclaration if libkern/OSTypes.h */
       |  129|#ifndef _OS_OSTYPES_H
       |  130|#if TARGET_RT_BIG_ENDIAN
       |  131|struct wide {
  ------------------
  | -[OCClassMockObject prepareClassForClassMethodMocking]:
  |     19|   79|#else
  |     19|   80|
  |     19|   81|#define ALLOW_OBSOLETE_CARBON_MACMEMORY       1       /* Removes obsolete constants; turns HLock/HUnlock into no-op macros */
  |     19|   82|#define ALLOW_OBSOLETE_CARBON_OSUTILS       1       /* Removes obsolete structures */
  |      0|   83|
  |     19|   84|#endif
  |     19|   85|
  |     19|   86|#ifndef NULL
  |     19|   87|#define NULL    __DARWIN_NULL
  |      7|   88|#endif /* ! NULL */
  |     19|   89|#ifndef nil
  |     19|   90|  #if defined(__has_feature) 
  |     19|   91|    #if __has_feature(cxx_nullptr)
  |     19|   92|      #define nil nullptr
  |     19|   93|    #else
  |     19|   94|      #define nil __DARWIN_NULL
  |     19|   95|    #endif
  |     19|   96|  #else
  |     19|   97|    #define nil __DARWIN_NULL
  |     19|   98|  #endif
  |     19|   99|#endif
  |     19|  100|
  |     19|  101|/********************************************************************************
  |     19|  102|
  |     19|  103|    Base integer types for all target OS's and CPU's
  |     19|  104|    
  |     19|  105|        UInt8            8-bit unsigned integer 
  |     19|  106|        SInt8            8-bit signed integer
  |     19|  107|        UInt16          16-bit unsigned integer 
  |     19|  108|        SInt16          16-bit signed integer           
  |     19|  109|        UInt32          32-bit unsigned integer 
  |     19|  110|        SInt32          32-bit signed integer   
  |     19|  111|        UInt64          64-bit unsigned integer 
  |     19|  112|        SInt64          64-bit signed integer   
  |     19|  113|
  |     19|  114|*********************************************************************************/
  |     19|  115|typedef unsigned char                   UInt8;
  |     19|  116|typedef signed char                     SInt8;
  |     19|  117|typedef unsigned short                  UInt16;
  |     19|  118|typedef signed short                    SInt16;
  |     19|  119|
  |     19|  120|#if __LP64__
  |     19|  121|typedef unsigned int                    UInt32;
  |     19|  122|typedef signed int                      SInt32;
  |     19|  123|#else
  |     19|  124|typedef unsigned long                   UInt32;
  |     19|  125|typedef signed long                     SInt32;
  |     19|  126|#endif
  |     19|  127|
  |     19|  128|/* avoid redeclaration if libkern/OSTypes.h */
  |     19|  129|#ifndef _OS_OSTYPES_H
  |     19|  130|#if TARGET_RT_BIG_ENDIAN
  |     19|  131|struct wide {
  ------------------
       |  132|  SInt32              hi;
       |  133|  UInt32              lo;
       |  134|};
       |  135|typedef struct wide                     wide;
       |  136|struct UnsignedWide {
       |  137|  UInt32              hi;
       |  138|  UInt32              lo;
       |  139|};
       |  140|typedef struct UnsignedWide             UnsignedWide;
       |  141|#else
       |  142|struct wide {
       |  143|  UInt32              lo;
       |  144|  SInt32              hi;
       |  145|};
       |  146|typedef struct wide                     wide;
       |  147|struct UnsignedWide {
       |  148|  UInt32              lo;
       |  149|  UInt32              hi;
  ------------------
  | -[OCMInvocationMatcher matchesInvocation:]:
  |    413|   88|#endif /* ! NULL */
  |    413|   89|#ifndef nil
  |    413|   90|  #if defined(__has_feature) 
  |    413|   91|    #if __has_feature(cxx_nullptr)
  |     67|   92|      #define nil nullptr
  |    413|   93|    #else
  |    346|   94|      #define nil __DARWIN_NULL
  |    298|   95|    #endif
  |    346|   96|  #else
  |     48|   97|    #define nil __DARWIN_NULL
  |     48|   98|  #endif
  |     72|   99|#endif
  |     39|  100|
  |     39|  101|/********************************************************************************
  |      0|  102|
  |      0|  103|    Base integer types for all target OS's and CPU's
  |      0|  104|    
  |     39|  105|        UInt8            8-bit unsigned integer 
  |     39|  106|        SInt8            8-bit signed integer
  |     39|  107|        UInt16          16-bit unsigned integer 
  |     39|  108|        SInt16          16-bit signed integer           
  |     39|  109|        UInt32          32-bit unsigned integer 
  |      0|  110|        SInt32          32-bit signed integer   
  |      0|  111|        UInt64          64-bit unsigned integer 
  |      0|  112|        SInt64          64-bit signed integer   
  |      0|  113|
  |      0|  114|*********************************************************************************/
  |     39|  115|typedef unsigned char                   UInt8;
  |     39|  116|typedef signed char                     SInt8;
  |      0|  117|typedef unsigned short                  UInt16;
  |     39|  118|typedef signed short                    SInt16;
  |     39|  119|
  |      1|  120|#if __LP64__
  |      1|  121|typedef unsigned int                    UInt32;
  |      0|  122|typedef signed int                      SInt32;
  |      1|  123|#else
  |     38|  124|typedef unsigned long                   UInt32;
  |      0|  125|typedef signed long                     SInt32;
  |      0|  126|#endif
  |      0|  127|
  |      0|  128|/* avoid redeclaration if libkern/OSTypes.h */
  |      0|  129|#ifndef _OS_OSTYPES_H
  |      0|  130|#if TARGET_RT_BIG_ENDIAN
  |      0|  131|struct wide {
  |      0|  132|  SInt32              hi;
  |     38|  133|  UInt32              lo;
  |      0|  134|};
  |      0|  135|typedef struct wide                     wide;
  |      0|  136|struct UnsignedWide {
  |      0|  137|  UInt32              hi;
  |     38|  138|  UInt32              lo;
  |     38|  139|};
  |     38|  140|typedef struct UnsignedWide             UnsignedWide;
  |      0|  141|#else
  |      0|  142|struct wide {
  |     38|  143|  UInt32              lo;
  |     15|  144|  SInt32              hi;
  |     15|  145|};
  |     38|  146|typedef struct wide                     wide;
  |     39|  147|struct UnsignedWide {
  |     33|  148|  UInt32              lo;
  |     48|  149|  UInt32              hi;
  ------------------
       |  150|};
       |  151|typedef struct UnsignedWide             UnsignedWide;
       |  152|#endif  /* TARGET_RT_BIG_ENDIAN */
       |  153|
       |  154|#endif
       |  155|
       |  156|#if TYPE_LONGLONG
  ------------------
  | -[OCMockObject verify]:
  |      0|  154|#endif
  |      0|  155|
  |      0|  156|#if TYPE_LONGLONG
  ------------------
       |  157|/*
       |  158|  Note:   wide and UnsignedWide must always be structs for source code
       |  159|           compatibility. On the other hand UInt64 and SInt64 can be
       |  160|          either a struct or a long long, depending on the compiler.
       |  161|         
       |  162|           If you use UInt64 and SInt64 you should do all operations on 
       |  163|          those data types through the functions/macros in Math64.h.  
  ------------------
  | -[NSInvocation(OCMAdditions) getArgumentAtIndexAsObject:]:
  |     78|   37|#ifndef __MACTYPES__
  |     78|   38|#define __MACTYPES__
  |     78|   39|
  |     78|   40|#ifndef __CONDITIONALMACROS__
  |      0|   41|#include <ConditionalMacros.h>
  |     78|   42|#endif
  |     78|   43|
  |     78|   44|#include <stdbool.h>
  |     78|   45|
  |     78|   46|#include <sys/types.h>
  |     78|   47|
  |     78|   48|#include <Availability.h>
  |     78|   49|
  |      0|   50|#if PRAGMA_ONCE
  |      0|   51|#pragma once
  |      0|   52|#endif
  |      0|   53|
  |      0|   54|#ifdef __cplusplus
  |      0|   55|extern "C" {
  |      0|   56|#endif
  |      0|   57|
  |      0|   58|#pragma pack(push, 2)
  |      0|   59|
  |      0|   60|
  |      0|   61|/*
  |      0|   62|        CarbonCore Deprecation flags.
  |      0|   63|
  |      0|   64|     Certain Carbon API functions are deprecated in 10.3 and later
  |      0|   65|      systems.  These will produce a warning when compiling on 10.3.
  |      0|   66|
  |      0|   67|        Other functions and constants do not produce meaningful
  |      0|   68|        results when building Carbon for Mac OS X.  For these
  |      0|   69|      functions, no-op macros are provided, but only when the
  |      0|   70|        ALLOW_OBSOLETE_CARBON flag is defined to be 0: eg
  |      0|   71|      -DALLOW_OBSOLETE_CARBON=0.
  |      0|   72|*/
  |      0|   73|
  |      0|   74|#if  ! defined(ALLOW_OBSOLETE_CARBON) || ! ALLOW_OBSOLETE_CARBON
  |      0|   75|
  |      0|   76|#define ALLOW_OBSOLETE_CARBON_MACMEMORY        0
  |      0|   77|#define ALLOW_OBSOLETE_CARBON_OSUTILS     0
  |      0|   78|
  |      0|   79|#else
  |      0|   80|
  |      0|   81|#define ALLOW_OBSOLETE_CARBON_MACMEMORY       1       /* Removes obsolete constants; turns HLock/HUnlock into no-op macros */
  |      0|   82|#define ALLOW_OBSOLETE_CARBON_OSUTILS       1       /* Removes obsolete structures */
  |      0|   83|
  |      0|   84|#endif
  |      0|   85|
  |      0|   86|#ifndef NULL
  |      0|   87|#define NULL    __DARWIN_NULL
  |      0|   88|#endif /* ! NULL */
  |      0|   89|#ifndef nil
  |      0|   90|  #if defined(__has_feature) 
  |      0|   91|    #if __has_feature(cxx_nullptr)
  |      0|   92|      #define nil nullptr
  |      0|   93|    #else
  |      0|   94|      #define nil __DARWIN_NULL
  |      0|   95|    #endif
  |      0|   96|  #else
  |      0|   97|    #define nil __DARWIN_NULL
  |      0|   98|  #endif
  |      0|   99|#endif
  |      0|  100|
  |      0|  101|/********************************************************************************
  |      0|  102|
  |      0|  103|    Base integer types for all target OS's and CPU's
  |      0|  104|    
  |      0|  105|        UInt8            8-bit unsigned integer 
  |      0|  106|        SInt8            8-bit signed integer
  |      0|  107|        UInt16          16-bit unsigned integer 
  |      0|  108|        SInt16          16-bit signed integer           
  |      0|  109|        UInt32          32-bit unsigned integer 
  |      0|  110|        SInt32          32-bit signed integer   
  |      0|  111|        UInt64          64-bit unsigned integer 
  |      0|  112|        SInt64          64-bit signed integer   
  |      0|  113|
  |      0|  114|*********************************************************************************/
  |      0|  115|typedef unsigned char                   UInt8;
  |      0|  116|typedef signed char                     SInt8;
  |      0|  117|typedef unsigned short                  UInt16;
  |      0|  118|typedef signed short                    SInt16;
  |      0|  119|
  |      0|  120|#if __LP64__
  |      0|  121|typedef unsigned int                    UInt32;
  |      0|  122|typedef signed int                      SInt32;
  |      0|  123|#else
  |      0|  124|typedef unsigned long                   UInt32;
  |      0|  125|typedef signed long                     SInt32;
  |      0|  126|#endif
  |      0|  127|
  |      0|  128|/* avoid redeclaration if libkern/OSTypes.h */
  |      0|  129|#ifndef _OS_OSTYPES_H
  |      0|  130|#if TARGET_RT_BIG_ENDIAN
  |      0|  131|struct wide {
  |      0|  132|  SInt32              hi;
  |      0|  133|  UInt32              lo;
  |      0|  134|};
  |      0|  135|typedef struct wide                     wide;
  |      0|  136|struct UnsignedWide {
  |      0|  137|  UInt32              hi;
  |      0|  138|  UInt32              lo;
  |      0|  139|};
  |      0|  140|typedef struct UnsignedWide             UnsignedWide;
  |      0|  141|#else
  |      0|  142|struct wide {
  |      0|  143|  UInt32              lo;
  |      0|  144|  SInt32              hi;
  |      0|  145|};
  |      0|  146|typedef struct wide                     wide;
  |      0|  147|struct UnsignedWide {
  |      0|  148|  UInt32              lo;
  |      0|  149|  UInt32              hi;
  |      0|  150|};
  |      0|  151|typedef struct UnsignedWide             UnsignedWide;
  |      0|  152|#endif  /* TARGET_RT_BIG_ENDIAN */
  |      0|  153|
  |      0|  154|#endif
  |      0|  155|
  |      0|  156|#if TYPE_LONGLONG
  |      0|  157|/*
  |      0|  158|  Note:   wide and UnsignedWide must always be structs for source code
  |      0|  159|           compatibility. On the other hand UInt64 and SInt64 can be
  |      0|  160|          either a struct or a long long, depending on the compiler.
  |      0|  161|         
  |      0|  162|           If you use UInt64 and SInt64 you should do all operations on 
  |      0|  163|          those data types through the functions/macros in Math64.h.  
  ------------------
  | -[OCClassMockObject forwardInvocationForClassObject:]:
  |      2|  151|typedef struct UnsignedWide             UnsignedWide;
  |      2|  152|#endif  /* TARGET_RT_BIG_ENDIAN */
  |      2|  153|
  |      2|  154|#endif
  |      0|  155|
  |      0|  156|#if TYPE_LONGLONG
  |      0|  157|/*
  |      2|  158|  Note:   wide and UnsignedWide must always be structs for source code
  |      0|  159|           compatibility. On the other hand UInt64 and SInt64 can be
  |      0|  160|          either a struct or a long long, depending on the compiler.
  |      0|  161|         
  |      0|  162|           If you use UInt64 and SInt64 you should do all operations on 
  |      2|  163|          those data types through the functions/macros in Math64.h.  
  ------------------
       |  164|           This will assure that your code compiles with compilers that
       |  165|           support long long and those that don't.
       |  166|            
       |  167|           The MS Visual C/C++ compiler uses __int64 instead of long long. 
       |  168|*/
       |  169|    #if defined(_MSC_VER) && !defined(__MWERKS__) && defined(_M_IX86)
       |  170|      typedef   signed __int64                SInt64;
       |  171|        typedef unsigned __int64                UInt64;
       |  172|    #else
       |  173|      typedef   signed long long              SInt64;
       |  174|        typedef unsigned long long              UInt64;
       |  175|    #endif
       |  176|#else
       |  177|
       |  178|
       |  179|typedef wide                            SInt64;
       |  180|typedef UnsignedWide                    UInt64;
       |  181|#endif  /* TYPE_LONGLONG */
  ------------------
  | -[OCPartialMockObject classForRealObject]:
  |    354|  175|    #endif
  |    354|  176|#else
  |    354|  177|
  |    354|  178|
  |      0|  179|typedef wide                            SInt64;
  |    354|  180|typedef UnsignedWide                    UInt64;
  |    354|  181|#endif  /* TYPE_LONGLONG */
  ------------------
       |  182|
       |  183|/********************************************************************************
       |  184|
       |  185|    Base fixed point types 
       |  186|    
       |  187|        Fixed           16-bit signed integer plus 16-bit fraction
       |  188|        UnsignedFixed   16-bit unsigned integer plus 16-bit fraction
       |  189|        Fract           2-bit signed integer plus 30-bit fraction
       |  190|        ShortFixed      8-bit signed integer plus 8-bit fraction
       |  191|        
       |  192|*********************************************************************************/
       |  193|typedef SInt32                          Fixed;
       |  194|typedef Fixed *                         FixedPtr;
  ------------------
  | -[OCPartialMockObject forwardingTargetForSelectorForRealObject:]:
  |     80|  185|    Base fixed point types 
  |     80|  186|    
  |     80|  187|        Fixed           16-bit signed integer plus 16-bit fraction
  |     80|  188|        UnsignedFixed   16-bit unsigned integer plus 16-bit fraction
  |      0|  189|        Fract           2-bit signed integer plus 30-bit fraction
  |     80|  190|        ShortFixed      8-bit signed integer plus 8-bit fraction
  |     14|  191|        
  |     80|  192|*********************************************************************************/
  |     66|  193|typedef SInt32                          Fixed;
  |     80|  194|typedef Fixed *                         FixedPtr;
  ------------------
  | -[OCMockObject verifyWithDelay:]:
  |      0|  192|*********************************************************************************/
  |      0|  193|typedef SInt32                          Fixed;
  |      0|  194|typedef Fixed *                         FixedPtr;
  ------------------
       |  195|typedef SInt32                          Fract;
       |  196|typedef Fract *                         FractPtr;
       |  197|typedef UInt32                          UnsignedFixed;
       |  198|typedef UnsignedFixed *                 UnsignedFixedPtr;
       |  199|typedef short                           ShortFixed;
       |  200|typedef ShortFixed *                    ShortFixedPtr;
  ------------------
  | -[OCPartialMockObject ocmock_replaced_forwardingTargetForSelector:]:
  |      0|  198|typedef UnsignedFixed *                 UnsignedFixedPtr;
  |      0|  199|typedef short                           ShortFixed;
  |      0|  200|typedef ShortFixed *                    ShortFixedPtr;
  ------------------
       |  201|
       |  202|
       |  203|/********************************************************************************
       |  204|
       |  205|    Base floating point types 
       |  206|    
       |  207|        Float32         32 bit IEEE float:  1 sign bit, 8 exponent bits, 23 fraction bits
       |  208|        Float64         64 bit IEEE float:  1 sign bit, 11 exponent bits, 52 fraction bits  
       |  209|        Float80         80 bit MacOS float: 1 sign bit, 15 exponent bits, 1 integer bit, 63 fraction bits
       |  210|        Float96         96 bit 68881 float: 1 sign bit, 15 exponent bits, 16 pad bits, 1 integer bit, 63 fraction bits
       |  211|        
       |  212|    Note: These are fixed size floating point types, useful when writing a floating
       |  213|          point value to disk.  If your compiler does not support a particular size 
       |  214|          float, a struct is used instead.
       |  215|          Use of of the NCEG types (e.g. double_t) or an ANSI C type (e.g. double) if
  ------------------
  | -[OCPartialMockObject forwardInvocationForRealObject:]:
  |     80|  204|
  |     80|  205|    Base floating point types 
  |     80|  206|    
  |     80|  207|        Float32         32 bit IEEE float:  1 sign bit, 8 exponent bits, 23 fraction bits
  |      0|  208|        Float64         64 bit IEEE float:  1 sign bit, 11 exponent bits, 52 fraction bits  
  |     80|  209|        Float80         80 bit MacOS float: 1 sign bit, 15 exponent bits, 1 integer bit, 63 fraction bits
  |     80|  210|        Float96         96 bit 68881 float: 1 sign bit, 15 exponent bits, 16 pad bits, 1 integer bit, 63 fraction bits
  |     66|  211|        
  |     66|  212|    Note: These are fixed size floating point types, useful when writing a floating
  |     66|  213|          point value to disk.  If your compiler does not support a particular size 
  |     66|  214|          float, a struct is used instead.
  |     80|  215|          Use of of the NCEG types (e.g. double_t) or an ANSI C type (e.g. double) if
  ------------------
       |  216|          you want a floating point representation that is natural for any given
  ------------------
  | -[OCMockObject verifyInvocation:]:
  |      0|  214|          float, a struct is used instead.
  |      0|  215|          Use of of the NCEG types (e.g. double_t) or an ANSI C type (e.g. double) if
  |      0|  216|          you want a floating point representation that is natural for any given
  ------------------
       |  217|          compiler, but might be a different size on different compilers.
       |  218|
       |  219|*********************************************************************************/
       |  220|typedef float               Float32;
       |  221|typedef double              Float64;
       |  222|struct Float80 {
       |  223|    SInt16  exp;
       |  224|    UInt16  man[4];
       |  225|};
       |  226|typedef struct Float80 Float80;
       |  227|
  ------------------
  | OCMSetAssociatedMockForClass:
  |     37|  223|    SInt16  exp;
  |     37|  224|    UInt16  man[4];
  |      0|  225|};
  |     37|  226|typedef struct Float80 Float80;
  |     37|  227|
  ------------------
       |  228|struct Float96 {
  ------------------
  | -[NSInvocation(OCMAdditions) objectDescriptionAtIndex:]:
  |      0|  217|          compiler, but might be a different size on different compilers.
  |      0|  218|
  |      0|  219|*********************************************************************************/
  |      0|  220|typedef float               Float32;
  |      0|  221|typedef double              Float64;
  |      0|  222|struct Float80 {
  |      0|  223|    SInt16  exp;
  |      0|  224|    UInt16  man[4];
  |      0|  225|};
  |      0|  226|typedef struct Float80 Float80;
  |      0|  227|
  |      0|  228|struct Float96 {
  ------------------
       |  229|    SInt16  exp[2];     /* the second 16-bits are undefined */
       |  230|    UInt16  man[4];
       |  231|};
       |  232|typedef struct Float96 Float96;
       |  233|struct Float32Point {
       |  234|    Float32             x;
       |  235|    Float32             y;
       |  236|};
       |  237|typedef struct Float32Point Float32Point;
       |  238|
       |  239|/********************************************************************************
  ------------------
  | OCMGetAssociatedMockForClass:
  |     21|  230|    UInt16  man[4];
  |     21|  231|};
  |     21|  232|typedef struct Float96 Float96;
  |     21|  233|struct Float32Point {
  |     21|  234|    Float32             x;
  |     21|  235|    Float32             y;
  |     21|  236|};
  |     21|  237|typedef struct Float32Point Float32Point;
  |     21|  238|
  |     21|  239|/********************************************************************************
  ------------------
       |  240|
       |  241|    MacOS Memory Manager types
       |  242|    
       |  243|        Ptr             Pointer to a non-relocatable block
  ------------------
  | -[OCMockObject forwardingTargetForSelector:]:
  |     88|  235|    Float32             y;
  |     88|  236|};
  |     51|  237|typedef struct Float32Point Float32Point;
  |     51|  238|
  |     51|  239|/********************************************************************************
  |     51|  240|
  |     51|  241|    MacOS Memory Manager types
  |     37|  242|    
  |     88|  243|        Ptr             Pointer to a non-relocatable block
  ------------------
       |  244|        Handle          Pointer to a master pointer to a relocatable block
       |  245|        Size            The number of bytes in a block (signed for historical reasons)
       |  246|        
       |  247|*********************************************************************************/
       |  248|typedef char *                          Ptr;
  ------------------
  | OCMSetAssociatedMockForObject:
  |     16|  244|        Handle          Pointer to a master pointer to a relocatable block
  |     16|  245|        Size            The number of bytes in a block (signed for historical reasons)
  |      0|  246|        
  |     16|  247|*********************************************************************************/
  |     16|  248|typedef char *                          Ptr;
  ------------------
       |  249|typedef Ptr *                           Handle;
       |  250|typedef long                            Size;
       |  251|
       |  252|/********************************************************************************
       |  253|
       |  254|    Higher level basic types
       |  255|    
       |  256|        OSErr                   16-bit result error code
       |  257|        OSStatus                32-bit result error code
       |  258|        LogicalAddress          Address in the clients virtual address space
       |  259|        ConstLogicalAddress     Address in the clients virtual address space that will only be read
       |  260|        PhysicalAddress         Real address as used on the hardware bus
       |  261|        BytePtr                 Pointer to an array of bytes
       |  262|        ByteCount               The size of an array of bytes
       |  263|        ByteOffset              An offset into an array of bytes
       |  264|        ItemCount               32-bit iteration count
       |  265|        OptionBits              Standard 32-bit set of bit flags
       |  266|        PBVersion               ?
       |  267|        Duration                32-bit millisecond timer for drivers
       |  268|        AbsoluteTime            64-bit clock
       |  269|        ScriptCode              A particular set of written characters (e.g. Roman vs Cyrillic) and their encoding
       |  270|        LangCode                A particular language (e.g. English), as represented using a particular ScriptCode
       |  271|        RegionCode              Designates a language as used in a particular region (e.g. British vs American
       |  272|                                English) together with other region-dependent characteristics (e.g. date format)
       |  273|        FourCharCode            A 32-bit value made by packing four 1 byte characters together
       |  274|        OSType                  A FourCharCode used in the OS and file system (e.g. creator)
       |  275|        ResType                 A FourCharCode used to tag resources (e.g. 'DLOG')
       |  276|        
       |  277|*********************************************************************************/
       |  278|typedef SInt16                          OSErr;
       |  279|typedef SInt32                          OSStatus;
       |  280|typedef void *                          LogicalAddress;
       |  281|typedef const void *                    ConstLogicalAddress;
       |  282|typedef void *                          PhysicalAddress;
       |  283|typedef UInt8 *                         BytePtr;
       |  284|typedef unsigned long                   ByteCount;
       |  285|typedef unsigned long                   ByteOffset;
       |  286|typedef SInt32                          Duration;
       |  287|typedef UnsignedWide                    AbsoluteTime;
       |  288|typedef UInt32                          OptionBits;
       |  289|typedef unsigned long                   ItemCount;
       |  290|typedef UInt32                          PBVersion;
       |  291|typedef SInt16                          ScriptCode;
       |  292|typedef SInt16                          LangCode;
  ------------------
  | OCMReportFailure:
  |      0|  259|        ConstLogicalAddress     Address in the clients virtual address space that will only be read
  |      0|  260|        PhysicalAddress         Real address as used on the hardware bus
  |      0|  261|        BytePtr                 Pointer to an array of bytes
  |      0|  262|        ByteCount               The size of an array of bytes
  |      0|  263|        ByteOffset              An offset into an array of bytes
  |      0|  264|        ItemCount               32-bit iteration count
  |      0|  265|        OptionBits              Standard 32-bit set of bit flags
  |      0|  266|        PBVersion               ?
  |      0|  267|        Duration                32-bit millisecond timer for drivers
  |      0|  268|        AbsoluteTime            64-bit clock
  |      0|  269|        ScriptCode              A particular set of written characters (e.g. Roman vs Cyrillic) and their encoding
  |      0|  270|        LangCode                A particular language (e.g. English), as represented using a particular ScriptCode
  |      0|  271|        RegionCode              Designates a language as used in a particular region (e.g. British vs American
  |      0|  272|                                English) together with other region-dependent characteristics (e.g. date format)
  |      0|  273|        FourCharCode            A 32-bit value made by packing four 1 byte characters together
  |      0|  274|        OSType                  A FourCharCode used in the OS and file system (e.g. creator)
  |      0|  275|        ResType                 A FourCharCode used to tag resources (e.g. 'DLOG')
  |      0|  276|        
  |      0|  277|*********************************************************************************/
  |      0|  278|typedef SInt16                          OSErr;
  |      0|  279|typedef SInt32                          OSStatus;
  |      0|  280|typedef void *                          LogicalAddress;
  |      0|  281|typedef const void *                    ConstLogicalAddress;
  |      0|  282|typedef void *                          PhysicalAddress;
  |      0|  283|typedef UInt8 *                         BytePtr;
  |      0|  284|typedef unsigned long                   ByteCount;
  |      0|  285|typedef unsigned long                   ByteOffset;
  |      0|  286|typedef SInt32                          Duration;
  |      0|  287|typedef UnsignedWide                    AbsoluteTime;
  |      0|  288|typedef UInt32                          OptionBits;
  |      0|  289|typedef unsigned long                   ItemCount;
  |      0|  290|typedef UInt32                          PBVersion;
  |      0|  291|typedef SInt16                          ScriptCode;
  |      0|  292|typedef SInt16                          LangCode;
  ------------------
       |  293|typedef SInt16                          RegionCode;
       |  294|typedef UInt32                          FourCharCode;
       |  295|typedef FourCharCode                    OSType;
       |  296|typedef FourCharCode                    ResType;
       |  297|typedef OSType *                        OSTypePtr;
       |  298|typedef ResType *                       ResTypePtr;
       |  299|/********************************************************************************
       |  300|
       |  301|    Boolean types and values
       |  302|    
       |  303|        Boolean         Mac OS historic type, sizeof(Boolean)==1
       |  304|        bool            Defined in stdbool.h, ISO C/C++ standard type
       |  305|        false           Now defined in stdbool.h
  ------------------
  | -[OCMockObject handleInvocation:]:
  |    119|  270|        LangCode                A particular language (e.g. English), as represented using a particular ScriptCode
  |    119|  271|        RegionCode              Designates a language as used in a particular region (e.g. British vs American
  |    119|  272|                                English) together with other region-dependent characteristics (e.g. date format)
  |    119|  273|        FourCharCode            A 32-bit value made by packing four 1 byte characters together
  |    119|  274|        OSType                  A FourCharCode used in the OS and file system (e.g. creator)
  |    413|  275|        ResType                 A FourCharCode used to tag resources (e.g. 'DLOG')
  |    413|  276|        
  |    413|  277|*********************************************************************************/
  |     33|  278|typedef SInt16                          OSErr;
  |    413|  279|typedef SInt32                          OSStatus;
  |    119|  280|typedef void *                          LogicalAddress;
  |    119|  281|typedef const void *                    ConstLogicalAddress;
  |    119|  282|typedef void *                          PhysicalAddress;
  |     86|  283|typedef UInt8 *                         BytePtr;
  |    119|  284|typedef unsigned long                   ByteCount;
  |     33|  285|typedef unsigned long                   ByteOffset;
  |      0|  286|typedef SInt32                          Duration;
  |      0|  287|typedef UnsignedWide                    AbsoluteTime;
  |      0|  288|typedef UInt32                          OptionBits;
  |      0|  289|typedef unsigned long                   ItemCount;
  |      0|  290|typedef UInt32                          PBVersion;
  |      0|  291|typedef SInt16                          ScriptCode;
  |      0|  292|typedef SInt16                          LangCode;
  |      0|  293|typedef SInt16                          RegionCode;
  |      0|  294|typedef UInt32                          FourCharCode;
  |      0|  295|typedef FourCharCode                    OSType;
  |      0|  296|typedef FourCharCode                    ResType;
  |      0|  297|typedef OSType *                        OSTypePtr;
  |      0|  298|typedef ResType *                       ResTypePtr;
  |      0|  299|/********************************************************************************
  |      0|  300|
  |     33|  301|    Boolean types and values
  |     33|  302|    
  |     33|  303|        Boolean         Mac OS historic type, sizeof(Boolean)==1
  |     33|  304|        bool            Defined in stdbool.h, ISO C/C++ standard type
  |    119|  305|        false           Now defined in stdbool.h
  ------------------
       |  306|        true            Now defined in stdbool.h
       |  307|        
       |  308|*********************************************************************************/
       |  309|typedef unsigned char                   Boolean;
       |  310|/********************************************************************************
       |  311|
       |  312|    Function Pointer Types
       |  313|    
       |  314|        ProcPtr                 Generic pointer to a function
  ------------------
  | -[OCMockObject _nextExptectedInvocation]:
  |      0|  309|typedef unsigned char                   Boolean;
  |      0|  310|/********************************************************************************
  |      0|  311|
  |      0|  312|    Function Pointer Types
  |      0|  313|    
  |      0|  314|        ProcPtr                 Generic pointer to a function
  ------------------
       |  315|        Register68kProcPtr      Pointer to a 68K function that expects parameters in registers
       |  316|        UniversalProcPtr        Pointer to classic 68K code or a RoutineDescriptor
       |  317|        
       |  318|        ProcHandle              Pointer to a ProcPtr
       |  319|        UniversalProcHandle     Pointer to a UniversalProcPtr
       |  320|        
       |  321|*********************************************************************************/
       |  322|typedef CALLBACK_API_C( long , ProcPtr )();
       |  323|typedef CALLBACK_API( void , Register68kProcPtr )();
       |  324|#if TARGET_RT_MAC_CFM
       |  325|/*  The RoutineDescriptor structure is defined in MixedMode.h */
       |  326|typedef struct RoutineDescriptor *UniversalProcPtr;
       |  327|#else
       |  328|typedef ProcPtr                         UniversalProcPtr;
       |  329|#endif  /* TARGET_RT_MAC_CFM */
       |  330|
       |  331|typedef ProcPtr *                       ProcHandle;
       |  332|typedef UniversalProcPtr *              UniversalProcHandle;
       |  333|/********************************************************************************
       |  334|
       |  335|    RefCon Types
       |  336|    
       |  337|        For access to private data in callbacks, etc.; refcons are generally
       |  338|        used as a pointer to something, but in the 32-bit world refcons in
  ------------------
  | -[OCMockObject doesNotRecognizeSelector:]:
  |      0|  326|typedef struct RoutineDescriptor *UniversalProcPtr;
  |      0|  327|#else
  |      0|  328|typedef ProcPtr                         UniversalProcPtr;
  |      0|  329|#endif  /* TARGET_RT_MAC_CFM */
  |      0|  330|
  |      0|  331|typedef ProcPtr *                       ProcHandle;
  |      0|  332|typedef UniversalProcPtr *              UniversalProcHandle;
  |      0|  333|/********************************************************************************
  |      0|  334|
  |      0|  335|    RefCon Types
  |      0|  336|    
  |      0|  337|        For access to private data in callbacks, etc.; refcons are generally
  |      0|  338|        used as a pointer to something, but in the 32-bit world refcons in
  ------------------
       |  339|        different APIs have had various types: pointer, unsigned scalar, and
       |  340|        signed scalar. The RefCon types defined here support the current 32-bit
       |  341|        usage but provide normalization to pointer types for 64-bit.
       |  342|        
       |  343|        PRefCon is preferred for new APIs; URefCon and SRefCon are primarily
       |  344|        for compatibility with existing APIs.
       |  345|        
       |  346|*********************************************************************************/
       |  347|typedef void *                          PRefCon;
       |  348|#if __LP64__
       |  349|typedef void *                          URefCon;
       |  350|typedef void *                          SRefCon;
       |  351|#else
       |  352|typedef UInt32                          URefCon;
       |  353|typedef SInt32                          SRefCon;
       |  354|#endif  /* __LP64__ */
       |  355|
       |  356|/********************************************************************************
       |  357|
       |  358|    Common Constants
       |  359|    
       |  360|        noErr                   OSErr: function performed properly - no error
       |  361|        kNilOptions             OptionBits: all flags false
       |  362|        kInvalidID              KernelID: NULL is for pointers as kInvalidID is for ID's
       |  363|        kVariableLengthArray    array bounds: variable length array
       |  364|
       |  365|    Note: kVariableLengthArray was used in array bounds to specify a variable length array,
       |  366|          usually the last field in a struct.  Now that the C language supports 
       |  367|		  the concept of flexible array members, you can instead use: 
       |  368|		
       |  369|		struct BarList
       |  370|		{
       |  371|			short	listLength;
       |  372|			Bar		elements[];
       |  373|		};
       |  374|
       |  375|		However, this changes the semantics somewhat, as sizeof( BarList ) contains
       |  376|		no space for any of the elements, so to allocate a list with space for
       |  377|		the count elements
       |  378|
       |  379|		struct BarList* l = (struct BarList*) malloc( sizeof(BarList) + count * sizeof(Bar) );
       |  380|        
       |  381|*********************************************************************************/
       |  382|enum {
       |  383|  noErr                         = 0
       |  384|};
       |  385|
       |  386|enum {
       |  387|  kNilOptions                   = 0
       |  388|};
       |  389|
       |  390|#define kInvalidID   0
       |  391|enum {
       |  392|  kVariableLengthArray  
       |  393|#ifdef __has_extension
       |  394|   #if __has_extension(enumerator_attributes)
       |  395|		__attribute__((deprecated))  
       |  396|	#endif
       |  397|#endif
       |  398|  = 1
       |  399|};
       |  400|
       |  401|enum {
       |  402|  kUnknownType                  = 0x3F3F3F3F /* "????" QuickTime 3.0: default unknown ResType or OSType */
       |  403|};
       |  404|
       |  405|
       |  406|
       |  407|/********************************************************************************
       |  408|
       |  409|    String Types and Unicode Types
       |  410|    
       |  411|        UnicodeScalarValue,     A complete Unicode character in UTF-32 format, with
       |  412|        UTF32Char               values from 0 through 0x10FFFF (excluding the surrogate
       |  413|                                range 0xD800-0xDFFF and certain disallowed values).
       |  414|
       |  415|        UniChar,                A 16-bit Unicode code value in the default UTF-16 format.
       |  416|        UTF16Char               UnicodeScalarValues 0-0xFFFF are expressed in UTF-16
       |  417|                                format using a single UTF16Char with the same value.
       |  418|                                UnicodeScalarValues 0x10000-0x10FFFF are expressed in
       |  419|                                UTF-16 format using a pair of UTF16Chars - one in the
       |  420|                                high surrogate range (0xD800-0xDBFF) followed by one in
       |  421|                                the low surrogate range (0xDC00-0xDFFF). All of the
       |  422|                                characters defined in Unicode versions through 3.0 are
       |  423|                                in the range 0-0xFFFF and can be expressed using a single
       |  424|                                UTF16Char, thus the term "Unicode character" generally
       |  425|                                refers to a UniChar = UTF16Char.
       |  426|
       |  427|        UTF8Char                An 8-bit code value in UTF-8 format. UnicodeScalarValues
       |  428|                                0-0x7F are expressed in UTF-8 format using one UTF8Char
       |  429|                                with the same value. UnicodeScalarValues above 0x7F are
       |  430|                                expressed in UTF-8 format using 2-4 UTF8Chars, all with
       |  431|                                values in the range 0x80-0xF4 (UnicodeScalarValues
       |  432|                                0x100-0xFFFF use two or three UTF8Chars,
       |  433|                                UnicodeScalarValues 0x10000-0x10FFFF use four UTF8Chars).
       |  434|
       |  435|        UniCharCount            A count of UTF-16 code values in an array or buffer.
       |  436|
       |  437|        StrNNN                  Pascal string holding up to NNN bytes
       |  438|        StringPtr               Pointer to a pascal string
       |  439|        StringHandle            Pointer to a StringPtr
       |  440|        ConstStringPtr          Pointer to a read-only pascal string
       |  441|        ConstStrNNNParam        For function parameters only - means string is const
       |  442|        
       |  443|        CStringPtr              Pointer to a C string           (in C:  char*)
       |  444|        ConstCStringPtr         Pointer to a read-only C string (in C:  const char*)
       |  445|        
       |  446|    Note: The length of a pascal string is stored as the first byte.
       |  447|          A pascal string does not have a termination byte.
       |  448|          A pascal string can hold at most 255 bytes of data.
       |  449|          The first character in a pascal string is offset one byte from the start of the string. 
       |  450|          
       |  451|          A C string is terminated with a byte of value zero.  
       |  452|          A C string has no length limitation.
       |  453|          The first character in a C string is the zeroth byte of the string. 
       |  454|          
       |  455|        
       |  456|*********************************************************************************/
       |  457|typedef UInt32                          UnicodeScalarValue;
       |  458|typedef UInt32                          UTF32Char;
       |  459|typedef UInt16                          UniChar;
       |  460|typedef UInt16                          UTF16Char;
       |  461|typedef UInt8                           UTF8Char;
       |  462|typedef UniChar *                       UniCharPtr;
       |  463|typedef unsigned long                   UniCharCount;
       |  464|typedef UniCharCount *                  UniCharCountPtr;
       |  465|typedef unsigned char                   Str255[256];
       |  466|typedef unsigned char                   Str63[64];
       |  467|typedef unsigned char                   Str32[33];
       |  468|typedef unsigned char                   Str31[32];
       |  469|typedef unsigned char                   Str27[28];
       |  470|typedef unsigned char                   Str15[16];
       |  471|/*
       |  472|    The type Str32 is used in many AppleTalk based data structures.
       |  473|    It holds up to 32 one byte chars.  The problem is that with the
       |  474|    length byte it is 33 bytes long.  This can cause weird alignment
       |  475|    problems in structures.  To fix this the type "Str32Field" has
       |  476|    been created.  It should only be used to hold 32 chars, but
       |  477|    it is 34 bytes long so that there are no alignment problems.
       |  478|*/
       |  479|typedef unsigned char                   Str32Field[34];
       |  480|/*
       |  481|    QuickTime 3.0:
       |  482|    The type StrFileName is used to make MacOS structs work 
       |  483|    cross-platform.  For example FSSpec or SFReply previously
       |  484|    contained a Str63 field.  They now contain a StrFileName
       |  485|    field which is the same when targeting the MacOS but is
       |  486|    a 256 char buffer for Win32 and unix, allowing them to
       |  487|    contain long file names.
       |  488|*/
       |  489|typedef Str63                           StrFileName;
       |  490|typedef unsigned char *                 StringPtr;
       |  491|typedef StringPtr *                     StringHandle;
       |  492|typedef const unsigned char *           ConstStringPtr;
       |  493|typedef const unsigned char *           ConstStr255Param;
       |  494|typedef const unsigned char *           ConstStr63Param;
       |  495|typedef const unsigned char *           ConstStr32Param;
       |  496|typedef const unsigned char *           ConstStr31Param;
       |  497|typedef const unsigned char *           ConstStr27Param;
       |  498|typedef const unsigned char *           ConstStr15Param;
       |  499|typedef ConstStr63Param                 ConstStrFileNameParam;
       |  500|#ifdef __cplusplus
       |  501|inline unsigned char StrLength(ConstStr255Param string) { return (*string); }
       |  502|#else
       |  503|#define StrLength(string) (*(unsigned char *)(string))
       |  504|#endif  /* defined(__cplusplus) */
       |  505|
       |  506|#if OLDROUTINENAMES
       |  507|#define Length(string) StrLength(string)
       |  508|#endif  /* OLDROUTINENAMES */
       |  509|
       |  510|/********************************************************************************
       |  511|
       |  512|    Process Manager type ProcessSerialNumber (previously in Processes.h)
       |  513|
       |  514|*********************************************************************************/
       |  515|/* type for unique process identifier */
       |  516|struct ProcessSerialNumber {
       |  517|  UInt32              highLongOfPSN;
       |  518|  UInt32              lowLongOfPSN;
       |  519|};
       |  520|typedef struct ProcessSerialNumber      ProcessSerialNumber;
       |  521|typedef ProcessSerialNumber *           ProcessSerialNumberPtr;
       |  522|/********************************************************************************
       |  523|
       |  524|    Quickdraw Types
       |  525|    
       |  526|        Point               2D Quickdraw coordinate, range: -32K to +32K
       |  527|        Rect                Rectangular Quickdraw area
       |  528|        Style               Quickdraw font rendering styles
       |  529|        StyleParameter      Style when used as a parameter (historical 68K convention)
       |  530|        StyleField          Style when used as a field (historical 68K convention)
       |  531|        CharParameter       Char when used as a parameter (historical 68K convention)
       |  532|        
       |  533|    Note:   The original Macintosh toolbox in 68K Pascal defined Style as a SET.  
       |  534|            Both Style and CHAR occupy 8-bits in packed records or 16-bits when 
       |  535|            used as fields in non-packed records or as parameters. 
       |  536|        
       |  537|*********************************************************************************/
       |  538|struct Point {
       |  539|  short               v;
       |  540|  short               h;
       |  541|};
       |  542|typedef struct Point                    Point;
       |  543|typedef Point *                         PointPtr;
       |  544|struct Rect {
       |  545|  short               top;
       |  546|  short               left;
       |  547|  short               bottom;
       |  548|  short               right;
       |  549|};
       |  550|typedef struct Rect                     Rect;
       |  551|typedef Rect *                          RectPtr;
       |  552|struct FixedPoint {
       |  553|  Fixed               x;
       |  554|  Fixed               y;
       |  555|};
       |  556|typedef struct FixedPoint               FixedPoint;
       |  557|struct FixedRect {
       |  558|  Fixed               left;
       |  559|  Fixed               top;
       |  560|  Fixed               right;
       |  561|  Fixed               bottom;
       |  562|};
       |  563|typedef struct FixedRect                FixedRect;
       |  564|
       |  565|typedef short                           CharParameter;
       |  566|enum {
       |  567|  normal                        = 0,
       |  568|  bold                          = 1,
       |  569|  italic                        = 2,
       |  570|  underline                     = 4,
       |  571|  outline                       = 8,
       |  572|  shadow                        = 0x10,
       |  573|  condense                      = 0x20,
       |  574|  extend                        = 0x40
       |  575|};
       |  576|
       |  577|typedef unsigned char                   Style;
       |  578|typedef short                           StyleParameter;
       |  579|typedef Style                           StyleField;
       |  580|
       |  581|
       |  582|/********************************************************************************
       |  583|
       |  584|    QuickTime TimeBase types (previously in Movies.h)
       |  585|    
       |  586|        TimeValue           Count of units
       |  587|        TimeScale           Units per second
       |  588|        CompTimeValue       64-bit count of units (always a struct) 
       |  589|        TimeValue64         64-bit count of units (long long or struct) 
       |  590|        TimeBase            An opaque reference to a time base
       |  591|        TimeRecord          Package of TimeBase, duration, and scale
       |  592|        
       |  593|*********************************************************************************/
       |  594|typedef SInt32                          TimeValue;
       |  595|typedef SInt32                          TimeScale;
       |  596|typedef wide                            CompTimeValue;
       |  597|typedef SInt64                          TimeValue64;
       |  598|typedef struct TimeBaseRecord*          TimeBase;
       |  599|struct TimeRecord {
       |  600|  CompTimeValue       value;                  /* units (duration or absolute) */
       |  601|  TimeScale           scale;                  /* units per second */
       |  602|  TimeBase            base;                   /* refernce to the time base */
       |  603|};
       |  604|typedef struct TimeRecord               TimeRecord;
       |  605|
       |  606|/********************************************************************************
       |  607|
       |  608|    THINK C base objects
       |  609|
       |  610|        HandleObject        Root class for handle based THINK C++ objects
       |  611|        PascalObject        Root class for pascal style objects in THINK C++ 
       |  612|
       |  613|*********************************************************************************/
       |  614|#if defined(__SC__) && !defined(__STDC__) && defined(__cplusplus)
       |  615|        class __machdl HandleObject {};
       |  616|        #if TARGET_CPU_68K
       |  617|            class __pasobj PascalObject {};
       |  618|        #endif
       |  619|#endif
       |  620|
       |  621|
       |  622|/********************************************************************************
       |  623|
       |  624|    MacOS versioning structures
       |  625|    
       |  626|        VersRec                 Contents of a 'vers' resource
       |  627|        VersRecPtr              Pointer to a VersRecPtr
       |  628|        VersRecHndl             Resource Handle containing a VersRec
       |  629|        NumVersion              Packed BCD version representation (e.g. "4.2.1a3" is 0x04214003)
       |  630|        UniversalProcPtr        Pointer to classic 68K code or a RoutineDescriptor
       |  631|        
       |  632|        ProcHandle              Pointer to a ProcPtr
       |  633|        UniversalProcHandle     Pointer to a UniversalProcPtr
       |  634|        
       |  635|*********************************************************************************/
       |  636|#if TARGET_RT_BIG_ENDIAN
       |  637|struct NumVersion {
       |  638|                                              /* Numeric version part of 'vers' resource */
       |  639|  UInt8               majorRev;               /*1st part of version number in BCD*/
       |  640|  UInt8               minorAndBugRev;         /*2nd & 3rd part of version number share a byte*/
       |  641|  UInt8               stage;                  /*stage code: dev, alpha, beta, final*/
       |  642|  UInt8               nonRelRev;              /*revision level of non-released version*/
       |  643|};
       |  644|typedef struct NumVersion               NumVersion;
       |  645|#else
       |  646|struct NumVersion {
       |  647|                                              /* Numeric version part of 'vers' resource accessable in little endian format */
       |  648|  UInt8               nonRelRev;              /*revision level of non-released version*/
       |  649|  UInt8               stage;                  /*stage code: dev, alpha, beta, final*/
       |  650|  UInt8               minorAndBugRev;         /*2nd & 3rd part of version number share a byte*/
       |  651|  UInt8               majorRev;               /*1st part of version number in BCD*/
       |  652|};
       |  653|typedef struct NumVersion               NumVersion;
       |  654|#endif  /* TARGET_RT_BIG_ENDIAN */
       |  655|
       |  656|enum {
       |  657|                                        /* Version Release Stage Codes */
       |  658|  developStage                  = 0x20,
       |  659|  alphaStage                    = 0x40,
       |  660|  betaStage                     = 0x60,
       |  661|  finalStage                    = 0x80
       |  662|};
       |  663|
       |  664|union NumVersionVariant {
       |  665|                                              /* NumVersionVariant is a wrapper so NumVersion can be accessed as a 32-bit value */
       |  666|  NumVersion          parts;
       |  667|  UInt32              whole;
       |  668|};
       |  669|typedef union NumVersionVariant         NumVersionVariant;
       |  670|typedef NumVersionVariant *             NumVersionVariantPtr;
       |  671|typedef NumVersionVariantPtr *          NumVersionVariantHandle;
       |  672|struct VersRec {
       |  673|                                              /* 'vers' resource format */
       |  674|  NumVersion          numericVersion;         /*encoded version number*/
       |  675|  short               countryCode;            /*country code from intl utilities*/
       |  676|  Str255              shortVersion;           /*version number string - worst case*/
       |  677|  Str255              reserved;               /*longMessage string packed after shortVersion*/
       |  678|};
       |  679|typedef struct VersRec                  VersRec;
       |  680|typedef VersRec *                       VersRecPtr;
       |  681|typedef VersRecPtr *                    VersRecHndl;
       |  682|/*********************************************************************************
       |  683|
       |  684|    Old names for types
       |  685|        
       |  686|*********************************************************************************/
       |  687|typedef UInt8                           Byte;
       |  688|typedef SInt8                           SignedByte;
       |  689|typedef wide *                          WidePtr;
       |  690|typedef UnsignedWide *                  UnsignedWidePtr;
       |  691|typedef Float80                         extended80;
       |  692|typedef Float96                         extended96;
       |  693|typedef SInt8                           VHSelect;
       |  694|/*********************************************************************************
       |  695|
       |  696|    Debugger functions
       |  697|    
       |  698|*********************************************************************************/
       |  699|/*
       |  700| *  Debugger()
       |  701| *  
       |  702| *  Availability:
       |  703| *    Mac OS X:         in version 10.0 and later in CoreServices.framework
       |  704| *    CarbonLib:        in CarbonLib 1.0 and later
       |  705| *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
       |  706| */
       |  707|extern void 
       |  708|Debugger(void)                                                __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA);
       |  709|
       |  710|
       |  711|/*
       |  712| *  DebugStr()
       |  713| *  
       |  714| *  Availability:
       |  715| *    Mac OS X:         in version 10.0 and later in CoreServices.framework
       |  716| *    CarbonLib:        in CarbonLib 1.0 and later
       |  717| *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
       |  718| */
       |  719|extern void 
       |  720|DebugStr(ConstStr255Param debuggerMsg)                        __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA);
       |  721|
       |  722|
       |  723|/*
       |  724| *  debugstr()
       |  725| *  
       |  726| *  Availability:
       |  727| *    Mac OS X:         not available
       |  728| *    CarbonLib:        not available
       |  729| *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
       |  730| */
       |  731|
       |  732|
       |  733|#if TARGET_CPU_PPC
       |  734|/* Only for Mac OS native drivers */
       |  735|/*
       |  736| *  SysDebug()
       |  737| *  
       |  738| *  Availability:
       |  739| *    Mac OS X:         not available
       |  740| *    CarbonLib:        not available
       |  741| *    Non-Carbon CFM:   in DriverServicesLib 1.0 and later
       |  742| */
       |  743|
       |  744|
       |  745|/*
       |  746| *  SysDebugStr()
       |  747| *  
       |  748| *  Availability:
       |  749| *    Mac OS X:         not available
       |  750| *    CarbonLib:        not available
       |  751| *    Non-Carbon CFM:   in DriverServicesLib 1.0 and later
       |  752| */
       |  753|
       |  754|
       |  755|#endif  /* TARGET_CPU_PPC */
       |  756|
       |  757|/* SADE break points */
       |  758|/*
       |  759| *  SysBreak()
       |  760| *  
       |  761| *  Availability:
       |  762| *    Mac OS X:         in version 10.0 and later in CoreServices.framework
       |  763| *    CarbonLib:        in CarbonLib 1.0 and later
       |  764| *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
       |  765| */
       |  766|extern void 
       |  767|SysBreak(void)                                                __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA);
       |  768|
       |  769|
       |  770|/*
       |  771| *  SysBreakStr()
       |  772| *  
       |  773| *  Availability:
       |  774| *    Mac OS X:         in version 10.0 and later in CoreServices.framework
       |  775| *    CarbonLib:        in CarbonLib 1.0 and later
       |  776| *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
       |  777| */
       |  778|extern void 
       |  779|SysBreakStr(ConstStr255Param debuggerMsg)                     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA);
       |  780|
       |  781|
       |  782|/*
       |  783| *  SysBreakFunc()
       |  784| *  
       |  785| *  Availability:
       |  786| *    Mac OS X:         in version 10.0 and later in CoreServices.framework
       |  787| *    CarbonLib:        in CarbonLib 1.0 and later
       |  788| *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
       |  789| */
       |  790|extern void 
       |  791|SysBreakFunc(ConstStr255Param debuggerMsg)                    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA);
       |  792|
       |  793|
       |  794|/* old names for Debugger and DebugStr */
       |  795|#if OLDROUTINENAMES && TARGET_CPU_68K
       |  796|    #define Debugger68k()   Debugger()
       |  797|    #define DebugStr68k(s)  DebugStr(s)
       |  798|#endif
       |  799|
       |  800|
       |  801|#pragma pack(pop)
       |  802|
       |  803|#ifdef __cplusplus
       |  804|}
       |  805|#endif
       |  806|
       |  807|#endif /* __MACTYPES__ */
       |  808|

/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.0.sdk/usr/include/objc/objc.h:
       |    1|/*
       |    2| * Copyright (c) 1999-2007 Apple Inc.  All Rights Reserved.
       |    3| * 
       |    4| * @APPLE_LICENSE_HEADER_START@
       |    5| * 
       |    6| * This file contains Original Code and/or Modifications of Original Code
       |    7| * as defined in and that are subject to the Apple Public Source License
       |    8| * Version 2.0 (the 'License'). You may not use this file except in
       |    9| * compliance with the License. Please obtain a copy of the License at
       |   10| * http://www.opensource.apple.com/apsl/ and read it before using this
       |   11| * file.
       |   12| * 
       |   13| * The Original Code and all software distributed under the License are
       |   14| * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
       |   15| * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
       |   16| * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
       |   17| * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
       |   18| * Please see the License for the specific language governing rights and
       |   19| * limitations under the License.
       |   20| * 
       |   21| * @APPLE_LICENSE_HEADER_END@
       |   22| */
       |   23|/*
       |   24| *	objc.h
       |   25| *	Copyright 1988-1996, NeXT Software, Inc.
       |   26| */
       |   27|
       |   28|#ifndef _OBJC_OBJC_H_
  ------------------
  | -[OCMInvocationExpectation setMatchAndReject:]:
  |      0|   24| *	objc.h
  |      0|   25| *	Copyright 1988-1996, NeXT Software, Inc.
  |      0|   26| */
  |      0|   27|
  |      0|   28|#ifndef _OBJC_OBJC_H_
  ------------------
       |   29|#define _OBJC_OBJC_H_
       |   30|
  ------------------
  | -[OCMConstraint evaluate:]:
  |      0|   28|#ifndef _OBJC_OBJC_H_
  |      0|   29|#define _OBJC_OBJC_H_
  |      0|   30|
  ------------------
       |   31|#include <sys/types.h>      // for __DARWIN_NULL
       |   32|#include <Availability.h>
       |   33|#include <objc/objc-api.h>
  ------------------
  | -[NSInvocation(OCMAdditions) hasCharPointerArgument]:
  |     59|   24| *	objc.h
  |     59|   25| *	Copyright 1988-1996, NeXT Software, Inc.
  |    210|   26| */
  |    151|   27|
  |    151|   28|#ifndef _OBJC_OBJC_H_
  |    151|   29|#define _OBJC_OBJC_H_
  |      0|   30|
  |    151|   31|#include <sys/types.h>      // for __DARWIN_NULL
  |     59|   32|#include <Availability.h>
  |     59|   33|#include <objc/objc-api.h>
  ------------------
       |   34|#include <stdbool.h>
       |   35|
       |   36|#if !OBJC_TYPES_DEFINED
       |   37|/// An opaque type that represents an Objective-C class.
       |   38|typedef struct objc_class *Class;
       |   39|
       |   40|/// Represents an instance of a class.
       |   41|struct objc_object {
       |   42|    Class isa  OBJC_ISA_AVAILABILITY;
       |   43|};
       |   44|
  ------------------
  | -[OCMExpectationRecorder never]:
  |      0|   41|struct objc_object {
  |      0|   42|    Class isa  OBJC_ISA_AVAILABILITY;
  |      0|   43|};
  |      0|   44|
  ------------------
       |   45|/// A pointer to an instance of a class.
  ------------------
  | -[NSMethodSignature(OCMAdditions) usesSpecialStructureReturn]:
  |    124|   25| *	Copyright 1988-1996, NeXT Software, Inc.
  |    124|   26| */
  |    124|   27|
  |    124|   28|#ifndef _OBJC_OBJC_H_
  |    122|   29|#define _OBJC_OBJC_H_
  |    124|   30|
  |    124|   31|#include <sys/types.h>      // for __DARWIN_NULL
  |    124|   32|#include <Availability.h>
  |    124|   33|#include <objc/objc-api.h>
  |    124|   34|#include <stdbool.h>
  |    124|   35|
  |    124|   36|#if !OBJC_TYPES_DEFINED
  |    124|   37|/// An opaque type that represents an Objective-C class.
  |    124|   38|typedef struct objc_class *Class;
  |    124|   39|
  |    124|   40|/// Represents an instance of a class.
  |    124|   41|struct objc_object {
  |    124|   42|    Class isa  OBJC_ISA_AVAILABILITY;
  |      2|   43|};
  |      2|   44|
  |    124|   45|/// A pointer to an instance of a class.
  ------------------
       |   46|typedef struct objc_object *id;
       |   47|#endif
       |   48|
       |   49|/// An opaque type that represents a method selector.
       |   50|typedef struct objc_selector *SEL;
       |   51|
  ------------------
  | -[OCProtocolMockObject methodSignatureForSelector:]:
  |      0|   42|    Class isa  OBJC_ISA_AVAILABILITY;
  |      0|   43|};
  |      0|   44|
  |      0|   45|/// A pointer to an instance of a class.
  |      0|   46|typedef struct objc_object *id;
  |      0|   47|#endif
  |      0|   48|
  |      0|   49|/// An opaque type that represents a method selector.
  |      0|   50|typedef struct objc_selector *SEL;
  |      0|   51|
  ------------------
       |   52|/// A pointer to the function of a method implementation. 
       |   53|#if !OBJC_OLD_DISPATCH_PROTOTYPES
       |   54|typedef void (*IMP)(void /* id, SEL, ... */ ); 
  ------------------
  | -[OCMInvocationExpectation handleInvocation:]:
  |      0|   41|struct objc_object {
  |      0|   42|    Class isa  OBJC_ISA_AVAILABILITY;
  |      0|   43|};
  |      0|   44|
  |      0|   45|/// A pointer to an instance of a class.
  |      0|   46|typedef struct objc_object *id;
  |      0|   47|#endif
  |      0|   48|
  |      0|   49|/// An opaque type that represents a method selector.
  |      0|   50|typedef struct objc_selector *SEL;
  |      0|   51|
  |      0|   52|/// A pointer to the function of a method implementation. 
  |      0|   53|#if !OBJC_OLD_DISPATCH_PROTOTYPES
  |      0|   54|typedef void (*IMP)(void /* id, SEL, ... */ ); 
  ------------------
       |   55|#else
       |   56|typedef id (*IMP)(id, SEL, ...); 
       |   57|#endif
       |   58|
  ------------------
  | -[OCMBoxedReturnValueProvider isMethodReturnType:compatibleWithValueType:]:
  |      3|   48|
  |      3|   49|/// An opaque type that represents a method selector.
  |      3|   50|typedef struct objc_selector *SEL;
  |      3|   51|
  |      3|   52|/// A pointer to the function of a method implementation. 
  |      3|   53|#if !OBJC_OLD_DISPATCH_PROTOTYPES
  |      0|   54|typedef void (*IMP)(void /* id, SEL, ... */ ); 
  |      0|   55|#else
  |      0|   56|typedef id (*IMP)(id, SEL, ...); 
  |      0|   57|#endif
  |      0|   58|
  ------------------
  | OCMIsObjectType:
  |    147|   39|
  |    147|   40|/// Represents an instance of a class.
  |    147|   41|struct objc_object {
  |    147|   42|    Class isa  OBJC_ISA_AVAILABILITY;
  |    134|   43|};
  |    147|   44|
  |    147|   45|/// A pointer to an instance of a class.
  |     13|   46|typedef struct objc_object *id;
  |     13|   47|#endif
  |     13|   48|
  |     13|   49|/// An opaque type that represents a method selector.
  |      0|   50|typedef struct objc_selector *SEL;
  |     13|   51|
  |     13|   52|/// A pointer to the function of a method implementation. 
  |     13|   53|#if !OBJC_OLD_DISPATCH_PROTOTYPES
  |     13|   54|typedef void (*IMP)(void /* id, SEL, ... */ ); 
  |      2|   55|#else
  |     13|   56|typedef id (*IMP)(id, SEL, ...); 
  |     11|   57|#endif
  |     13|   58|
  ------------------
       |   59|#define OBJC_BOOL_DEFINED
       |   60|
       |   61|/// Type to represent a boolean value.
       |   62|#if (TARGET_OS_IPHONE && __LP64__)  ||  TARGET_OS_WATCH
       |   63|#define OBJC_BOOL_IS_BOOL 1
       |   64|typedef bool BOOL;
       |   65|#else
       |   66|#define OBJC_BOOL_IS_CHAR 1
       |   67|typedef signed char BOOL; 
  ------------------
  | -[OCMRecorder classMethod]:
  |      5|   63|#define OBJC_BOOL_IS_BOOL 1
  |      5|   64|typedef bool BOOL;
  |      5|   65|#else
  |      5|   66|#define OBJC_BOOL_IS_CHAR 1
  |      5|   67|typedef signed char BOOL; 
  ------------------
       |   68|// BOOL is explicitly signed so @encode(BOOL) == "c" rather than "C" 
       |   69|// even if -funsigned-char is used.
       |   70|#endif
       |   71|
  ------------------
  | -[OCMAnyConstraint evaluate:]:
  |      1|   69|// even if -funsigned-char is used.
  |      1|   70|#endif
  |      1|   71|
  ------------------
       |   72|#if __has_feature(objc_bool)
    837|   73|#define YES __objc_yes
  ------------------
  | -[OCMRecorder ignoringNonObjectArgs]:
  |      0|   70|#endif
  |      0|   71|
  |      0|   72|#if __has_feature(objc_bool)
  |      0|   73|#define YES __objc_yes
  ------------------
  2.72k|   74|#define NO  __objc_no
       |   75|#else
       |   76|#define YES ((BOOL)1)
       |   77|#define NO  ((BOOL)0)
  ------------------
  | +[OCMockObject _makeNice:]:
  |     10|   74|#define NO  __objc_no
  |     10|   75|#else
  |     10|   76|#define YES ((BOOL)1)
  |     10|   77|#define NO  ((BOOL)0)
  ------------------
       |   78|#endif
       |   79|
       |   80|#ifndef Nil
       |   81|# if __has_feature(cxx_nullptr)
       |   82|#   define Nil nullptr
       |   83|# else
       |   84|#   define Nil __DARWIN_NULL
  ------------------
  | -[OCMObserverRecorder argument:matchesArgument:]:
  |      0|   63|#define OBJC_BOOL_IS_BOOL 1
  |      0|   64|typedef bool BOOL;
  |      0|   65|#else
  |      0|   66|#define OBJC_BOOL_IS_CHAR 1
  |      0|   67|typedef signed char BOOL; 
  |      0|   68|// BOOL is explicitly signed so @encode(BOOL) == "c" rather than "C" 
  |      0|   69|// even if -funsigned-char is used.
  |      0|   70|#endif
  |      0|   71|
  |      0|   72|#if __has_feature(objc_bool)
  |      0|   73|#define YES __objc_yes
  |      0|   74|#define NO  __objc_no
  |      0|   75|#else
  |      0|   76|#define YES ((BOOL)1)
  |      0|   77|#define NO  ((BOOL)0)
  |      0|   78|#endif
  |      0|   79|
  |      0|   80|#ifndef Nil
  |      0|   81|# if __has_feature(cxx_nullptr)
  |      0|   82|#   define Nil nullptr
  |      0|   83|# else
  |      0|   84|#   define Nil __DARWIN_NULL
  ------------------
       |   85|# endif
  ------------------
  | -[OCMInvocationMatcher matchesSelector:]:
  |    603|   77|#define NO  ((BOOL)0)
  |    603|   78|#endif
  |     62|   79|
  |    541|   80|#ifndef Nil
  |      0|   81|# if __has_feature(cxx_nullptr)
  |      0|   82|#   define Nil nullptr
  |    541|   83|# else
  |    541|   84|#   define Nil __DARWIN_NULL
  |    541|   85|# endif
  ------------------
       |   86|#endif
       |   87|
       |   88|#ifndef nil
       |   89|# if __has_feature(cxx_nullptr)
       |   90|#   define nil nullptr
       |   91|# else
       |   92|#   define nil __DARWIN_NULL
       |   93|# endif
       |   94|#endif
       |   95|
       |   96|#if ! (defined(__OBJC_GC__)  ||  __has_feature(objc_arc))
       |   97|#define __strong /* empty */
  ------------------
  | -[OCMockObject init]:
  |     19|   89|# if __has_feature(cxx_nullptr)
  |     19|   90|#   define nil nullptr
  |     19|   91|# else
  |     19|   92|#   define nil __DARWIN_NULL
  |     19|   93|# endif
  |     19|   94|#endif
  |     19|   95|
  |     19|   96|#if ! (defined(__OBJC_GC__)  ||  __has_feature(objc_arc))
  |     19|   97|#define __strong /* empty */
  ------------------
       |   98|#endif
       |   99|
       |  100|#if !__has_feature(objc_arc)
       |  101|#define __unsafe_unretained /* empty */
       |  102|#define __autoreleasing /* empty */
       |  103|#endif
       |  104|
  ------------------
  | -[NSValue(OCMAdditions) getBytes:objCType:]:
  |      0|   68|// BOOL is explicitly signed so @encode(BOOL) == "c" rather than "C" 
  |      0|   69|// even if -funsigned-char is used.
  |      0|   70|#endif
  |      0|   71|
  |      0|   72|#if __has_feature(objc_bool)
  |      0|   73|#define YES __objc_yes
  |      0|   74|#define NO  __objc_no
  |      0|   75|#else
  |      0|   76|#define YES ((BOOL)1)
  |      0|   77|#define NO  ((BOOL)0)
  |      0|   78|#endif
  |      0|   79|
  |      0|   80|#ifndef Nil
  |      0|   81|# if __has_feature(cxx_nullptr)
  |      0|   82|#   define Nil nullptr
  |      0|   83|# else
  |      0|   84|#   define Nil __DARWIN_NULL
  |      0|   85|# endif
  |      0|   86|#endif
  |      0|   87|
  |      0|   88|#ifndef nil
  |      0|   89|# if __has_feature(cxx_nullptr)
  |      0|   90|#   define nil nullptr
  |      0|   91|# else
  |      0|   92|#   define nil __DARWIN_NULL
  |      0|   93|# endif
  |      0|   94|#endif
  |      0|   95|
  |      0|   96|#if ! (defined(__OBJC_GC__)  ||  __has_feature(objc_arc))
  |      0|   97|#define __strong /* empty */
  |      0|   98|#endif
  |      0|   99|
  |      0|  100|#if !__has_feature(objc_arc)
  |      0|  101|#define __unsafe_unretained /* empty */
  |      0|  102|#define __autoreleasing /* empty */
  |      0|  103|#endif
  |      0|  104|
  ------------------
       |  105|
       |  106|/** 
       |  107| * Returns the name of the method specified by a given selector.
       |  108| * 
       |  109| * @param sel A pointer of type \c SEL. Pass the selector whose name you wish to determine.
       |  110| * 
       |  111| * @return A C string indicating the name of the selector.
       |  112| */
       |  113|OBJC_EXPORT const char *sel_getName(SEL sel)
       |  114|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
       |  115|
       |  116|/** 
       |  117| * Registers a method with the Objective-C runtime system, maps the method 
       |  118| * name to a selector, and returns the selector value.
       |  119| * 
       |  120| * @param str A pointer to a C string. Pass the name of the method you wish to register.
       |  121| * 
       |  122| * @return A pointer of type SEL specifying the selector for the named method.
       |  123| * 
       |  124| * @note You must register a method name with the Objective-C runtime system to obtain the
       |  125| *  methods selector before you can add the method to a class definition. If the method name
       |  126| *  has already been registered, this function simply returns the selector.
       |  127| */
       |  128|OBJC_EXPORT SEL sel_registerName(const char *str)
       |  129|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
       |  130|
       |  131|/** 
  ------------------
  | -[OCClassMockObject prepareClassForClassMethodMocking]:
  |     19|   79|
  |     19|   80|#ifndef Nil
  |     19|   81|# if __has_feature(cxx_nullptr)
  |     19|   82|#   define Nil nullptr
  |      0|   83|# else
  |     19|   84|#   define Nil __DARWIN_NULL
  |     19|   85|# endif
  |     19|   86|#endif
  |     19|   87|
  |      7|   88|#ifndef nil
  |     19|   89|# if __has_feature(cxx_nullptr)
  |     19|   90|#   define nil nullptr
  |     19|   91|# else
  |     19|   92|#   define nil __DARWIN_NULL
  |     19|   93|# endif
  |     19|   94|#endif
  |     19|   95|
  |     19|   96|#if ! (defined(__OBJC_GC__)  ||  __has_feature(objc_arc))
  |     19|   97|#define __strong /* empty */
  |     19|   98|#endif
  |     19|   99|
  |     19|  100|#if !__has_feature(objc_arc)
  |     19|  101|#define __unsafe_unretained /* empty */
  |     19|  102|#define __autoreleasing /* empty */
  |     19|  103|#endif
  |     19|  104|
  |     19|  105|
  |     19|  106|/** 
  |     19|  107| * Returns the name of the method specified by a given selector.
  |     19|  108| * 
  |     19|  109| * @param sel A pointer of type \c SEL. Pass the selector whose name you wish to determine.
  |     19|  110| * 
  |     19|  111| * @return A C string indicating the name of the selector.
  |     19|  112| */
  |     19|  113|OBJC_EXPORT const char *sel_getName(SEL sel)
  |     19|  114|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |     19|  115|
  |     19|  116|/** 
  |     19|  117| * Registers a method with the Objective-C runtime system, maps the method 
  |     19|  118| * name to a selector, and returns the selector value.
  |     19|  119| * 
  |     19|  120| * @param str A pointer to a C string. Pass the name of the method you wish to register.
  |     19|  121| * 
  |     19|  122| * @return A pointer of type SEL specifying the selector for the named method.
  |     19|  123| * 
  |     19|  124| * @note You must register a method name with the Objective-C runtime system to obtain the
  |     19|  125| *  methods selector before you can add the method to a class definition. If the method name
  |     19|  126| *  has already been registered, this function simply returns the selector.
  |     19|  127| */
  |     19|  128|OBJC_EXPORT SEL sel_registerName(const char *str)
  |     19|  129|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |     19|  130|
  |     19|  131|/** 
  ------------------
       |  132| * Returns the class name of a given object.
       |  133| * 
       |  134| * @param obj An Objective-C object.
       |  135| * 
       |  136| * @return The name of the class of which \e obj is an instance.
       |  137| */
       |  138|OBJC_EXPORT const char *object_getClassName(id obj)
       |  139|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
       |  140|
       |  141|/** 
       |  142| * Returns a pointer to any extra bytes allocated with an instance given object.
       |  143| * 
       |  144| * @param obj An Objective-C object.
       |  145| * 
       |  146| * @return A pointer to any extra bytes allocated with \e obj. If \e obj was
       |  147| *   not allocated with any extra bytes, then dereferencing the returned pointer is undefined.
       |  148| * 
       |  149| * @note This function returns a pointer to any extra bytes allocated with the instance
  ------------------
  | -[OCMInvocationMatcher matchesInvocation:]:
  |    413|   88|#ifndef nil
  |    413|   89|# if __has_feature(cxx_nullptr)
  |    413|   90|#   define nil nullptr
  |    413|   91|# else
  |     67|   92|#   define nil __DARWIN_NULL
  |    413|   93|# endif
  |    346|   94|#endif
  |    298|   95|
  |    346|   96|#if ! (defined(__OBJC_GC__)  ||  __has_feature(objc_arc))
  |     48|   97|#define __strong /* empty */
  |     48|   98|#endif
  |     72|   99|
  |     39|  100|#if !__has_feature(objc_arc)
  |     39|  101|#define __unsafe_unretained /* empty */
  |      0|  102|#define __autoreleasing /* empty */
  |      0|  103|#endif
  |      0|  104|
  |     39|  105|
  |     39|  106|/** 
  |     39|  107| * Returns the name of the method specified by a given selector.
  |     39|  108| * 
  |     39|  109| * @param sel A pointer of type \c SEL. Pass the selector whose name you wish to determine.
  |      0|  110| * 
  |      0|  111| * @return A C string indicating the name of the selector.
  |      0|  112| */
  |      0|  113|OBJC_EXPORT const char *sel_getName(SEL sel)
  |      0|  114|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |     39|  115|
  |     39|  116|/** 
  |      0|  117| * Registers a method with the Objective-C runtime system, maps the method 
  |     39|  118| * name to a selector, and returns the selector value.
  |     39|  119| * 
  |      1|  120| * @param str A pointer to a C string. Pass the name of the method you wish to register.
  |      1|  121| * 
  |      0|  122| * @return A pointer of type SEL specifying the selector for the named method.
  |      1|  123| * 
  |     38|  124| * @note You must register a method name with the Objective-C runtime system to obtain the
  |      0|  125| *  methods selector before you can add the method to a class definition. If the method name
  |      0|  126| *  has already been registered, this function simply returns the selector.
  |      0|  127| */
  |      0|  128|OBJC_EXPORT SEL sel_registerName(const char *str)
  |      0|  129|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |      0|  130|
  |      0|  131|/** 
  |      0|  132| * Returns the class name of a given object.
  |     38|  133| * 
  |      0|  134| * @param obj An Objective-C object.
  |      0|  135| * 
  |      0|  136| * @return The name of the class of which \e obj is an instance.
  |      0|  137| */
  |     38|  138|OBJC_EXPORT const char *object_getClassName(id obj)
  |     38|  139|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |     38|  140|
  |      0|  141|/** 
  |      0|  142| * Returns a pointer to any extra bytes allocated with an instance given object.
  |     38|  143| * 
  |     15|  144| * @param obj An Objective-C object.
  |     15|  145| * 
  |     38|  146| * @return A pointer to any extra bytes allocated with \e obj. If \e obj was
  |     39|  147| *   not allocated with any extra bytes, then dereferencing the returned pointer is undefined.
  |     33|  148| * 
  |     48|  149| * @note This function returns a pointer to any extra bytes allocated with the instance
  ------------------
       |  150| *  (as specified by \c class_createInstance with extraBytes>0). This memory follows the
  ------------------
  | OCMEqualTypesAllowingOpaqueStructsInternal:
  |      0|   81|# if __has_feature(cxx_nullptr)
  |      0|   82|#   define Nil nullptr
  |      0|   83|# else
  |      0|   84|#   define Nil __DARWIN_NULL
  |      0|   85|# endif
  |      0|   86|#endif
  |      0|   87|
  |      0|   88|#ifndef nil
  |      0|   89|# if __has_feature(cxx_nullptr)
  |      0|   90|#   define nil nullptr
  |      0|   91|# else
  |      0|   92|#   define nil __DARWIN_NULL
  |      0|   93|# endif
  |      0|   94|#endif
  |      0|   95|
  |      0|   96|#if ! (defined(__OBJC_GC__)  ||  __has_feature(objc_arc))
  |      0|   97|#define __strong /* empty */
  |      0|   98|#endif
  |      0|   99|
  |      0|  100|#if !__has_feature(objc_arc)
  |      0|  101|#define __unsafe_unretained /* empty */
  |      0|  102|#define __autoreleasing /* empty */
  |      0|  103|#endif
  |      0|  104|
  |      0|  105|
  |      0|  106|/** 
  |      0|  107| * Returns the name of the method specified by a given selector.
  |      0|  108| * 
  |      0|  109| * @param sel A pointer of type \c SEL. Pass the selector whose name you wish to determine.
  |      0|  110| * 
  |      0|  111| * @return A C string indicating the name of the selector.
  |      0|  112| */
  |      0|  113|OBJC_EXPORT const char *sel_getName(SEL sel)
  |      0|  114|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |      0|  115|
  |      0|  116|/** 
  |      0|  117| * Registers a method with the Objective-C runtime system, maps the method 
  |      0|  118| * name to a selector, and returns the selector value.
  |      0|  119| * 
  |      0|  120| * @param str A pointer to a C string. Pass the name of the method you wish to register.
  |      0|  121| * 
  |      0|  122| * @return A pointer of type SEL specifying the selector for the named method.
  |      0|  123| * 
  |      0|  124| * @note You must register a method name with the Objective-C runtime system to obtain the
  |      0|  125| *  methods selector before you can add the method to a class definition. If the method name
  |      0|  126| *  has already been registered, this function simply returns the selector.
  |      0|  127| */
  |      0|  128|OBJC_EXPORT SEL sel_registerName(const char *str)
  |      0|  129|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |      0|  130|
  |      0|  131|/** 
  |      0|  132| * Returns the class name of a given object.
  |      0|  133| * 
  |      0|  134| * @param obj An Objective-C object.
  |      0|  135| * 
  |      0|  136| * @return The name of the class of which \e obj is an instance.
  |      0|  137| */
  |      0|  138|OBJC_EXPORT const char *object_getClassName(id obj)
  |      0|  139|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |      0|  140|
  |      0|  141|/** 
  |      0|  142| * Returns a pointer to any extra bytes allocated with an instance given object.
  |      0|  143| * 
  |      0|  144| * @param obj An Objective-C object.
  |      0|  145| * 
  |      0|  146| * @return A pointer to any extra bytes allocated with \e obj. If \e obj was
  |      0|  147| *   not allocated with any extra bytes, then dereferencing the returned pointer is undefined.
  |      0|  148| * 
  |      0|  149| * @note This function returns a pointer to any extra bytes allocated with the instance
  |      0|  150| *  (as specified by \c class_createInstance with extraBytes>0). This memory follows the
  ------------------
       |  151| *  object's ordinary ivars, but may not be adjacent to the last ivar.
       |  152| * @note The returned pointer is guaranteed to be pointer-size aligned, even if the area following
       |  153| *  the object's last ivar is less aligned than that. Alignment greater than pointer-size is never
  ------------------
  | -[OCMBlockConstraint evaluate:]:
  |      0|  151| *  object's ordinary ivars, but may not be adjacent to the last ivar.
  |      0|  152| * @note The returned pointer is guaranteed to be pointer-size aligned, even if the area following
  |      0|  153| *  the object's last ivar is less aligned than that. Alignment greater than pointer-size is never
  ------------------
       |  154| *  guaranteed, even if the area following the object's last ivar is more aligned than that.
       |  155| * @note In a garbage-collected environment, the memory is scanned conservatively.
       |  156| */
       |  157|OBJC_EXPORT void *object_getIndexedIvars(id obj)
       |  158|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
       |  159|
       |  160|/** 
       |  161| * Identifies a selector as being valid or invalid.
       |  162| * 
       |  163| * @param sel The selector you want to identify.
  ------------------
  | -[OCClassMockObject forwardInvocationForClassObject:]:
  |      2|  151| *  object's ordinary ivars, but may not be adjacent to the last ivar.
  |      2|  152| * @note The returned pointer is guaranteed to be pointer-size aligned, even if the area following
  |      2|  153| *  the object's last ivar is less aligned than that. Alignment greater than pointer-size is never
  |      2|  154| *  guaranteed, even if the area following the object's last ivar is more aligned than that.
  |      0|  155| * @note In a garbage-collected environment, the memory is scanned conservatively.
  |      0|  156| */
  |      0|  157|OBJC_EXPORT void *object_getIndexedIvars(id obj)
  |      2|  158|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |      0|  159|
  |      0|  160|/** 
  |      0|  161| * Identifies a selector as being valid or invalid.
  |      0|  162| * 
  |      2|  163| * @param sel The selector you want to identify.
  ------------------
  | OCMEqualTypesAllowingOpaqueStructs:
  |      0|  153| *  the object's last ivar is less aligned than that. Alignment greater than pointer-size is never
  |      0|  154| *  guaranteed, even if the area following the object's last ivar is more aligned than that.
  |      0|  155| * @note In a garbage-collected environment, the memory is scanned conservatively.
  |      0|  156| */
  |      0|  157|OBJC_EXPORT void *object_getIndexedIvars(id obj)
  |      0|  158|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |      0|  159|
  |      0|  160|/** 
  |      0|  161| * Identifies a selector as being valid or invalid.
  |      0|  162| * 
  |      0|  163| * @param sel The selector you want to identify.
  ------------------
       |  164| * 
       |  165| * @return YES if selector is valid and has a function implementation, NO otherwise. 
       |  166| * 
       |  167| * @warning On some platforms, an invalid reference (to invalid memory addresses) can cause
       |  168| *  a crash. 
       |  169| */
       |  170|OBJC_EXPORT BOOL sel_isMapped(SEL sel)
       |  171|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
       |  172|
       |  173|/** 
       |  174| * Registers a method name with the Objective-C runtime system.
       |  175| * 
       |  176| * @param str A pointer to a C string. Pass the name of the method you wish to register.
       |  177| * 
       |  178| * @return A pointer of type SEL specifying the selector for the named method.
       |  179| * 
       |  180| * @note The implementation of this method is identical to the implementation of \c sel_registerName.
       |  181| * @note Prior to OS X version 10.0, this method tried to find the selector mapped to the given name
       |  182| *  and returned \c NULL if the selector was not found. This was changed for safety, because it was
       |  183| *  observed that many of the callers of this function did not check the return value for \c NULL.
       |  184| */
       |  185|OBJC_EXPORT SEL sel_getUid(const char *str)
       |  186|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
       |  187|
       |  188|
  ------------------
  | -[OCMockObject verifyAtLocation:]:
  |      0|  159|
  |      0|  160|/** 
  |      0|  161| * Identifies a selector as being valid or invalid.
  |      0|  162| * 
  |      0|  163| * @param sel The selector you want to identify.
  |      0|  164| * 
  |      0|  165| * @return YES if selector is valid and has a function implementation, NO otherwise. 
  |      0|  166| * 
  |      0|  167| * @warning On some platforms, an invalid reference (to invalid memory addresses) can cause
  |      0|  168| *  a crash. 
  |      0|  169| */
  |      0|  170|OBJC_EXPORT BOOL sel_isMapped(SEL sel)
  |      0|  171|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |      0|  172|
  |      0|  173|/** 
  |      0|  174| * Registers a method name with the Objective-C runtime system.
  |      0|  175| * 
  |      0|  176| * @param str A pointer to a C string. Pass the name of the method you wish to register.
  |      0|  177| * 
  |      0|  178| * @return A pointer of type SEL specifying the selector for the named method.
  |      0|  179| * 
  |      0|  180| * @note The implementation of this method is identical to the implementation of \c sel_registerName.
  |      0|  181| * @note Prior to OS X version 10.0, this method tried to find the selector mapped to the given name
  |      0|  182| *  and returned \c NULL if the selector was not found. This was changed for safety, because it was
  |      0|  183| *  observed that many of the callers of this function did not check the return value for \c NULL.
  |      0|  184| */
  |      0|  185|OBJC_EXPORT SEL sel_getUid(const char *str)
  |      0|  186|    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
  |      0|  187|
  |      0|  188|
  ------------------
       |  189|// Obsolete ARC conversions. Deprecation forthcoming.
       |  190|// Use CFBridgingRetain, CFBridgingRelease, and __bridge casts instead.
       |  191|
       |  192|typedef const void* objc_objectptr_t;
       |  193|
       |  194|#if __has_feature(objc_arc)
       |  195|#   define objc_retainedObject(o) ((__bridge_transfer id)(objc_objectptr_t)(o))
       |  196|#   define objc_unretainedObject(o) ((__bridge id)(objc_objectptr_t)(o))
       |  197|#   define objc_unretainedPointer(o) ((__bridge objc_objectptr_t)(id)(o))
       |  198|#else
       |  199|#   define objc_retainedObject(o) ((id)(objc_objectptr_t)(o))
       |  200|#   define objc_unretainedObject(o) ((id)(objc_objectptr_t)(o))
       |  201|#   define objc_unretainedPointer(o) ((objc_objectptr_t)(id)(o))
       |  202|#endif
       |  203|
       |  204|
       |  205|#if !__OBJC2__
       |  206|
       |  207|// The following declarations are provided here for source compatibility.
       |  208|
       |  209|#if defined(__LP64__)
       |  210|    typedef long arith_t;
       |  211|    typedef unsigned long uarith_t;
       |  212|#   define ARITH_SHIFT 32
       |  213|#else
       |  214|    typedef int arith_t;
       |  215|    typedef unsigned uarith_t;
  ------------------
  | -[OCPartialMockObject forwardInvocationForRealObject:]:
  |     80|  204|
  |     80|  205|#if !__OBJC2__
  |     80|  206|
  |     80|  207|// The following declarations are provided here for source compatibility.
  |      0|  208|
  |     80|  209|#if defined(__LP64__)
  |     80|  210|    typedef long arith_t;
  |     66|  211|    typedef unsigned long uarith_t;
  |     66|  212|#   define ARITH_SHIFT 32
  |     66|  213|#else
  |     66|  214|    typedef int arith_t;
  |     80|  215|    typedef unsigned uarith_t;
  ------------------
       |  216|#   define ARITH_SHIFT 16
       |  217|#endif
       |  218|
       |  219|typedef char *STR;
       |  220|
       |  221|#define ISSELECTOR(sel) sel_isMapped(sel)
       |  222|#define SELNAME(sel)	sel_getName(sel)
       |  223|#define SELUID(str)	sel_getUid(str)
       |  224|#define NAMEOF(obj)     object_getClassName(obj)
       |  225|#define IV(obj)         object_getIndexedIvars(obj)
       |  226|
       |  227|#endif
       |  228|
       |  229|#endif  /* _OBJC_OBJC_H_ */

/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.0.sdk/usr/include/sys/_types.h:
       |    1|/*
       |    2| * Copyright (c) 2003-2007 Apple Inc. All rights reserved.
       |    3| *
       |    4| * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
       |    5| * 
       |    6| * This file contains Original Code and/or Modifications of Original Code
       |    7| * as defined in and that are subject to the Apple Public Source License
       |    8| * Version 2.0 (the 'License'). You may not use this file except in
       |    9| * compliance with the License. The rights granted to you under the License
       |   10| * may not be used to create, or enable the creation or redistribution of,
       |   11| * unlawful or unlicensed copies of an Apple operating system, or to
       |   12| * circumvent, violate, or enable the circumvention or violation of, any
       |   13| * terms of an Apple operating system software license agreement.
       |   14| * 
       |   15| * Please obtain a copy of the License at
       |   16| * http://www.opensource.apple.com/apsl/ and read it before using this file.
       |   17| * 
       |   18| * The Original Code and all software distributed under the License are
       |   19| * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
       |   20| * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
       |   21| * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
       |   22| * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
       |   23| * Please see the License for the specific language governing rights and
       |   24| * limitations under the License.
       |   25| * 
       |   26| * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
       |   27| */
       |   28|
       |   29|#ifndef _SYS__TYPES_H_
       |   30|#define _SYS__TYPES_H_
       |   31|
       |   32|#include <sys/cdefs.h>
       |   33|#include <machine/_types.h>
       |   34|
       |   35|/*
       |   36| * Type definitions; takes common type definitions that must be used
       |   37| * in multiple header files due to [XSI], removes them from the system
       |   38| * space, and puts them in the implementation space.
       |   39| */
       |   40|
       |   41|#ifdef __cplusplus
       |   42|#ifdef __GNUG__
  ------------------
  | +[OCMMacroState endStubMacro]:
  |     51|   38| * space, and puts them in the implementation space.
  |     51|   39| */
  |     51|   40|
  |     51|   41|#ifdef __cplusplus
  |     51|   42|#ifdef __GNUG__
  ------------------
       |   43|#define __DARWIN_NULL __null
       |   44|#else /* ! __GNUG__ */
  ------------------
  | -[OCMBlockCaller handleInvocation:]:
  |      1|   39| */
  |      1|   40|
  |      1|   41|#ifdef __cplusplus
  |      1|   42|#ifdef __GNUG__
  |      1|   43|#define __DARWIN_NULL __null
  |      1|   44|#else /* ! __GNUG__ */
  ------------------
       |   45|#ifdef __LP64__
       |   46|#define __DARWIN_NULL (0L)
       |   47|#else /* !__LP64__ */
       |   48|#define __DARWIN_NULL 0
  ------------------
  | +[OCMConstraint constraintWithSelector:onObject:]:
  |      0|   38| * space, and puts them in the implementation space.
  |      0|   39| */
  |      0|   40|
  |      0|   41|#ifdef __cplusplus
  |      0|   42|#ifdef __GNUG__
  |      0|   43|#define __DARWIN_NULL __null
  |      0|   44|#else /* ! __GNUG__ */
  |      0|   45|#ifdef __LP64__
  |      0|   46|#define __DARWIN_NULL (0L)
  |      0|   47|#else /* !__LP64__ */
  |      0|   48|#define __DARWIN_NULL 0
  ------------------
       |   49|#endif /* __LP64__ */
       |   50|#endif /* __GNUG__ */
       |   51|#else /* ! __cplusplus */
  ------------------
  | -[OCProtocolMockObject methodSignatureForSelector:]:
  |      0|   42|#ifdef __GNUG__
  |      0|   43|#define __DARWIN_NULL __null
  |      0|   44|#else /* ! __GNUG__ */
  |      0|   45|#ifdef __LP64__
  |      0|   46|#define __DARWIN_NULL (0L)
  |      0|   47|#else /* !__LP64__ */
  |      0|   48|#define __DARWIN_NULL 0
  |      0|   49|#endif /* __LP64__ */
  |      0|   50|#endif /* __GNUG__ */
  |      0|   51|#else /* ! __cplusplus */
  ------------------
  2.77k|   52|#define __DARWIN_NULL ((void *)0)
       |   53|#endif /* __cplusplus */
  ------------------
  | -[OCMReturnValueProvider handleInvocation:]:
  |     28|   41|#ifdef __cplusplus
  |     28|   42|#ifdef __GNUG__
  |      0|   43|#define __DARWIN_NULL __null
  |      0|   44|#else /* ! __GNUG__ */
  |      0|   45|#ifdef __LP64__
  |     28|   46|#define __DARWIN_NULL (0L)
  |     28|   47|#else /* !__LP64__ */
  |      0|   48|#define __DARWIN_NULL 0
  |      0|   49|#endif /* __LP64__ */
  |      0|   50|#endif /* __GNUG__ */
  |      0|   51|#else /* ! __cplusplus */
  |     28|   52|#define __DARWIN_NULL ((void *)0)
  |     28|   53|#endif /* __cplusplus */
  ------------------
       |   54|
       |   55|typedef	__int64_t	__darwin_blkcnt_t;	/* total blocks */
  ------------------
  | +[NSObject(OCMAdditions) instanceMethodForwarderForSelector:]:
  |    435|   24| * limitations under the License.
  |    435|   25| * 
  |    435|   26| * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
  |    435|   27| */
  |    435|   28|
  |    435|   29|#ifndef _SYS__TYPES_H_
  |    435|   30|#define _SYS__TYPES_H_
  |    435|   31|
  |      1|   32|#include <sys/cdefs.h>
  |    435|   33|#include <machine/_types.h>
  |    435|   34|
  |    435|   35|/*
  |    435|   36| * Type definitions; takes common type definitions that must be used
  |    435|   37| * in multiple header files due to [XSI], removes them from the system
  |    435|   38| * space, and puts them in the implementation space.
  |    435|   39| */
  |    124|   40|
  |    124|   41|#ifdef __cplusplus
  |    124|   42|#ifdef __GNUG__
  |    124|   43|#define __DARWIN_NULL __null
  |    124|   44|#else /* ! __GNUG__ */
  |    435|   45|#ifdef __LP64__
  |    311|   46|#define __DARWIN_NULL (0L)
  |    311|   47|#else /* !__LP64__ */
  |    311|   48|#define __DARWIN_NULL 0
  |    435|   49|#endif /* __LP64__ */
  |    435|   50|#endif /* __GNUG__ */
  |      3|   51|#else /* ! __cplusplus */
  |    435|   52|#define __DARWIN_NULL ((void *)0)
  |    435|   53|#endif /* __cplusplus */
  |    432|   54|
  |    435|   55|typedef	__int64_t	__darwin_blkcnt_t;	/* total blocks */
  ------------------
       |   56|typedef	__int32_t	__darwin_blksize_t;	/* preferred block size */
       |   57|typedef __int32_t	__darwin_dev_t;		/* dev_t */
       |   58|typedef unsigned int	__darwin_fsblkcnt_t;	/* Used by statvfs and fstatvfs */
       |   59|typedef unsigned int	__darwin_fsfilcnt_t;	/* Used by statvfs and fstatvfs */
  ------------------
  | -[OCClassMockObject stopMocking]:
  |     26|   55|typedef	__int64_t	__darwin_blkcnt_t;	/* total blocks */
  |     26|   56|typedef	__int32_t	__darwin_blksize_t;	/* preferred block size */
  |     11|   57|typedef __int32_t	__darwin_dev_t;		/* dev_t */
  |     26|   58|typedef unsigned int	__darwin_fsblkcnt_t;	/* Used by statvfs and fstatvfs */
  |     26|   59|typedef unsigned int	__darwin_fsfilcnt_t;	/* Used by statvfs and fstatvfs */
  ------------------
       |   60|typedef __uint32_t	__darwin_gid_t;		/* [???] process and group IDs */
       |   61|typedef __uint32_t	__darwin_id_t;		/* [XSI] pid_t, uid_t, or gid_t*/
  ------------------
  | -[OCProtocolMockObject respondsToSelector:]:
  |      0|   59|typedef unsigned int	__darwin_fsfilcnt_t;	/* Used by statvfs and fstatvfs */
  |      0|   60|typedef __uint32_t	__darwin_gid_t;		/* [???] process and group IDs */
  |      0|   61|typedef __uint32_t	__darwin_id_t;		/* [XSI] pid_t, uid_t, or gid_t*/
  ------------------
       |   62|typedef __uint64_t	__darwin_ino64_t;	/* [???] Used for 64 bit inodes */
       |   63|#if __DARWIN_64_BIT_INO_T
       |   64|typedef __darwin_ino64_t __darwin_ino_t;	/* [???] Used for inodes */
  ------------------
  | OCMNumberForValue:
  |      0|   45|#ifdef __LP64__
  |      0|   46|#define __DARWIN_NULL (0L)
  |      0|   47|#else /* !__LP64__ */
  |      0|   48|#define __DARWIN_NULL 0
  |      0|   49|#endif /* __LP64__ */
  |      0|   50|#endif /* __GNUG__ */
  |      0|   51|#else /* ! __cplusplus */
  |      0|   52|#define __DARWIN_NULL ((void *)0)
  |      0|   53|#endif /* __cplusplus */
  |      0|   54|
  |      0|   55|typedef	__int64_t	__darwin_blkcnt_t;	/* total blocks */
  |      0|   56|typedef	__int32_t	__darwin_blksize_t;	/* preferred block size */
  |      0|   57|typedef __int32_t	__darwin_dev_t;		/* dev_t */
  |      0|   58|typedef unsigned int	__darwin_fsblkcnt_t;	/* Used by statvfs and fstatvfs */
  |      0|   59|typedef unsigned int	__darwin_fsfilcnt_t;	/* Used by statvfs and fstatvfs */
  |      0|   60|typedef __uint32_t	__darwin_gid_t;		/* [???] process and group IDs */
  |      0|   61|typedef __uint32_t	__darwin_id_t;		/* [XSI] pid_t, uid_t, or gid_t*/
  |      0|   62|typedef __uint64_t	__darwin_ino64_t;	/* [???] Used for 64 bit inodes */
  |      0|   63|#if __DARWIN_64_BIT_INO_T
  |      0|   64|typedef __darwin_ino64_t __darwin_ino_t;	/* [???] Used for inodes */
  ------------------
       |   65|#else /* !__DARWIN_64_BIT_INO_T */
       |   66|typedef __uint32_t	__darwin_ino_t;		/* [???] Used for inodes */
  ------------------
  | -[OCClassMockObject restoreMetaClass]:
  |     18|   62|typedef __uint64_t	__darwin_ino64_t;	/* [???] Used for 64 bit inodes */
  |     18|   63|#if __DARWIN_64_BIT_INO_T
  |     18|   64|typedef __darwin_ino64_t __darwin_ino_t;	/* [???] Used for inodes */
  |     18|   65|#else /* !__DARWIN_64_BIT_INO_T */
  |     18|   66|typedef __uint32_t	__darwin_ino_t;		/* [???] Used for inodes */
  ------------------
       |   67|#endif /* __DARWIN_64_BIT_INO_T */
  ------------------
  | +[OCMMacroState endVerifyMacro]:
  |      0|   65|#else /* !__DARWIN_64_BIT_INO_T */
  |      0|   66|typedef __uint32_t	__darwin_ino_t;		/* [???] Used for inodes */
  |      0|   67|#endif /* __DARWIN_64_BIT_INO_T */
  ------------------
       |   68|typedef __darwin_natural_t __darwin_mach_port_name_t; /* Used by mach */
       |   69|typedef __darwin_mach_port_name_t __darwin_mach_port_t; /* Used by mach */
       |   70|typedef __uint16_t	__darwin_mode_t;	/* [???] Some file attributes */
  ------------------
  | -[OCPartialMockObject assertClassIsSupported:]:
  |      8|   60|typedef __uint32_t	__darwin_gid_t;		/* [???] process and group IDs */
  |      8|   61|typedef __uint32_t	__darwin_id_t;		/* [XSI] pid_t, uid_t, or gid_t*/
  |      8|   62|typedef __uint64_t	__darwin_ino64_t;	/* [???] Used for 64 bit inodes */
  |      8|   63|#if __DARWIN_64_BIT_INO_T
  |      0|   64|typedef __darwin_ino64_t __darwin_ino_t;	/* [???] Used for inodes */
  |      8|   65|#else /* !__DARWIN_64_BIT_INO_T */
  |      0|   66|typedef __uint32_t	__darwin_ino_t;		/* [???] Used for inodes */
  |      8|   67|#endif /* __DARWIN_64_BIT_INO_T */
  |      8|   68|typedef __darwin_natural_t __darwin_mach_port_name_t; /* Used by mach */
  |      0|   69|typedef __darwin_mach_port_name_t __darwin_mach_port_t; /* Used by mach */
  |      8|   70|typedef __uint16_t	__darwin_mode_t;	/* [???] Some file attributes */
  ------------------
       |   71|typedef __int64_t	__darwin_off_t;		/* [???] Used for file sizes */
       |   72|typedef __int32_t	__darwin_pid_t;		/* [???] process and group IDs */
       |   73|typedef __uint32_t	__darwin_sigset_t;	/* [???] signal set */
  ------------------
  | +[NSObject(OCMAdditions) enumerateMethodsInClass:usingBlock:]:
  |     27|   59|typedef unsigned int	__darwin_fsfilcnt_t;	/* Used by statvfs and fstatvfs */
  |     99|   60|typedef __uint32_t	__darwin_gid_t;		/* [???] process and group IDs */
  |     72|   61|typedef __uint32_t	__darwin_id_t;		/* [XSI] pid_t, uid_t, or gid_t*/
  |     72|   62|typedef __uint64_t	__darwin_ino64_t;	/* [???] Used for 64 bit inodes */
  |     72|   63|#if __DARWIN_64_BIT_INO_T
  |      7|   64|typedef __darwin_ino64_t __darwin_ino_t;	/* [???] Used for inodes */
  |     72|   65|#else /* !__DARWIN_64_BIT_INO_T */
  |  34.1k|   66|typedef __uint32_t	__darwin_ino_t;		/* [???] Used for inodes */
  |  34.0k|   67|#endif /* __DARWIN_64_BIT_INO_T */
  |  34.0k|   68|typedef __darwin_natural_t __darwin_mach_port_name_t; /* Used by mach */
  |  34.0k|   69|typedef __darwin_mach_port_name_t __darwin_mach_port_t; /* Used by mach */
  |  34.0k|   70|typedef __uint16_t	__darwin_mode_t;	/* [???] Some file attributes */
  |     65|   71|typedef __int64_t	__darwin_off_t;		/* [???] Used for file sizes */
  |     65|   72|typedef __int32_t	__darwin_pid_t;		/* [???] process and group IDs */
  |     27|   73|typedef __uint32_t	__darwin_sigset_t;	/* [???] signal set */
  ------------------
       |   74|typedef __int32_t	__darwin_suseconds_t;	/* [???] microseconds */
       |   75|typedef __uint32_t	__darwin_uid_t;		/* [???] user IDs */
       |   76|typedef __uint32_t	__darwin_useconds_t;	/* [???] microseconds */
       |   77|typedef	unsigned char	__darwin_uuid_t[16];
       |   78|typedef	char	__darwin_uuid_string_t[37];
       |   79|
       |   80|#include <sys/_pthread/_pthread_types.h>
  ------------------
  | -[OCObserverMockObject verify]:
  |      0|   78|typedef	char	__darwin_uuid_string_t[37];
  |      0|   79|
  |      0|   80|#include <sys/_pthread/_pthread_types.h>
  ------------------
       |   81|
       |   82|#if defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 5 || __GNUC__ > 3)
       |   83|#define __offsetof(type, field) __builtin_offsetof(type, field)
       |   84|#else /* !(gcc >= 3.5) */
  ------------------
  | -[OCMObserverRecorder argument:matchesArgument:]:
  |      0|   63|#if __DARWIN_64_BIT_INO_T
  |      0|   64|typedef __darwin_ino64_t __darwin_ino_t;	/* [???] Used for inodes */
  |      0|   65|#else /* !__DARWIN_64_BIT_INO_T */
  |      0|   66|typedef __uint32_t	__darwin_ino_t;		/* [???] Used for inodes */
  |      0|   67|#endif /* __DARWIN_64_BIT_INO_T */
  |      0|   68|typedef __darwin_natural_t __darwin_mach_port_name_t; /* Used by mach */
  |      0|   69|typedef __darwin_mach_port_name_t __darwin_mach_port_t; /* Used by mach */
  |      0|   70|typedef __uint16_t	__darwin_mode_t;	/* [???] Some file attributes */
  |      0|   71|typedef __int64_t	__darwin_off_t;		/* [???] Used for file sizes */
  |      0|   72|typedef __int32_t	__darwin_pid_t;		/* [???] process and group IDs */
  |      0|   73|typedef __uint32_t	__darwin_sigset_t;	/* [???] signal set */
  |      0|   74|typedef __int32_t	__darwin_suseconds_t;	/* [???] microseconds */
  |      0|   75|typedef __uint32_t	__darwin_uid_t;		/* [???] user IDs */
  |      0|   76|typedef __uint32_t	__darwin_useconds_t;	/* [???] microseconds */
  |      0|   77|typedef	unsigned char	__darwin_uuid_t[16];
  |      0|   78|typedef	char	__darwin_uuid_string_t[37];
  |      0|   79|
  |      0|   80|#include <sys/_pthread/_pthread_types.h>
  |      0|   81|
  |      0|   82|#if defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 5 || __GNUC__ > 3)
  |      0|   83|#define __offsetof(type, field) __builtin_offsetof(type, field)
  |      0|   84|#else /* !(gcc >= 3.5) */
  ------------------
  | -[OCMIsNilConstraint evaluate:]:
  |      0|   82|#if defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 5 || __GNUC__ > 3)
  |      0|   83|#define __offsetof(type, field) __builtin_offsetof(type, field)
  |      0|   84|#else /* !(gcc >= 3.5) */
  ------------------
       |   85|#define __offsetof(type, field) ((size_t)(&((type *)0)->field))
  ------------------
  | -[OCPartialMockObject stopMocking]:
  |     16|   76|typedef __uint32_t	__darwin_useconds_t;	/* [???] microseconds */
  |     16|   77|typedef	unsigned char	__darwin_uuid_t[16];
  |      8|   78|typedef	char	__darwin_uuid_string_t[37];
  |      8|   79|
  |      8|   80|#include <sys/_pthread/_pthread_types.h>
  |      8|   81|
  |      8|   82|#if defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 5 || __GNUC__ > 3)
  |      8|   83|#define __offsetof(type, field) __builtin_offsetof(type, field)
  |     16|   84|#else /* !(gcc >= 3.5) */
  |     16|   85|#define __offsetof(type, field) ((size_t)(&((type *)0)->field))
  ------------------
       |   86|#endif /* (gcc >= 3.5) */
       |   87|
       |   88|
       |   89|#endif	/* _SYS__TYPES_H_ */

/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/7.0.0/include/limits.h:
       |    1|/*===---- limits.h - Standard header for integer sizes --------------------===*\
       |    2| *
       |    3| * Copyright (c) 2009 Chris Lattner
       |    4| *
       |    5| * Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6| * of this software and associated documentation files (the "Software"), to deal
       |    7| * in the Software without restriction, including without limitation the rights
       |    8| * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9| * copies of the Software, and to permit persons to whom the Software is
       |   10| * furnished to do so, subject to the following conditions:
       |   11| *
       |   12| * The above copyright notice and this permission notice shall be included in
       |   13| * all copies or substantial portions of the Software.
       |   14| *
       |   15| * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16| * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17| * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18| * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19| * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20| * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21| * THE SOFTWARE.
       |   22| *
       |   23|\*===----------------------------------------------------------------------===*/
       |   24|
       |   25|#ifndef __CLANG_LIMITS_H
       |   26|#define __CLANG_LIMITS_H
       |   27|
       |   28|/* The system's limits.h may, in turn, try to #include_next GCC's limits.h.
       |   29|   Avert this #include_next madness. */
       |   30|#if defined __GNUC__ && !defined _GCC_LIMITS_H_
       |   31|#define _GCC_LIMITS_H_
       |   32|#endif
       |   33|
       |   34|/* System headers include a number of constants from POSIX in <limits.h>.
       |   35|   Include it if we're hosted. */
       |   36|#if __STDC_HOSTED__ && __has_include_next(<limits.h>)
       |   37|#include_next <limits.h>
       |   38|#endif
       |   39|
       |   40|/* Many system headers try to "help us out" by defining these.  No really, we
       |   41|   know how big each datatype is. */
       |   42|#undef  SCHAR_MIN
       |   43|#undef  SCHAR_MAX
       |   44|#undef  UCHAR_MAX
       |   45|#undef  SHRT_MIN
       |   46|#undef  SHRT_MAX
       |   47|#undef  USHRT_MAX
       |   48|#undef  INT_MIN
       |   49|#undef  INT_MAX
       |   50|#undef  UINT_MAX
       |   51|#undef  LONG_MIN
       |   52|#undef  LONG_MAX
       |   53|#undef  ULONG_MAX
       |   54|
       |   55|#undef  CHAR_BIT
       |   56|#undef  CHAR_MIN
       |   57|#undef  CHAR_MAX
       |   58|
       |   59|/* C90/99 5.2.4.2.1 */
       |   60|#define SCHAR_MAX __SCHAR_MAX__
      0|   61|#define SHRT_MAX  __SHRT_MAX__
       |   62|#define INT_MAX   __INT_MAX__
       |   63|#define LONG_MAX  __LONG_MAX__
       |   64|
      0|   65|#define SCHAR_MIN (-__SCHAR_MAX__-1)
      0|   66|#define SHRT_MIN  (-__SHRT_MAX__ -1)
       |   67|#define INT_MIN   (-__INT_MAX__  -1)
       |   68|#define LONG_MIN  (-__LONG_MAX__ -1L)
       |   69|
      0|   70|#define UCHAR_MAX (__SCHAR_MAX__*2  +1)
      0|   71|#define USHRT_MAX (__SHRT_MAX__ *2  +1)
       |   72|#define UINT_MAX  (__INT_MAX__  *2U +1U)
       |   73|#define ULONG_MAX (__LONG_MAX__ *2UL+1UL)
       |   74|
       |   75|#ifndef MB_LEN_MAX
       |   76|#define MB_LEN_MAX 1
       |   77|#endif
       |   78|
       |   79|#define CHAR_BIT  __CHAR_BIT__
       |   80|
       |   81|#ifdef __CHAR_UNSIGNED__  /* -funsigned-char */
       |   82|#define CHAR_MIN 0
       |   83|#define CHAR_MAX UCHAR_MAX
       |   84|#else
      0|   85|#define CHAR_MIN SCHAR_MIN
      0|   86|#define CHAR_MAX __SCHAR_MAX__
       |   87|#endif
       |   88|
       |   89|/* C99 5.2.4.2.1: Added long long.
       |   90|   C++11 18.3.3.2: same contents as the Standard C Library header <limits.h>.
       |   91| */
       |   92|#if __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L
       |   93|
       |   94|#undef  LLONG_MIN
       |   95|#undef  LLONG_MAX
       |   96|#undef  ULLONG_MAX
       |   97|
      0|   98|#define LLONG_MAX  __LONG_LONG_MAX__
      0|   99|#define LLONG_MIN  (-__LONG_LONG_MAX__-1LL)
       |  100|#define ULLONG_MAX (__LONG_LONG_MAX__*2ULL+1ULL)
       |  101|#endif
       |  102|
       |  103|/* LONG_LONG_MIN/LONG_LONG_MAX/ULONG_LONG_MAX are a GNU extension.  It's too bad
       |  104|   that we don't have something like #pragma poison that could be used to
       |  105|   deprecate a macro - the code should just use LLONG_MAX and friends.
       |  106| */
       |  107|#if defined(__GNU_LIBRARY__) ? defined(__USE_GNU) : !defined(__STRICT_ANSI__)
       |  108|
       |  109|#undef   LONG_LONG_MIN
       |  110|#undef   LONG_LONG_MAX
       |  111|#undef   ULONG_LONG_MAX
       |  112|
       |  113|#define LONG_LONG_MAX  __LONG_LONG_MAX__
       |  114|#define LONG_LONG_MIN  (-__LONG_LONG_MAX__-1LL)
       |  115|#define ULONG_LONG_MAX (__LONG_LONG_MAX__*2ULL+1ULL)
       |  116|#endif
       |  117|
       |  118|#endif /* __CLANG_LIMITS_H */

/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/7.0.0/include/stdbool.h:
       |    1|/*===---- stdbool.h - Standard header for booleans -------------------------===
       |    2| *
       |    3| * Copyright (c) 2008 Eli Friedman
       |    4| *
       |    5| * Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6| * of this software and associated documentation files (the "Software"), to deal
       |    7| * in the Software without restriction, including without limitation the rights
       |    8| * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9| * copies of the Software, and to permit persons to whom the Software is
       |   10| * furnished to do so, subject to the following conditions:
       |   11| *
       |   12| * The above copyright notice and this permission notice shall be included in
       |   13| * all copies or substantial portions of the Software.
       |   14| *
       |   15| * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16| * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17| * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18| * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19| * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20| * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21| * THE SOFTWARE.
       |   22| *
       |   23| *===-----------------------------------------------------------------------===
       |   24| */
       |   25|
       |   26|#ifndef __STDBOOL_H
       |   27|#define __STDBOOL_H
       |   28|
       |   29|/* Don't define bool, true, and false in C++, except as a GNU extension. */
       |   30|#ifndef __cplusplus
      0|   31|#define bool _Bool
       |   32|#define true 1
       |   33|#define false 0
       |   34|#elif defined(__GNUC__) && !defined(__STRICT_ANSI__)
       |   35|/* Define _Bool, bool, false, true as a GNU extension. */
       |   36|#define _Bool bool
       |   37|#define bool  bool
       |   38|#define false false
       |   39|#define true  true
       |   40|#endif
       |   41|
       |   42|#define __bool_true_false_are_defined 1
       |   43|
       |   44|#endif /* __STDBOOL_H */

/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/7.0.0/include/stddef.h:
       |    1|/*===---- stddef.h - Basic type definitions --------------------------------===
       |    2| *
       |    3| * Copyright (c) 2008 Eli Friedman
       |    4| *
       |    5| * Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6| * of this software and associated documentation files (the "Software"), to deal
       |    7| * in the Software without restriction, including without limitation the rights
       |    8| * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9| * copies of the Software, and to permit persons to whom the Software is
       |   10| * furnished to do so, subject to the following conditions:
       |   11| *
       |   12| * The above copyright notice and this permission notice shall be included in
       |   13| * all copies or substantial portions of the Software.
       |   14| *
       |   15| * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16| * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17| * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18| * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19| * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20| * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21| * THE SOFTWARE.
       |   22| *
       |   23| *===-----------------------------------------------------------------------===
       |   24| */
       |   25|
       |   26|#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
       |   27|    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
       |   28|    defined(__need_NULL) || defined(__need_wint_t)
       |   29|
       |   30|#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
       |   31|    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
       |   32|    !defined(__need_wint_t)
       |   33|/* Always define miscellaneous pieces when modules are available. */
       |   34|#if !__has_feature(modules)
       |   35|#define __STDDEF_H
       |   36|#endif
       |   37|#define __need_ptrdiff_t
       |   38|#define __need_size_t
       |   39|#define __need_wchar_t
       |   40|#define __need_NULL
       |   41|#define __need_STDDEF_H_misc
  ------------------
  | +[OCMockObject initialize]:
  |      3|   38|#define __need_size_t
  |      3|   39|#define __need_wchar_t
  |      0|   40|#define __need_NULL
  |      3|   41|#define __need_STDDEF_H_misc
  ------------------
       |   42|/* __need_wint_t is intentionally not defined here. */
       |   43|#endif
       |   44|
       |   45|#if defined(__need_ptrdiff_t)
  ------------------
  | -[NSMethodSignature(OCMAdditions) usesSpecialStructureReturn]:
  |    124|   25|
  |    124|   26|#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
  |    124|   27|    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
  |    124|   28|    defined(__need_NULL) || defined(__need_wint_t)
  |    122|   29|
  |    124|   30|#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
  |    124|   31|    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
  |    124|   32|    !defined(__need_wint_t)
  |    124|   33|/* Always define miscellaneous pieces when modules are available. */
  |    124|   34|#if !__has_feature(modules)
  |    124|   35|#define __STDDEF_H
  |    124|   36|#endif
  |    124|   37|#define __need_ptrdiff_t
  |    124|   38|#define __need_size_t
  |    124|   39|#define __need_wchar_t
  |    124|   40|#define __need_NULL
  |    124|   41|#define __need_STDDEF_H_misc
  |    124|   42|/* __need_wint_t is intentionally not defined here. */
  |      2|   43|#endif
  |      2|   44|
  |    124|   45|#if defined(__need_ptrdiff_t)
  ------------------
       |   46|#if !defined(_PTRDIFF_T) || __has_feature(modules)
       |   47|/* Always define ptrdiff_t when modules are available. */
       |   48|#if !__has_feature(modules)
       |   49|#define _PTRDIFF_T
       |   50|#endif
       |   51|typedef __PTRDIFF_TYPE__ ptrdiff_t;
  ------------------
  | -[OCProtocolMockObject methodSignatureForSelector:]:
  |      0|   42|/* __need_wint_t is intentionally not defined here. */
  |      0|   43|#endif
  |      0|   44|
  |      0|   45|#if defined(__need_ptrdiff_t)
  |      0|   46|#if !defined(_PTRDIFF_T) || __has_feature(modules)
  |      0|   47|/* Always define ptrdiff_t when modules are available. */
  |      0|   48|#if !__has_feature(modules)
  |      0|   49|#define _PTRDIFF_T
  |      0|   50|#endif
  |      0|   51|typedef __PTRDIFF_TYPE__ ptrdiff_t;
  ------------------
       |   52|#endif
       |   53|#undef __need_ptrdiff_t
       |   54|#endif /* defined(__need_ptrdiff_t) */
       |   55|
       |   56|#if defined(__need_size_t)
       |   57|#if !defined(_SIZE_T) || __has_feature(modules)
       |   58|/* Always define size_t when modules are available. */
  ------------------
  | OCMIsObjectType:
  |    147|   39|#define __need_wchar_t
  |    147|   40|#define __need_NULL
  |    147|   41|#define __need_STDDEF_H_misc
  |    147|   42|/* __need_wint_t is intentionally not defined here. */
  |    134|   43|#endif
  |    147|   44|
  |    147|   45|#if defined(__need_ptrdiff_t)
  |     13|   46|#if !defined(_PTRDIFF_T) || __has_feature(modules)
  |     13|   47|/* Always define ptrdiff_t when modules are available. */
  |     13|   48|#if !__has_feature(modules)
  |     13|   49|#define _PTRDIFF_T
  |      0|   50|#endif
  |     13|   51|typedef __PTRDIFF_TYPE__ ptrdiff_t;
  |     13|   52|#endif
  |     13|   53|#undef __need_ptrdiff_t
  |     13|   54|#endif /* defined(__need_ptrdiff_t) */
  |      2|   55|
  |     13|   56|#if defined(__need_size_t)
  |     11|   57|#if !defined(_SIZE_T) || __has_feature(modules)
  |     13|   58|/* Always define size_t when modules are available. */
  ------------------
       |   59|#if !__has_feature(modules)
       |   60|#define _SIZE_T
       |   61|#endif
       |   62|typedef __SIZE_TYPE__ size_t;
       |   63|#endif
       |   64|#undef __need_size_t
       |   65|#endif /*defined(__need_size_t) */
       |   66|
  ------------------
  | OCMTypeWithoutQualifiers:
  |    500|   62|typedef __SIZE_TYPE__ size_t;
  |    500|   63|#endif
  |      0|   64|#undef __need_size_t
  |    500|   65|#endif /*defined(__need_size_t) */
  |    500|   66|
  ------------------
       |   67|#if defined(__need_STDDEF_H_misc)
       |   68|/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
       |   69| * enabled. */
       |   70|#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
       |   71|     !defined(_RSIZE_T)) || __has_feature(modules)
       |   72|/* Always define rsize_t when modules are available. */
       |   73|#if !__has_feature(modules)
  ------------------
  | +[NSObject(OCMAdditions) enumerateMethodsInClass:usingBlock:]:
  |     27|   59|#if !__has_feature(modules)
  |     99|   60|#define _SIZE_T
  |     72|   61|#endif
  |     72|   62|typedef __SIZE_TYPE__ size_t;
  |     72|   63|#endif
  |      7|   64|#undef __need_size_t
  |     72|   65|#endif /*defined(__need_size_t) */
  |  34.1k|   66|
  |  34.0k|   67|#if defined(__need_STDDEF_H_misc)
  |  34.0k|   68|/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
  |  34.0k|   69| * enabled. */
  |  34.0k|   70|#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
  |     65|   71|     !defined(_RSIZE_T)) || __has_feature(modules)
  |     65|   72|/* Always define rsize_t when modules are available. */
  |     27|   73|#if !__has_feature(modules)
  ------------------
       |   74|#define _RSIZE_T
       |   75|#endif
       |   76|typedef __SIZE_TYPE__ rsize_t;
       |   77|#endif
       |   78|#endif /* defined(__need_STDDEF_H_misc) */
       |   79|
       |   80|#if defined(__need_wchar_t)
       |   81|#ifndef __cplusplus
       |   82|/* Always define wchar_t when modules are available. */
       |   83|#if !defined(_WCHAR_T) || __has_feature(modules)
       |   84|#if !__has_feature(modules)
       |   85|#define _WCHAR_T
       |   86|#if defined(_MSC_EXTENSIONS)
       |   87|#define _WCHAR_T_DEFINED
       |   88|#endif
       |   89|#endif
       |   90|typedef __WCHAR_TYPE__ wchar_t;
       |   91|#endif
       |   92|#endif
       |   93|#undef __need_wchar_t
       |   94|#endif /* defined(__need_wchar_t) */
       |   95|
       |   96|#if defined(__need_NULL)
       |   97|#undef NULL
       |   98|#ifdef __cplusplus
       |   99|#  if !defined(__MINGW32__) && !defined(_MSC_VER)
       |  100|#    define NULL __null
       |  101|#  else
       |  102|#    define NULL 0
       |  103|#  endif
       |  104|#else
  35.7k|  105|#  define NULL ((void*)0)
       |  106|#endif
       |  107|#ifdef __cplusplus
       |  108|#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
       |  109|namespace std { typedef decltype(nullptr) nullptr_t; }
       |  110|using ::std::nullptr_t;
       |  111|#endif
       |  112|#endif
  ------------------
  | +[OCMArg resolveSpecialValues:]:
  |      0|   94|#endif /* defined(__need_wchar_t) */
  |      0|   95|
  |      0|   96|#if defined(__need_NULL)
  |      0|   97|#undef NULL
  |      0|   98|#ifdef __cplusplus
  |      0|   99|#  if !defined(__MINGW32__) && !defined(_MSC_VER)
  |      0|  100|#    define NULL __null
  |      0|  101|#  else
  |      0|  102|#    define NULL 0
  |      0|  103|#  endif
  |      0|  104|#else
  |      0|  105|#  define NULL ((void*)0)
  |      0|  106|#endif
  |      0|  107|#ifdef __cplusplus
  |      0|  108|#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
  |      0|  109|namespace std { typedef decltype(nullptr) nullptr_t; }
  |      0|  110|using ::std::nullptr_t;
  |      0|  111|#endif
  |      0|  112|#endif
  ------------------
       |  113|#undef __need_NULL
       |  114|#endif /* defined(__need_NULL) */
       |  115|
       |  116|#if defined(__need_STDDEF_H_misc)
       |  117|#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
       |  118|#include "__stddef_max_align_t.h"
       |  119|#endif
       |  120|#define offsetof(t, d) __builtin_offsetof(t, d)
       |  121|#undef __need_STDDEF_H_misc
       |  122|#endif  /* defined(__need_STDDEF_H_misc) */
       |  123|
       |  124|/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
       |  125|__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
       |  126|#if defined(__need_wint_t)
       |  127|/* Always define wint_t when modules are available. */
       |  128|#if !defined(_WINT_T) || __has_feature(modules)
       |  129|#if !__has_feature(modules)
       |  130|#define _WINT_T
       |  131|#endif
       |  132|typedef __WINT_TYPE__ wint_t;
       |  133|#endif
       |  134|#undef __need_wint_t
       |  135|#endif /* __need_wint_t */
       |  136|
       |  137|#endif

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/AddressCellMailingAddressViewModelTests.swift:
       |    1|//
       |    2|//  AddressCellGuestControllerBindingTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 11/5/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|import PaperlessPost
       |   12|
       |   13|class MockMailingObject : NSObject, MailingAddress {
       |   14|    
       |   15|    dynamic var addressLine1: String?
       |   16|    dynamic var addressLine2: String?
       |   17|    dynamic var city: String?
       |   18|    dynamic var state: String?
       |   19|    dynamic var zipCode: String?
       |   20|    dynamic var country_: String?
       |   21|    
      3|   22|    convenience init(defaults: Bool) {
      3|   23|        self.init()
      3|   24|        if defaults {
      3|   25|            self.addressLine1 = "115 Broadway"
      3|   26|            self.addressLine2 = "1802"
      3|   27|            self.city = "New York"
      3|   28|            self.state = "NY"
      3|   29|            self.zipCode = "10001"
      3|   30|            self.country_ = "MURICA"
      3|   31|        }
      3|   32|    }
       |   33|}
       |   34|
       |   35|
       |   36|class AddressCellMailingAddressViewModelTests: XCTestCase {
       |   37|    
      1|   38|    func testTheCellsValuesUpdateOnInit() {
      1|   39| 
      1|   40|        let mailingObject = MockMailingObject(defaults: true)
      1|   41|        
      1|   42|        let addressCell = AddressCollectionCell(frame: CGRect(x: 0, y: 0, width: 300, height: 400))
      1|   43|        
      1|   44|        _ = AddressCellMailingAddressViewModel(mailingObject: mailingObject, cell: addressCell)
      1|   45|        
      1|   46|        assertPropertiesAreEqual(mailingObject, addressCell: addressCell)
      1|   47|    }
       |   48|    
      1|   49|    func testUpdatingTheModelUpdatesTheCell() {
      1|   50|        
      1|   51|        let mailingObject = MockMailingObject(defaults: true)
      1|   52|        let addressCell = AddressCollectionCell(frame: CGRect(x: 0, y: 0, width: 300, height: 400))
      1|   53|        _ = AddressCellMailingAddressViewModel(mailingObject: mailingObject, cell: addressCell)
      1|   54|
      1|   55|        mailingObject.addressLine2 = "This is a test of line 2"
      1|   56|        
      1|   57|        XCTAssertTrue(addressCell.addressLine2 == mailingObject.addressLine2, "After updating the model, the cell's text should update")
      1|   58|    }
       |   59|    
      1|   60|    func testSubscribingForCellChangesWorks() {
      1|   61|        
      1|   62|        let mailingObject = MockMailingObject(defaults: true)
      1|   63|        let addressCell = AddressCollectionCell(frame: CGRect(x: 0, y: 0, width: 300, height: 400))
      1|   64|        let observer = AddressCellMailingAddressViewModel(mailingObject: mailingObject, cell: addressCell)
      1|   65|        
      1|   66|        var receivedMessage = false
      1|   67|        observer.setOnAddressCellFieldChangeBlock { (cell: AddressCollectionCell!, keyPath: String!) -> Void in
      1|   68|            mailingObject.addressLine1 = addressCell.addressLine1
      1|   69|            receivedMessage = true
      1|   70|        }
      1|   71|
      1|   72|        addressCell.addressLine1 = "this is the new line 1"
      1|   73|        
      1|   74|        XCTAssertTrue(receivedMessage, "Should have received a message after updating the cell's property")
      1|   75|        
      1|   76|        XCTAssertTrue(mailingObject.addressLine1 == addressCell.addressLine1, "After updating the cell's mailing address line 1, the mailingObject should also have been updated")
      1|   77|    }
       |   78|    
       |   79|}
       |   80|
       |   81|
       |   82|
       |   83|
       |   84|// MARK: Helpers Funcs
       |   85|
       |   86|
       |   87|
      1|   88|func assertPropertiesAreEqual(mailingObject: MailingAddress, addressCell: AddressCollectionCell) {
      1|   89|    XCTAssertTrue(addressCell.addressLine1 == mailingObject.addressLine1, "Line 1 field should have been updated to reflect the model")
      1|   90|    XCTAssertTrue(addressCell.addressLine2 == mailingObject.addressLine2, "Line 2 field should have been updated to reflect the model")
      1|   91|    XCTAssertTrue(addressCell.city == mailingObject.city, "City field should have been updated to reflect the model")
      1|   92|    XCTAssertTrue(addressCell.state == mailingObject.state, "state field should have been updated to reflect the model")
      1|   93|    XCTAssertTrue(addressCell.zipCode == mailingObject.zipCode, "zipCode field should have been updated to reflect the model")
      1|   94|    XCTAssertTrue(addressCell.country_ == mailingObject.country_, "country field should have been updated to reflect the model")
      1|   95|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/AddressCollectionCellTests.swift:
       |    1|//
       |    2|//  AddressCollectionCellTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 11/7/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|class AddressCollectionCellTests: FBSnapshotTestCase {
       |   13|
      2|   14|    override func setUp() {
      2|   15|        super.setUp()
      2|   16|        self.recordMode = false
      2|   17|    }
       |   18|    
      1|   19|    func testItRendersCorrectlyInDefaultMode() {
      1|   20|        
      1|   21|        let style = AddressCollectionCellStyle.Default
      1|   22|        let height = AddressCollectionCell.heightForCellStyle(style)
      1|   23|        let cell = AddressCollectionCell(frame: CGRect(x: 0, y: 0, width: 320, height: height))
      1|   24|     
      1|   25|        let container = containerView(cell, height: height)
      1|   26|        FBSnapShotVerifyLayer(container.layer, identifier: nil)
      1|   27|    }
       |   28|    
      1|   29|    func testItRendersCorrectlyInGridMode() {
      1|   30|        
      1|   31|        let style = AddressCollectionCellStyle.Grid
      1|   32|        let height = AddressCollectionCell.heightForCellStyle(style)
      1|   33|        let cell = AddressCollectionCell(frame: CGRect(x: 0, y: 0, width: 400, height: height))
      1|   34|        cell.style = style
      1|   35|        
      1|   36|        let container = containerView(cell, height: height)
      1|   37|        FBSnapShotVerifyLayer(container.layer, identifier: nil)
      1|   38|    }
       |   39|    
       |   40|    //MARK: Helper Funcs
       |   41|    
      2|   42|    func containerView(cell: AddressCollectionCell, height: Int) -> UIView {
      2|   43|        
      2|   44|        let container = UIView(frame: CGRect(x: 0, y: 0, width: 400, height: height));
      2|   45|        container.backgroundColor = UIColor.whiteColor()
      2|   46|        container.addSubview(cell)
      2|   47|        
      2|   48|        cell.frame = container.bounds
      2|   49|        
      2|   50|        cell.setNeedsDisplay()
      2|   51|        cell.setNeedsLayout()
      2|   52|
      2|   53|        return container
      2|   54|    }
       |   55|    
       |   56|    
       |   57|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/ArrowPopoverContainerViewTests.swift:
       |    1|//
       |    2|//  ArrowPopoverContainerViewTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 7/20/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|import PaperlessPost
       |   12|
       |   13|class ArrowPopoverContainerViewTests: FBSnapshotTestCase {
       |   14|
      1|   15|    override func setUp() {
      1|   16|        super.setUp()
      1|   17|        self.recordMode = false
      1|   18|    }
       |   19|    
      1|   20|    override func tearDown() {
      1|   21|        super.tearDown()
      1|   22|    }
       |   23|
      1|   24|    func testExample() {
      1|   25|        let content = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 300))
      1|   26|        content.backgroundColor = UIColor.blueColor()
      1|   27|        let arrowPopover = ArrowPopoverContainerView(contentView: content)
      1|   28|        arrowPopover.arrowOriginX = 100
      1|   29|        arrowPopover.frame = CGRect(x: 0, y: 0, width: 320, height: 400)
      1|   30|        arrowPopover.backgroundColor = UIColor.redColor()
      1|   31|        FBSnapShotVerifyLayer(arrowPopover.layer)
      1|   32|    }
       |   33|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/CardPackageAccessibilityTests.swift:
       |    1|//
       |    2|//  CardPackageAccessibilityTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Wyatt McBain on 9/2/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|import PaperlessPost
       |   12|
       |   13|class CardPackageAccessibilityTests: XCTestCase {
       |   14|
       |   15|    var package: PPCardPackage?
       |   16|    var featureCenter: PPFeatureCenter?
       |   17|    
      3|   18|    override func setUp() {
      3|   19|        super.setUp()
      3|   20|        PPFeatureBlockCreatePartnerContent.isEnabledAtBuildTime = true
      3|   21|        package = PPCardPackage()
      3|   22|        featureCenter = PPFeatureCenter.sharedCenter()
      3|   23|    }
       |   24|    
      3|   25|    override func tearDown() {
      3|   26|        package = .None
      3|   27|        super.tearDown()
      3|   28|    }
       |   29|
      1|   30|    func testContentIsNotBlockedWhenFeatureIsDisabled() {
      1|   31|        if let package = package, featureCenter = featureCenter {
      1|   32|            package.isGeoblocked = 0
      1|   33|            featureCenter.disableFeature(PPFeatureBlockCreatePartnerContent)
      1|   34|            
      1|   35|            XCTAssertFalse(package.isContentBlocked, "When feature is disabled, content should be accessible.")
      0|   36|        } else {
      0|   37|            XCTFail("PPCardPackage or PPFeatureCenter was not created properly.")
      0|   38|        }
      1|   39|    }
       |   40|    
      1|   41|    func testContentIsNotBlockedWhenAttributesAreNil() {
      1|   42|        if let package = package, featureCenter = featureCenter {
      1|   43|            package.isGeoblocked = .None
      1|   44|            featureCenter.enableFeature(PPFeatureBlockCreatePartnerContent)
      1|   45|            
      1|   46|            XCTAssertFalse(package.isContentBlocked, "When properties are nil, content should not be blocked.")
      0|   47|        } else {
      0|   48|            XCTFail("PPCardPackage or PPFeatureCenter was not created properly.")
      0|   49|        }
      1|   50|    }
       |   51|    
      1|   52|    func testContentIsBlockedWhenPackageIsGeoblocked() {
      1|   53|        if let package = package, featureCenter = featureCenter {
      1|   54|            package.isGeoblocked = 1
      1|   55|            featureCenter.enableFeature(PPFeatureBlockCreatePartnerContent)
      1|   56|            
      1|   57|            XCTAssertTrue(package.isContentBlocked, "Content should be blocked when package is geoblocked.")
      0|   58|        } else {
      0|   59|            XCTFail("PPCardPackage or PPFeatureCenter was not created properly.")
      0|   60|        }
      1|   61|    }
       |   62|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/CreateDesignCardViewControllerAuthenticationTests.swift:
       |    1|//
       |    2|//  CreateDesignCardViewControllerAuthenticationTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 9/28/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|
       |   11|class CreateDesignCardViewControllerAuthenticationTests: XCTestCase {
       |   12|
      0|   13|    let dummyClosure : ClosureType = { arg in }
  ------------------
  | _TFC18PaperlessPostTests49CreateDesignCardViewControllerAuthenticationTestsCfMS0_FT10invocationGSqCSo12NSInvocation__S0_ :
  |      0|   13|    let dummyClosure : ClosureType = { arg in }
  ------------------
  | _TFC18PaperlessPostTests49CreateDesignCardViewControllerAuthenticationTestsCfMS0_FT8selectorV10ObjectiveC8Selector_S0_ :
  |      0|   13|    let dummyClosure : ClosureType = { arg in }
  ------------------
  | _TFC18PaperlessPostTests49CreateDesignCardViewControllerAuthenticationTestsCfMS0_FT_S0_ :
  |      0|   13|    let dummyClosure : ClosureType = { arg in }
  ------------------
       |   14|
      1|   15|    func testAuthModalFromCreateDesignCardViewController() {
      1|   16|
      1|   17|        // Corresponds to Create_DesignCardViewController -presentAuthenticationModalWithCompletionBlock:
      1|   18|
      1|   19|        let vc = Create_DesignCardViewController()
      1|   20|        let navDouble: PPNavigatorDouble! = PPNavigatorDouble.currentNavigator()
      1|   21|        navDouble.presentAuthenticationModalFromViewController(vc, authenticationArea:.Create, withCompletionBlock: dummyClosure)
      1|   22|
      1|   23|        if let event = navDouble.capturedEvent {
      1|   24|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      1|   25|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Create])
      0|   26|        } else {
      0|   27|            XCTFail("PPNavigator should had captured an event.")
      0|   28|        }
      1|   29|    }
       |   30|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/CreateFlowStateMachineTests.swift:
       |    1|//
       |    2|//  CreateFlowStateMachineTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Jabari Bell on 7/2/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import Foundation
       |   10|@testable import PaperlessPost
       |   11|import XCTest
       |   12|
       |   13|class CreateFlowStateMachineTests: XCTestCase, StateMachineDelegate {
       |   14|    
       |   15|    //MARK: StateMachineDelegate
       |   16|    typealias StateType = CreateFlowState
       |   17|    
     23|   18|    func didTransitionFrom(from: StateType, to: StateType) {}
       |   19|    
       |   20|    //Helper
     23|   21|    class func transitionTestBetweenValidStatesForMachine(machine: StateMachine<CreateFlowStateMachineTests>, to: StateType) {
     23|   22|        machine.state = to
     23|   23|        XCTAssert(machine.state == to, "State machine should have updated to the \(to.description).")
     23|   24|    }
       |   25|    
       |   26|    
       |   27|    //MARK: Tests
      1|   28|    func testThatStateMachineUpdatesValidStatesAsExpectedForCreateFlow() {
      1|   29|        
      1|   30|        //first flow
      1|   31|        var machine = StateMachine(initialState: .MoreDropdown, delegate: self)
      1|   32|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .BounceTextIcon)
      1|   33|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .BounceEnvelopeIcon)
      1|   34|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .HintEnvelope)
      1|   35|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .EditEnvelope)
      1|   36|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .HintDone)
      1|   37|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .TutorialCompleted)
      1|   38|        
      1|   39|        //second flow
      1|   40|        machine = StateMachine(initialState: .MoreDropdown, delegate: self)
      1|   41|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .BounceTextIcon)
      1|   42|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .HintText)
      1|   43|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .EditText)
      1|   44|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .BounceArrowRight)
      1|   45|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .BounceEnvelopeIcon)
      1|   46|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .HintEnvelope)
      1|   47|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .EditEnvelope)
      1|   48|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .HintDone)
      1|   49|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .TutorialCompleted)
      1|   50|        
      1|   51|        //third flow
      1|   52|        machine = StateMachine(initialState: .MoreDropdown, delegate: self)
      1|   53|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .BounceTextIcon)
      1|   54|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .HintText)
      1|   55|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .EditText)
      1|   56|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .BounceEnvelopeIcon)
      1|   57|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .HintEnvelope)
      1|   58|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .EditEnvelope)
      1|   59|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .HintDone)
      1|   60|        CreateFlowStateMachineTests.transitionTestBetweenValidStatesForMachine(machine, to: .TutorialCompleted)
      1|   61|    }
       |   62|    
      1|   63|    func testThatInvalidStateChangeDoesNotUpdateMachine() {
      1|   64|        
      1|   65|        let initialState = StateType.MoreDropdown
      1|   66|        let machine = StateMachine(initialState: initialState, delegate: self)
      1|   67|        machine.state = .TutorialCompleted
      1|   68|        XCTAssert(machine.state == initialState, "Updating state machine to invalid state should not update the machine's state.")
      1|   69|    }
       |   70|    
      1|   71|    func testThatResettingCreateFlowStateMachineRemovesAssociatedObjectFromUserDefaults() {
      1|   72|        
      1|   73|        let identifier = CreateFlowStateMachineInfo.Identifier
      1|   74|        let serializer = StateMachineSerializer<CreateFlowStateMachineTests>.createFlowSerializer()
      1|   75|        
      1|   76|        serializer.satisfy(StateType.MoreDropdown)
      1|   77|        
      1|   78|        if let _ = NSUserDefaults.standardUserDefaults().dictionaryForKey(identifier) as? [String: Bool] {
      0|   79|        } else {
      0|   80|            XCTFail("The backing dictionary for the serializer should exist.")
      0|   81|        }
      1|   82|        
      1|   83|        StateMachineSerializerControl.reset(identifier)
      1|   84|        
      0|   85|        if let _ = NSUserDefaults.standardUserDefaults().dictionaryForKey(identifier) as? [String: Bool] {
      0|   86|            XCTFail("The backing dictionary for the serializer should no longer  exist since it was reset.")
      0|   87|        }
      1|   88|    }
       |   89|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/CreateMoreMenuControllerTests.swift:
       |    1|//
       |    2|//  CreateMoreMenuControllerTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 6/30/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|import PaperlessPost
       |   12|
       |   13|class CreateMoreMenuControllerTests: XCTestCase {
       |   14|
      3|   15|    override func setUp() {
      3|   16|        super.setUp()
      3|   17|        // Put setup code here. This method is called before the invocation of each test method in the class.
      3|   18|    }
       |   19|
      1|   20|    func testItsMoreMenuDelegateIsProperlySet() {
      1|   21|        
      1|   22|        let moreMenu = MoreMenuView()
      1|   23|        let controller = CreateMoreMenuController(moreMenu: moreMenu, hostViewController: nil, eventMode: PPEventMode.Print)
      1|   24|        
      1|   25|        XCTAssertTrue(moreMenu.moreMenuDelegate === controller, "Upon setting the controller's more menu, the moreMenuDelegate should be set")
      1|   26|    }
       |   27|    
      1|   28|    func testSettingTheEventModeUpdatesTheMoreMenu() {
      1|   29|        
      1|   30|        let moreMenu = MoreMenuView()
      1|   31|        let controller = CreateMoreMenuController(moreMenu: moreMenu, hostViewController: nil, eventMode: PPEventMode.Print)
      1|   32|     
      1|   33|        controller.eventMode = PPEventMode.Print
      1|   34|        
      1|   35|        XCTAssertTrue(moreMenu.showEventSelection == false, "After setting the event mode to print, the controll should update the more menu to hide event selection")
      1|   36|        
      1|   37|        controller.eventMode = PPEventMode.Online
      1|   38|        XCTAssertTrue(moreMenu.showEventSelection == true, "After setting the event mode to online, the controll should update the more menu to show event selection")
      1|   39|    }
       |   40|    
      1|   41|    func testPricingUpdatesCorrectly() {
      1|   42|        
      1|   43|        let moreMenu = MoreMenuView()
      1|   44|        let controller = CreateMoreMenuController(moreMenu: moreMenu, hostViewController: nil, eventMode: PPEventMode.Print)
      1|   45|        
      1|   46|        let mockItem1 = MockLineItem()
      1|   47|        mockItem1.price = 1.25
      1|   48|        mockItem1.type = .Envelope
      1|   49|        
      1|   50|        let mockItem2 = MockLineItem()
      1|   51|        mockItem2.price = 2.50
      1|   52|        mockItem2.type = .EnvelopeLiner
      1|   53|        
      1|   54|        controller.lineItems = [mockItem1, mockItem2]
      1|   55|        
      1|   56|        XCTAssertTrue(moreMenu.costPerRecipient == "$3.75", "After adding line items to the controller, the price on the more meny should update to reflect the change")
      1|   57|    }
       |   58|}
       |   59|
       |   60|//CreateCardFeatureGroup Tests
       |   61|class CreateCardFeatureGroupTests: XCTestCase {
       |   62|    
      1|   63|    func testGroupsCalculateCoinsCorrectly() {
      1|   64|        
      1|   65|        let group = CreateCardFeatureGroup(group: .Envelope)
      1|   66|        
      1|   67|        let feature3 = MockLineItem()
      1|   68|        feature3.price = 3
      1|   69|        
      1|   70|        let feature2 = MockLineItem()
      1|   71|        feature2.price = 2
      1|   72|        
      1|   73|        let feature1 = MockLineItem()
      1|   74|        feature1.price = 1
      1|   75|        
      1|   76|        group.appendFeature(feature3)
      1|   77|        XCTAssertTrue(group.price == 3, "After adding a feature that costs 3 coins, coins should be 3")
      1|   78|        
      1|   79|        group.appendFeature(feature2)
      1|   80|        XCTAssertTrue(group.price == 5, "After adding a feature that costs 2 coins, coins should now be 5")
      1|   81|        
      1|   82|        group.appendFeature(feature1)
      1|   83|        XCTAssertTrue(group.price == 6, "After adding a feature that costs 1 coin, coins should now be 6")
      1|   84|    }
       |   85|    
      1|   86|    func testPriceCalulationAppliesCorrectly() {
      1|   87|        
      1|   88|        let group = CreateCardFeatureGroup(group: .Envelope)
      1|   89|       
      1|   90|        let feature3 = MockLineItem()
      1|   91|        feature3.price = 3
      1|   92|        
      1|   93|        group.appendFeature(feature3)
      1|   94|        
      1|   95|        group.priceDisplayCalculation = { (amount: Float) -> String in
      1|   96|            return "Amount: \(Int(amount))"
      1|   97|        }
      1|   98|        
      1|   99|        XCTAssertTrue(group.subtitle == "Amount: 3", "The price display calculation should be executed when requesting the group's subtitle.")
      1|  100|    }
       |  101|    
      1|  102|    func testItIdentifiesItemsCorrectly() {
      1|  103|        
      1|  104|        let group = CreateCardFeatureGroup(group: .Envelope)
      1|  105|
      1|  106|        let linerFeature = MockLineItem()
      1|  107|        linerFeature.type = .EnvelopeLiner
      1|  108|        group.appendFeature(linerFeature)
      1|  109|        
      1|  110|        let stampFeature = MockLineItem()
      1|  111|        stampFeature.type = .EnvelopeStamp
      1|  112|        group.appendFeature(stampFeature)
      1|  113|        
      1|  114|        XCTAssertTrue(group.containsItemWithType(.EnvelopeLiner), "Group should return true when asked if it contains an envelope liner")
      1|  115|        
      1|  116|        XCTAssertTrue(group.containsItemWithType(.EnvelopeStamp), "Group should return true when asked if it contains an envelope stamp")
      1|  117|
      1|  118|        XCTAssertFalse(group.containsItemWithType(.Logo), "Group should return false when asked if it contains an logo")
      1|  119|    }
       |  120|}
       |  121|
       |  122|class MockLineItem: NSObject, LineItemPricingDescribable {
       |  123|    
       |  124|    var name: String?
       |  125|    var price: Float = 0
       |  126|    var numberOfItems = 0
       |  127|    var type: PPOnlinePricingItemType = PPOnlinePricingItemType.Envelope
       |  128|    var imageURL: String?
       |  129|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/CreateTutorialTooltipsTests.swift:
       |    1|//
       |    2|//  CreateTutorialTooltipsTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Wyatt McBain on 8/13/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|@testable import PaperlessPost
       |   12|
       |   13|class CreateTutorialTooltipsTests: FBSnapshotTestCase {
       |   14|
       |   15|    var backingView: UIView?
       |   16|    
      3|   17|    override func setUp() {
      3|   18|        super.setUp()
      3|   19|        backingView = UIView(frame: CGRect(x: 0, y: 0, width: 370, height: 640))
      3|   20|        backingView?.backgroundColor = UIColor.blueColor()
      3|   21|        
      3|   22|        self.recordMode = false
      3|   23|    }
       |   24|    
      1|   25|    func testThatItShowsTextCoachmarkCorrectly() {
      1|   26|        if let backingView = backingView {
      1|   27|            let view = CreateTutorialTooltips.editTextTooltip()
      1|   28|            backingView.addSubview(view)
      1|   29|            view.animate()
      1|   30|            FBSnapShotVerifyLayer(backingView.layer, identifier: "Hint text coach mark")
      0|   31|        } else {
      0|   32|            XCTFail("Backing view is nil")
      0|   33|        }
      1|   34|    }
       |   35|    
      1|   36|    func testThatItShowsEnvelopeCoachmarkCorrectly() {
      1|   37|        if let backingView = backingView {
      1|   38|            let view = CreateTutorialTooltips.linerHintTooltip(target: CGPoint(x: backingView.bounds.width / 2, y: 200), eventMode: PPEventMode.Online)
      1|   39|            backingView.addSubview(view)
      1|   40|            view.animate()
      1|   41|            FBSnapShotVerifyLayer(backingView.layer, identifier: "Hint liner coach mark")
      0|   42|        } else {
      0|   43|            XCTFail("Backing view is nil")
      0|   44|        }
      1|   45|    }
       |   46|    
      1|   47|    func testThatItShowsDoneCoachmarkCorrectly() {
      1|   48|        if let backingView = backingView {
      1|   49|            let view = CreateTutorialTooltips.doneHintTooltip(delay: false)
      1|   50|            backingView.addSubview(view)
      1|   51|            view.animate()
      1|   52|            FBSnapShotVerifyLayer(backingView.layer, identifier: "Hint done coach mark")
      0|   53|        } else {
      0|   54|            XCTFail("Backing view is nil")
      0|   55|        }
      1|   56|    }
       |   57|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/FreeTestPreviewCellTests.swift:
       |    1|//
       |    2|//  FreeTestPreviewCellTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 10/6/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|@testable import PaperlessPost
       |   11|
       |   12|class FreeTestPreviewCellTests: FBSnapshotTestCase {
       |   13|    
      6|   14|    override func setUp() {
      6|   15|        super.setUp()
      6|   16|        self.recordMode = false
      6|   17|    }
       |   18|    
      1|   19|    func testConfigurationOnlyRightButton() {
      1|   20|        let cell = FreeTestPreviewCell.newWithDefaults()
      1|   21|        cell.rightButtonText = "Send a free test"
      1|   22|        FBSnapShotVerifyLayer(cell.layer)
      1|   23|    }
       |   24|    
      1|   25|    func testConfigurationOnlyLeftButton() {
      1|   26|        let cell = FreeTestPreviewCell.newWithDefaults()
      1|   27|        cell.leftButtonText = "Send a free test"
      1|   28|        FBSnapShotVerifyLayer(cell.layer)
      1|   29|    }
       |   30|    
      1|   31|    func testConfigurationLeftAndRightButton() {
      1|   32|        let cell = FreeTestPreviewCell.newWithDefaults()
      1|   33|        cell.leftButtonText = "Send a free test"
      1|   34|        cell.rightButtonText = "Preview"
      1|   35|        FBSnapShotVerifyLayer(cell.layer)
      1|   36|    }
       |   37|    
      1|   38|    func testConfigurationLeftRightMiddle() {
      1|   39|        let cell = FreeTestPreviewCell.newWithDefaults()
      1|   40|        cell.leftButtonText = "Send a free test"
      1|   41|        cell.rightButtonText = "Preview"
      1|   42|        cell.joiningString = "|"
      1|   43|        FBSnapShotVerifyLayer(cell.layer)
      1|   44|    }
       |   45|    
      1|   46|    func testItReturnsTheCorrectStrings() {
      1|   47|        
      1|   48|        let left = "Send a free test", right = "Preview", joining = "-_-"
      1|   49|        
      1|   50|        let cell = FreeTestPreviewCell.newWithDefaults()
      1|   51|        cell.leftButtonText = left
      1|   52|        cell.rightButtonText = right
      1|   53|        cell.joiningString = joining
      1|   54|        
      1|   55|        XCTAssertEqual(left, cell.leftButtonText)
      1|   56|        XCTAssertEqual(joining, cell.joiningString)
      1|   57|        XCTAssertEqual(right, cell.rightButtonText)
      1|   58|    }
       |   59|    
      1|   60|    func testButtonFunctionsWork() {
      1|   61|        
      1|   62|        let cell = FreeTestPreviewCell.newWithDefaults()
      1|   63|
      1|   64|        var leftCalled = false
      1|   65|        cell.onLeftButtonTap = {
      1|   66|            leftCalled = true
      1|   67|        }
      1|   68|        
      1|   69|        //Only way is to force call the (public) selector for this
      1|   70|        cell.leftButtonTapped()
      1|   71|        XCTAssertTrue(leftCalled, "Left button tap callback was never executed")
      1|   72|        
      1|   73|        
      1|   74|        var rightCalled = false
      1|   75|        cell.onRightButtonTap = {
      1|   76|            rightCalled = true
      1|   77|        }
      1|   78|        //Only way is to force call the (public) selector for this
      1|   79|        cell.rightButtonTapped()
      1|   80|        XCTAssertTrue(rightCalled, "Right button tap callback was never executed")
      1|   81|    }
       |   82|    
       |   83|    
       |   84|}
       |   85|
       |   86|
       |   87|private extension FreeTestPreviewCell {
      6|   88|    class func newWithDefaults() -> FreeTestPreviewCell {
      6|   89|        let cell = FreeTestPreviewCell()
      6|   90|        cell.backgroundColor = UIColor.whiteColor()
      6|   91|        return cell
      6|   92|    }
       |   93|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/GuestBookAddNewCommentViewTests.swift:
       |    1|//
       |    2|//  GuestBookAddNewCommentViewTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 1/12/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import Foundation
       |   10|import PaperlessPost
       |   11|import XCTest
       |   12|
       |   13|@available(iOS 8.0, *)
       |   14|class GuestBookAddNewCommentViewTests: FBSnapshotTestCase {
       |   15|
      2|   16|    override func setUp() {
      2|   17|        super.setUp()
      2|   18|        self.recordMode = false
      2|   19|    }
       |   20|
      1|   21|    func testItRendersAndResizesCorrectlyNoImage() {
      1|   22|
      1|   23|        let view = AddCommentView(frame: CGRect(x: 0, y: 0, width: 300, height: 400))
      1|   24|        view.rightButton.setTitle("Sign Book", forState: .Normal)
      1|   25|        view.leftButton.setTitle("Add Photo", forState: .Normal)
      1|   26|        view.leftButton.setTitleColor(UIColor.blackColor(), forState: .Normal)
      1|   27|        
      1|   28|        view.textFieldPlaceHolder = "Enter a comment..."
      1|   29|        view.setNeedsLayout()
      1|   30|        view.layoutIfNeeded()
      1|   31|        view.sizeToFit()
      1|   32|        //Must set BG color for tests to evaluate correctly, alpha is a problem w snapshot tests
      1|   33|        view.backgroundColor = UIColor.whiteColor()
      1|   34|
      1|   35|        FBSnapShotVerifyLayer(view.layer)
      1|   36|    }
       |   37|    
      1|   38|    func testItRendersAndResizesCorrectlyWithAnImage() {
      1|   39|        
      1|   40|        let view = AddCommentView(frame: CGRect(x: 0, y: 0, width: 300, height: 400))
      1|   41|        view.rightButton.setTitle("Sign Book", forState: .Normal)
      1|   42|        view.leftButton.setTitle("Add Photo", forState: .Normal)
      1|   43|        view.leftButton.setTitleColor(UIColor.blackColor(), forState: .Normal)
      1|   44|        
      1|   45|        view.textFieldPlaceHolder = "Enter a comment..."
      1|   46|        view.image = PPFixtureFactory.Images.Believe
      1|   47|        
      1|   48|        view.setNeedsLayout()
      1|   49|        view.layoutIfNeeded()
      1|   50|        view.sizeToFit()
      1|   51|        //Must set BG color for tests to evaluate correctly, alpha is a problem w snapshot tests
      1|   52|        view.backgroundColor = UIColor.whiteColor()
      1|   53|
      1|   54|        FBSnapShotVerifyLayer(view.layer)
      1|   55|    }
       |   56|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/GuestBookPostCellTests.swift:
       |    1|//
       |    2|//  GuestBookPostCellTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 1/7/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|import PaperlessPost
       |   12|
       |   13|@available(iOS 8.0, *)
       |   14|class GuestBookPostCellTests: FBSnapshotTestCase {
       |   15|    
     16|   16|    override func setUp() {
     16|   17|        super.setUp()
     16|   18|        self.recordMode = false
     16|   19|    }
       |   20|    
     16|   21|    override func tearDown() {
     16|   22|        // Put teardown code here. This method is called after the invocation of each test method in the class.
     16|   23|        super.tearDown()
     16|   24|    }
       |   25|    
      1|   26|    func testItRendersCorrectlyWhenNestedCommentsAreDisabledAndNoNestedCommentsExist() {
      1|   27|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|   28|        view.showsEnterCommentView = false
      1|   29|        view.backgroundColor = UIColor.whiteColor()
      1|   30|        view.timeText = "5 days ago"
      1|   31|        view.authorName = "Sal Pizzaiolo"
      1|   32|        view.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|   33|        view.likeCount = 12
      1|   34|        
      1|   35|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|   36|        view.frame.size = size
      1|   37|        
      1|   38|        FBSnapShotVerifyLayer(view.layer)
      1|   39|    }
       |   40|    
      1|   41|    func testItRendersCorrectlyWhenNestedCommentsAreDisabledAndNoNestedCommentsExistWithEmojiInTitle() {
      1|   42|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|   43|        view.showsEnterCommentView = false
      1|   44|        view.backgroundColor = UIColor.whiteColor()
      1|   45|        view.timeText = "5 days ago"
      1|   46|        view.authorName = "Sal Pizzaiolo"
      1|   47|        view.comment = " This is going to be the best party ever! Can't wait for ice cream"
      1|   48|        view.likeCount = 12
      1|   49|        
      1|   50|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|   51|        view.frame.size = size
      1|   52|        
      1|   53|        FBSnapShotVerifyLayer(view.layer)
      1|   54|    }
       |   55|    
      1|   56|    func testItRendersCorrectlyWithLikesButNoComments() {
      1|   57|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|   58|        view.showsEnterCommentView = true
      1|   59|        view.backgroundColor = UIColor.whiteColor()
      1|   60|        view.timeText = "5 days ago"
      1|   61|        view.authorName = "Sal Pizzaiolo"
      1|   62|        view.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|   63|        view.likeCount = 12
      1|   64|        
      1|   65|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|   66|        view.frame.size = size
      1|   67|        
      1|   68|        FBSnapShotVerifyLayer(view.layer)
      1|   69|    }
       |   70|    
      1|   71|    func testItRenderCorrectlyWhenNestedCommentsAreDisabledAndNoNestedCommentsOrLikesExist() {
      1|   72|        
      1|   73|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|   74|        view.showsEnterCommentView = false
      1|   75|        view.backgroundColor = UIColor.whiteColor()
      1|   76|        view.timeText = "5 days ago"
      1|   77|        view.authorName = "Sal Pizzaiolo"
      1|   78|        view.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|   79|        view.likeCount = 0
      1|   80|        
      1|   81|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|   82|        view.frame.size = size
      1|   83|        
      1|   84|        FBSnapShotVerifyLayer(view.layer)
      1|   85|    }
       |   86|    
      1|   87|    func testItRenderAndResizesCorrectNoImage() {
      1|   88|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|   89|        view.backgroundColor = UIColor.whiteColor()
      1|   90|        view.timeText = "5 days ago"
      1|   91|        view.authorName = "Sal Pizzaiolo"
      1|   92|        view.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|   93|        view.likeCount = 12
      1|   94|        view.comments = GuestBookPostTestHelper.nestedComments
      1|   95|        
      1|   96|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|   97|        view.frame.size = size
      1|   98|        
      1|   99|        FBSnapShotVerifyLayer(view.layer)
      1|  100|    }
       |  101|    
      1|  102|    func testItRenderAndResizesCorrectNoImageNoLikesWithNestedComments() {
      1|  103|        
      1|  104|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|  105|        view.backgroundColor = UIColor.whiteColor()
      1|  106|        view.timeText = "5 days ago"
      1|  107|        view.authorName = "Sal Pizzaiolo"
      1|  108|        view.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|  109|        view.likeCount = 0
      1|  110|        view.comments = GuestBookPostTestHelper.nestedComments
      1|  111|        
      1|  112|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|  113|        view.frame.size = size
      1|  114|        
      1|  115|        FBSnapShotVerifyLayer(view.layer)
      1|  116|    }
       |  117|    
      1|  118|    func testItRenderAndResizesCorrectNestedCommentSetToShowOnly3() {
      1|  119|        
      1|  120|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|  121|        view.backgroundColor = UIColor.whiteColor()
      1|  122|        view.timeText = "5 days ago"
      1|  123|        view.authorName = "Sal Pizzaiolo"
      1|  124|        view.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|  125|        view.comments = GuestBookPostTestHelper.nestedComments
      1|  126|        view.maximumNumberOfCommentsToDisplay = 3
      1|  127|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|  128|        view.frame.size = size
      1|  129|        
      1|  130|        FBSnapShotVerifyLayer(view.layer)
      1|  131|    }
       |  132|    
      1|  133|    func testItRenderAndResizesCorrectNoSpecialOptions() {
      1|  134|        
      1|  135|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|  136|        view.backgroundColor = UIColor.whiteColor()
      1|  137|        view.timeText = "5 days ago"
      1|  138|        view.authorName = "Sal Pizzaiolo"
      1|  139|        view.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|  140|        view.likeCount = 0
      1|  141|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|  142|        view.frame.size = size
      1|  143|        
      1|  144|        FBSnapShotVerifyLayer(view.layer)
      1|  145|//        self.recordMode = false
      1|  146|    }
       |  147|    
      1|  148|    func testItRendersProperlyWithOneLike() {
      1|  149|        
      1|  150|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|  151|        view.backgroundColor = UIColor.whiteColor()
      1|  152|        view.timeText = "5 days ago"
      1|  153|        view.authorName = "Sal Pizzaiolo"
      1|  154|        view.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|  155|        view.likeCount = 1
      1|  156|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|  157|        view.frame.size = size
      1|  158|        
      1|  159|        FBSnapShotVerifyLayer(view.layer)
      1|  160|    }
       |  161|    
      1|  162|    func testItRenderAndResizesCorrectNoImageLiked() {
      1|  163|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|  164|        view.backgroundColor = UIColor.whiteColor()
      1|  165|        view.timeText = "5 days ago"
      1|  166|        view.authorName = "Sal Pizzaiolo"
      1|  167|        view.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|  168|        view.likeCount = 12
      1|  169|        view.comments = GuestBookPostTestHelper.nestedComments
      1|  170|        view.isLiked = true
      1|  171|        
      1|  172|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|  173|        view.frame.size = size
      1|  174|        
      1|  175|        FBSnapShotVerifyLayer(view.layer)
      1|  176|    }
       |  177|    
      1|  178|    func testItRenderAndResizesCorrectWithHorizontalImage() {
      1|  179|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|  180|        view.backgroundColor = UIColor.whiteColor()
      1|  181|        view.timeText = "5 days ago"
      1|  182|        view.authorName = "Sal Pizzaiolo"
      1|  183|        view.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|  184|        view.likeCount = 12
      1|  185|        view.comments = GuestBookPostTestHelper.nestedComments
      1|  186|        view.isLiked = true
      1|  187|        view.image = PPFixtureFactory.Images.Believe
      1|  188|        
      1|  189|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|  190|        view.frame.size = size
      1|  191|        
      1|  192|        FBSnapShotVerifyLayer(view.layer)
      1|  193|    }
       |  194|    
      1|  195|    func testItRenderAndResizesCorrectWithVerticalImage() {
      1|  196|        let view = GuestBookPostView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))
      1|  197|        view.backgroundColor = UIColor.whiteColor()
      1|  198|        view.timeText = "5 days ago"
      1|  199|        view.authorName = "Sal Pizzaiolo"
      1|  200|        view.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|  201|        view.likeCount = 12
      1|  202|        view.comments = GuestBookPostTestHelper.nestedComments
      1|  203|        view.isLiked = true
      1|  204|        view.image = PPFixtureFactory.Images.VerticalSnapshotCard.front
      1|  205|        
      1|  206|        let size = view.sizeThatFits(CGSize(width: 300, height: NSIntegerMax))
      1|  207|        view.frame.size = size
      1|  208|        
      1|  209|        FBSnapShotVerifyLayer(view.layer)
      1|  210|    }
       |  211|    
      1|  212|    func testTheCollectionViewCellsSizesAndRenderCorrectlyNestedComments() {
      1|  213|        let aCell = GuestBookPostCollectionViewCell(frame: CGRectZero)
      1|  214|        
      1|  215|        aCell.postView.backgroundColor = UIColor.whiteColor()
      1|  216|        aCell.postView.timeText = "5 days ago"
      1|  217|        aCell.postView.authorName = "Sal Pizzaiolo"
      1|  218|        aCell.postView.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|  219|        aCell.postView.likeCount = 12
      1|  220|        aCell.postView.comments = GuestBookPostTestHelper.nestedComments
      1|  221|        aCell.postView.isLiked = true
      1|  222|        aCell.postView.image = PPFixtureFactory.Images.VerticalSnapshotCard.front
      1|  223|        
      1|  224|        //Get the esimated size
      1|  225|        
      1|  226|        let sizeEstimated = GuestBookPostCollectionViewCell.estimatedSizeThatFits(CGSize(width: 220, height: NSIntegerMax), author: aCell.postView.authorName, comment: aCell.postView.comment, timeText:aCell.postView.timeText, image: aCell.postView.image, comments: aCell.postView.comments, maxNumberOfComments: aCell.postView.maximumNumberOfCommentsToDisplay, likeCount: aCell.postView.likeCount, showsEnterCommentView: aCell.postView.showsEnterCommentView)
      1|  227|        
      1|  228|        aCell.frame.size = sizeEstimated
      1|  229|        
      1|  230|        FBSnapShotVerifyLayer(aCell.layer)
      1|  231|    }
       |  232|    
      1|  233|    func testTheCollectionViewCellsSizesAndRenderCorrectlyNoNestedComments() {
      1|  234|        let aCell = GuestBookPostCollectionViewCell(frame: CGRectZero)
      1|  235|        
      1|  236|        aCell.postView.backgroundColor = UIColor.whiteColor()
      1|  237|        aCell.postView.timeText = "5 days ago"
      1|  238|        aCell.postView.authorName = "Sal Pizzaiolo"
      1|  239|        aCell.postView.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|  240|        aCell.postView.likeCount = 12
      1|  241|        aCell.postView.isLiked = true
      1|  242|        aCell.postView.image = PPFixtureFactory.Images.VerticalSnapshotCard.front
      1|  243|        aCell.postView.showsEnterCommentView = false
      1|  244|        //Get the esimated size
      1|  245|        
      1|  246|        let sizeEstimated = GuestBookPostCollectionViewCell.estimatedSizeThatFits(CGSize(width: 220, height: NSIntegerMax), author: aCell.postView.authorName, comment: aCell.postView.comment, timeText:aCell.postView.timeText, image: aCell.postView.image, comments: aCell.postView.comments, maxNumberOfComments: aCell.postView.maximumNumberOfCommentsToDisplay, likeCount: aCell.postView.likeCount, showsEnterCommentView: aCell.postView.showsEnterCommentView)
      1|  247|        
      1|  248|        aCell.frame.size = sizeEstimated
      1|  249|        
      1|  250|        FBSnapShotVerifyLayer(aCell.layer)
      1|  251|    }
       |  252|    
      1|  253|    func testTheTableViewCellsSizesAndRenderCorrectlyNoNestedComments() {
      1|  254|        let aCell = GuestBookPostCell(style: UITableViewCellStyle.Default, reuseIdentifier: "reuse")
      1|  255|        
      1|  256|        aCell.postView.backgroundColor = UIColor.whiteColor()
      1|  257|        aCell.postView.timeText = "5 days ago"
      1|  258|        aCell.postView.authorName = "Sal Pizzaiolo"
      1|  259|        aCell.postView.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|  260|        aCell.postView.likeCount = 12
      1|  261|        aCell.postView.isLiked = true
      1|  262|        aCell.postView.image = PPFixtureFactory.Images.VerticalSnapshotCard.front
      1|  263|        aCell.postView.showsEnterCommentView = false
      1|  264|        //Get the esimated size
      1|  265|        
      1|  266|        let sizeEstimated = GuestBookPostCell.estimatedSizeThatFits(CGSize(width: 220, height: NSIntegerMax), author: aCell.postView.authorName, comment: aCell.postView.comment, timeText:aCell.postView.timeText, image: aCell.postView.image, comments: aCell.postView.comments, maxNumberOfComments: aCell.postView.maximumNumberOfCommentsToDisplay, likeCount: aCell.postView.likeCount, showsEnterCommentView: aCell.postView.showsEnterCommentView)
      1|  267|        
      1|  268|        aCell.frame.size = sizeEstimated
      1|  269|        
      1|  270|        FBSnapShotVerifyLayer(aCell.layer)
      1|  271|    }
       |  272|    
      1|  273|    func testTheTableViewCellsSizesAndRenderCorrectlyWithNestedComments() {
      1|  274|        let aCell = GuestBookPostCell(style: UITableViewCellStyle.Default, reuseIdentifier: "reuse")
      1|  275|        
      1|  276|        aCell.postView.backgroundColor = UIColor.whiteColor()
      1|  277|        aCell.postView.timeText = "5 days ago"
      1|  278|        aCell.postView.authorName = "Sal Pizzaiolo"
      1|  279|        aCell.postView.comment = "This is going to be the best party ever! Can't wait for ice cream"
      1|  280|        aCell.postView.likeCount = 12
      1|  281|        aCell.postView.isLiked = true
      1|  282|        aCell.postView.image = PPFixtureFactory.Images.VerticalSnapshotCard.front
      1|  283|        aCell.postView.showsEnterCommentView = true
      1|  284|        aCell.postView.comments = GuestBookPostTestHelper.nestedComments
      1|  285|
      1|  286|        //Get the esimated size
      1|  287|        
      1|  288|        let sizeEstimated = GuestBookPostCell.estimatedSizeThatFits(CGSize(width: 220, height: NSIntegerMax), author: aCell.postView.authorName, comment: aCell.postView.comment, timeText:aCell.postView.timeText, image: aCell.postView.image, comments: aCell.postView.comments, maxNumberOfComments: aCell.postView.maximumNumberOfCommentsToDisplay, likeCount: aCell.postView.likeCount, showsEnterCommentView: aCell.postView.showsEnterCommentView)
      1|  289|        
      1|  290|        aCell.frame.size = sizeEstimated
      1|  291|        
      1|  292|        FBSnapShotVerifyLayer(aCell.layer)
      1|  293|    }
       |  294|}
       |  295|
       |  296|struct GuestBookPostTestHelper {
       |  297|    
       |  298|    static var nestedComments = [ MockNestedComment(message: "hello this is my comment", author: "sal"),
       |  299|        MockNestedComment(message: "TURELY", author: "Jabari"),
       |  300|        MockNestedComment(message: "what is going on here", author: "Emma"),
       |  301|        MockNestedComment(message: "can't wait to test this", author: "stephanie"),
       |  302|        MockNestedComment(message: "sup", author: "corey")]
       |  303|    
       |  304|}
       |  305|
       |  306|internal class MockNestedComment : GuestBookPost {
       |  307|    
       |  308|    @objc var message: String?
       |  309|    @objc var author: String?
       |  310|    @objc var createdAt: NSDate?
       |  311|    
      5|  312|    init (message: String?, author: String?) {
      5|  313|        self.message = message
      5|  314|        self.author = author
      5|  315|    }
       |  316|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/LogInRegisterMixpanelEventTests.swift:
       |    1|//
       |    2|//  LogInRegisterMixpanelEventTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 9/29/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|
       |   11|class LogInRegisterMixpanelEventTests: XCTestCase {
       |   12|
      1|   13|    func testLogInEventIsCorrect() {
      1|   14|
      1|   15|        let event = PPAnalyticsAuthenticationEvent()
      1|   16|
      1|   17|        XCTAssertEqual(event.accountActivityValue(), "Log in")
      1|   18|        XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Unknown], "Default value for area should be unknown")
      1|   19|        XCTAssertNil(event.authenticationStepValue())
      1|   20|    }
       |   21|
      1|   22|    func testSignUpEventIsCorrect() {
      1|   23|
      1|   24|        let event = PPAnalyticsRegistrationEvent()
      1|   25|
      1|   26|        XCTAssertEqual(event.accountActivityValue(), "Register")
      1|   27|        XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Unknown], "Default value for area should be unknown")
      1|   28|        XCTAssertNil(event.authenticationStepValue())
      1|   29|    }
       |   30|
      1|   31|    func testLogInEventWithSpecificAreaIsCorrect() {
      1|   32|
      7|   33|        for area in AuthArea.allValues() {
      7|   34|            let event = PPAnalyticsAuthenticationEvent(authenticationArea: area)
      7|   35|            if let authenticationArea = event.authenticationAreaValue() {
      7|   36|                XCTAssertEqual(authenticationArea, ExpectedValues.Areas[area])
      0|   37|            } else {
      0|   38|                XCTFail("PPAnalyticsAuthenticationEvent should have a key-value pair for key \"auth area\"")
      0|   39|            }
      7|   40|        }
      1|   41|    }
       |   42|
      1|   43|    func testSignUpEventWithSpecificAreaIsCorrect() {
      1|   44|
      7|   45|        for area in AuthArea.allValues() {
      7|   46|            let event = PPAnalyticsRegistrationEvent(authenticationArea: area)
      7|   47|            if let authenticationArea = event.authenticationAreaValue() {
      7|   48|                XCTAssertEqual(authenticationArea, ExpectedValues.Areas[area])
      0|   49|            } else {
      0|   50|                XCTFail("PPAnalyticsRegistrationEvent should have a key-value pair for key \"auth area\"")
      0|   51|            }
      7|   52|        }
      1|   53|    }
       |   54|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/NSObjectSwizzableAddition.swift:
       |    1|//
       |    2|//  SwizzableExtension.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 9/28/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import Foundation
       |   10|
       |   11|// MARK: - Method (typealias on COpaquePointer) Additions
       |   12|
       |   13|extension Method {
       |   14|
       |   15|    /**
       |   16|    Returns a pointer to a (nil|NULL) method.  Used to check if a class contains a given Selector.
       |   17|
       |   18|    - returns: A Method type representing a nil method.
       |   19|    */
     88|   20|    static func null() -> Method {
     88|   21|        return Method.init(nilLiteral: ())
     88|   22|    }
       |   23|}
       |   24|
       |   25|/**
       |   26|An ErrorType for the Swizzle operations on -swizzleMethodSelector:withSelector:forClass: or
       |   27|-swizzleStaticMethodSelector:withSelector:forClass:
       |   28|
       |   29|- OriginalMethodNotFound: The first method is not part of the class.  Check the Selector declaration (spelling?)
       |   30|- SwizzleMethodNotFound:  The second method is not part of the class.  Check the Selector declaration (spelling?)
       |   31|*/
       |   32|enum SwizzleErrorType : ErrorType {
       |   33|    case OriginalMethodNotFound, SwizzleMethodNotFound
       |   34|}
       |   35|
       |   36|// MARK: - NSObject Additions
       |   37|
       |   38|extension NSObject {
       |   39|
       |   40|    /**
       |   41|    Swizzle two instance methods on a given class.
       |   42|
       |   43|    - parameter origSelector: The selector corresponding to the first method, or original method.
       |   44|    - parameter withSelector: The selector corresponding to the second method, or new method.
       |   45|    - parameter forClass:     The class type where we want to perform the method swizzling
       |   46|
       |   47|    - throws: SwizzleErrorType.OriginalMethodNotFound or SwizzleErrorType.OriginalMethodNotFound
       |   48|    */
      0|   49|    class func swizzleMethodSelector(origSelector: Selector, withSelector: Selector, forClass:AnyClass!) throws {
      0|   50|
      0|   51|        var originalMethod: Method?
      0|   52|        var swizzledMethod: Method?
      0|   53|
      0|   54|        originalMethod = class_getInstanceMethod(forClass, origSelector)
      0|   55|        swizzledMethod = class_getInstanceMethod(forClass, withSelector)
      0|   56|
      0|   57|        if originalMethod == Method.null() {
      0|   58|            throw SwizzleErrorType.OriginalMethodNotFound
      0|   59|        }
      0|   60|
      0|   61|        if swizzledMethod == Method.null() {
      0|   62|            throw SwizzleErrorType.SwizzleMethodNotFound
      0|   63|        }
      0|   64|
      0|   65|        method_exchangeImplementations(originalMethod!, swizzledMethod!)
      0|   66|    }
       |   67|
       |   68|    /**
       |   69|    Swizzle two class methods on a given class.
       |   70|
       |   71|    - parameter origSelector: The selector corresponding to the first method, or original method.
       |   72|    - parameter withSelector: The selector corresponding to the second method, or new method.
       |   73|    - parameter forClass:     The class type where we want to perform the class method swizzling
       |   74|
       |   75|    - throws: SwizzleErrorType.OriginalMethodNotFound or SwizzleErrorType.OriginalMethodNotFound
       |   76|    */
     44|   77|    class func swizzleStaticMethodSelector(origSelector: Selector, withSelector: Selector, forClass:AnyClass!) throws {
     44|   78|
     44|   79|        var originalMethod: Method?
     44|   80|        var swizzledMethod: Method?
     44|   81|
     44|   82|        originalMethod = class_getClassMethod(forClass, origSelector)
     44|   83|        swizzledMethod = class_getClassMethod(forClass, withSelector)
     44|   84|
      0|   85|        if originalMethod == Method.null() {
      0|   86|            throw SwizzleErrorType.OriginalMethodNotFound
      0|   87|        }
     44|   88|
      0|   89|        if swizzledMethod == Method.null() {
      0|   90|            throw SwizzleErrorType.SwizzleMethodNotFound
      0|   91|        }
     44|   92|
     44|   93|        method_exchangeImplementations(originalMethod!, swizzledMethod!)
     44|   94|    }
       |   95|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPAnalyticsProviderTests.swift:
       |    1|//
       |    2|//  PPAnalyticsProviderTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 9/29/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|import PaperlessPost
       |   11|
       |   12|class PPAnalyticsProviderTests: XCTestCase {
       |   13|
       |   14|    class CocoaObject : NSObject { }
       |   15|
       |   16|    class EventDummy : NSObject, PPAnalyticsSerializable {
      1|   17|        @objc static func analyticsEventName() -> String {
      1|   18|            return "Foo"
      1|   19|        }
      1|   20|        @objc func dictionaryRepresentation() -> [NSObject : AnyObject]! {
      1|   21|            return ["Foo" : "Bar"]
      1|   22|        }
       |   23|    }
       |   24|
      1|   25|    func testCocoaObjectHasProvider() {
      1|   26|        let object = CocoaObject()
      1|   27|        XCTAssertNotNil(object.analyticsProvider)
      1|   28|    }
       |   29|
      1|   30|    func testCocoaObjectStoresProviderCorrectly() {
      1|   31|
      1|   32|        class AnalyticsProviderSpy : NSObject, PPAnalyticsProviderObjC {
      1|   33|            var lastEvent : PPAnalyticsSerializable?
      1|   34|            @objc func trackEvent(event: PPAnalyticsSerializable) {
      1|   35|                self.lastEvent = event
      1|   36|            }
      1|   37|        }
      1|   38|
      1|   39|        let object = CocoaObject()
      1|   40|        object.analyticsProvider = AnalyticsProviderSpy()
      1|   41|        object.analyticsProvider.trackEvent( EventDummy() )
      1|   42|
      1|   43|        let spy = object.analyticsProvider as? AnalyticsProviderSpy
      1|   44|
      1|   45|        let retrievedEvent: PPAnalyticsSerializable = spy!.lastEvent!
      1|   46|
      1|   47|        if let valueForKeyFoo = retrievedEvent.dictionaryRepresentation()["Foo"] as? String,
      1|   48|           let eventName = retrievedEvent.dynamicType.analyticsEventName()
      0|   49|        {
      0|   50|            XCTAssertEqual(eventName, "Foo")
      0|   51|            XCTAssertEqual(valueForKeyFoo, "Bar")
      1|   52|        } else {
      1|   53|            XCTFail("The provider is not storing its event correctly.")
      1|   54|        }
      1|   55|    }
       |   56|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPAnalyticsViewAuthenticationModalTests.swift:
       |    1|//
       |    2|//  PPAnalyticsViewAuthenticationModalTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 9/24/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|
       |   11|typealias AuthStep = PPAnalyticsAuthenticationStep
       |   12|typealias AuthArea = PPAnalyticsAuthenticationArea
       |   13|typealias TestValueTupleType = (step:AuthStep, area:AuthArea, event: PPAnalyticsSerializable!)
       |   14|
       |   15|let AccountActivityStepKey = "account_activity_step"
       |   16|let AuthenticationStepKey = "auth step"
       |   17|let AuthenticationAreaKey = "auth area"
       |   18|
       |   19|// MARK: Unit Test
       |   20|
       |   21|class PPAnalyticsViewAuthenticationModalTests: XCTestCase {
       |   22|
      3|   23|    override func setUp() {
      3|   24|        super.setUp()
      3|   25|    }
       |   26|
      3|   27|    override func tearDown() {
      3|   28|        super.tearDown()
      3|   29|    }
       |   30|
      1|   31|    func testAnalyticsEventsHaveCorrectAccountActivityStep() {
      1|   32|
     21|   33|        for (_, _, event) in getTestValues() {
     21|   34|
     21|   35|            if let valueUnderTest = event.accountActivityValue() {
     21|   36|                XCTAssertEqual(valueUnderTest, ExpectedValues.AccountActivityStepValue)
      0|   37|            } else {
      0|   38|                XCTFail("Event \(event) should have an entry for key: \(AccountActivityStepKey)")
      0|   39|            }
     21|   40|        }
      1|   41|    }
       |   42|
      1|   43|    func testAnalyticsEventsHaveCorrectAuthenticationStep() {
      1|   44|
     21|   45|        for (step, _, event) in getTestValues() {
     21|   46|
     21|   47|            if let valueUnderTest = event.authenticationStepValue() {
     21|   48|                XCTAssertEqual(valueUnderTest, ExpectedValues.Steps[step])
      0|   49|            } else {
      0|   50|                XCTFail("Event \(event) should have an entry for key: \(AuthenticationStepKey)")
      0|   51|            }
     21|   52|        }
      1|   53|    }
       |   54|
      1|   55|    func testAnalyticsEventsHaveCorrectAuthenticationArea() {
      1|   56|
     21|   57|        for (_, area, event) in getTestValues() {
     21|   58|
     21|   59|            if let valueUnderTest = event.authenticationAreaValue() {
     21|   60|                XCTAssertEqual(valueUnderTest, ExpectedValues.Areas[area])
      0|   61|            } else {
      0|   62|                XCTFail("Event \(event) should have an entry for key: \(AuthenticationAreaKey)")
      0|   63|            }
     21|   64|        }
      1|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: Test Case Utilities
       |   69|
       |   70|extension PPAnalyticsViewAuthenticationModalTests {
       |   71|
       |   72|    /**
       |   73|    Build a List of Tuples containing all the different value combinations to Test.
       |   74|
       |   75|    - returns: A list of Tuples of type (AuthenticationStep, AuthenticationArea, PPAnalyticsSerializable)
       |   76|    */
      3|   77|    func getTestValues() -> [TestValueTupleType] {
      3|   78|        var list = [TestValueTupleType]()
      9|   79|        for step in AuthStep.allValues() {
     63|   80|            for area in AuthArea.allValues() {
     63|   81|                let event = PPAnalyticsViewAuthenticationModalFactory.authenticationModalEventForStep(step, withArea: area)
     63|   82|                list.append((step, area, event))
     63|   83|            }
      9|   84|        }
      3|   85|        return list
      3|   86|    }
       |   87|}
       |   88|
       |   89|// MARK: Additions for Enum iteration
       |   90|
       |   91|extension AuthStep {
      3|   92|    static func allValues() -> [AuthStep] {
      3|   93|        return [AuthStep.Login, AuthStep.Register, AuthStep.Unknown]
      3|   94|    }
       |   95|}
       |   96|
       |   97|extension AuthArea {
     11|   98|    static func allValues() -> [AuthArea] {
     11|   99|        return [AuthArea.Create,
     11|  100|                AuthArea.Favorites,
     11|  101|                AuthArea.More,
     11|  102|                AuthArea.Photos,
     11|  103|                AuthArea.Postbox,
     11|  104|                AuthArea.Unknown,
     11|  105|                AuthArea.TabletMenu]
     11|  106|    }
       |  107|}
       |  108|
       |  109|// MARK: Event Dictionary value shortcuts - make code easier to read.
       |  110|
       |  111|extension PPAnalyticsSerializable {
       |  112|
       |  113|    /**
       |  114|    Value associated to the key "account_activity_step"
       |  115|    */
     25|  116|    func accountActivityValue() -> String? {
     25|  117|        return dictionaryRepresentation()[AccountActivityStepKey] as! String?
     25|  118|    }
       |  119|
       |  120|    /**
       |  121|    Value associated to the key "auth step"
       |  122|    */
     40|  123|    func authenticationStepValue() -> String? {
     40|  124|        return dictionaryRepresentation()[AuthenticationStepKey] as! String?
     40|  125|    }
       |  126|
       |  127|    /**
       |  128|    Value associated to the key "auth area"
       |  129|    */
     54|  130|    func authenticationAreaValue() -> String? {
     54|  131|        return dictionaryRepresentation()[AuthenticationAreaKey] as! String?
     54|  132|    }
       |  133|}
       |  134|
       |  135|// MARK: Expected Test Values
       |  136|
       |  137|struct ExpectedValues {
       |  138|
       |  139|    static let AccountActivityStepValue = "Authentication modal"
       |  140|
       |  141|    static let Steps = [AuthStep.Login : "Login",
       |  142|        AuthStep.Register : "Register",
       |  143|        AuthStep.Unknown : "Unknown"]
       |  144|
       |  145|    static let Areas = [AuthArea.Create : "Create",
       |  146|        AuthArea.Photos : "Photos",
       |  147|        AuthArea.Favorites : "Favorites",
       |  148|        AuthArea.Postbox : "Postbox",
       |  149|        AuthArea.More : "More",
       |  150|        AuthArea.Unknown : "Unknown",
       |  151|        AuthArea.TabletMenu : "iPad Menu"]
       |  152|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPAuthenticationViewControllerAnalyticsUserInputTests.swift:
       |    1|//
       |    2|//  PPAuthenticationViewControllerAnalyticsUserInputTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 9/30/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|
       |   11|// MARK: Unit Test for PPAnalyticsAuthenticationEvent and PPAnalyticsRegistrationEvent()
       |   12|
       |   13|class PPAuthenticationViewControllerAnalyticsUserInputTests : XCTestCase {
       |   14|
      1|   15|    func testExpectedEventsAreDispatchedForSuccessfulLoginAuthentication() {
      1|   16|
      1|   17|        // GIVEN
      1|   18|        let anyArea = AuthArea.Create
      1|   19|        let spy = AnalyticsProviderSpy()
      1|   20|        let authenticationModal = AuthenticationViewController(requestType: RequestType.Authentication, source: anyArea)
      1|   21|        authenticationModal.analyticsProvider = spy
      1|   22|
      1|   23|        // WHEN
      1|   24|        authenticationModal.publishAnalyticsForSuccessfulAuthentication()
      1|   25|
      1|   26|        // WHERE
      1|   27|        XCTAssertEqual(spy.capturedEvents.count, 3)
      1|   28|
      1|   29|        var availableEventNames: Set<String> = [
      1|   30|            LoginRegisterMixpanelExpectedValues.EventNames.FlurryAccountLogin,
      1|   31|            LoginRegisterMixpanelExpectedValues.EventNames.PPStatCountLogin,
      1|   32|            LoginRegisterMixpanelExpectedValues.EventNames.PPAuthentication
      1|   33|        ]
      1|   34|
      3|   35|        for event in spy.capturedEvents {
      3|   36|
      3|   37|            if let event = event, eventName = event.eventName() {
      3|   38|
      3|   39|                if availableEventNames.contains(eventName) {
      3|   40|
      3|   41|                    XCTAssertNotNil(availableEventNames.remove(eventName) , "Non-unique value for event name: \(eventName). Event name values are expected to be unique for this test.")
      3|   42|
      1|   43|                    if eventName == LoginRegisterMixpanelExpectedValues.EventNames.PPAuthentication {
      1|   44|                        XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[anyArea])
      1|   45|                        XCTAssertEqual(event.accountActivityValue(), LoginRegisterMixpanelExpectedValues.AccountActivityStep.LogIn)
      1|   46|                        XCTAssertNil(event.authenticationStepValue(), "event should not have a value for key \(AuthenticationStepKey) ")
      1|   47|                    }
      3|   48|                }
      0|   49|                else {
      0|   50|                    XCTFail("The event name (\(eventName)) did not match any of the expected names: \(availableEventNames)")
      0|   51|                }
      3|   52|            }
      0|   53|            else {
      0|   54|                XCTFail("The event (\(event)), or its event name (\(event?.eventName())) cannot be nil")
      0|   55|            }
      3|   56|        }
      1|   57|    }
       |   58|
      1|   59|    func testExpectedEventsAreDispatchedForSuccessfulSignUpAuthentication() {
      1|   60|
      1|   61|        // GIVEN
      1|   62|        let anyArea = AuthArea.Create
      1|   63|        let spy = AnalyticsProviderSpy()
      1|   64|        let authenticationModal = AuthenticationViewController(requestType: RequestType.NewAccount, source: anyArea)
      1|   65|        authenticationModal.analyticsProvider = spy
      1|   66|
      1|   67|        // WHEN
      1|   68|        authenticationModal.publishAnalyticsForSuccessfulAuthentication()
      1|   69|
      1|   70|        // WHERE
      1|   71|        XCTAssertEqual(spy.capturedEvents.count, 3)
      1|   72|
      1|   73|        var availableEventNames : Set<String> = [
      1|   74|            LoginRegisterMixpanelExpectedValues.EventNames.FlurryAccountSignUp,
      1|   75|            LoginRegisterMixpanelExpectedValues.EventNames.PPStatCountSignUp,
      1|   76|            LoginRegisterMixpanelExpectedValues.EventNames.PPRegistration
      1|   77|        ]
      1|   78|
      3|   79|        for event in spy.capturedEvents {
      3|   80|
      3|   81|            if let event = event, eventName = event.eventName() {
      3|   82|
      3|   83|                if availableEventNames.contains(eventName) {
      3|   84|
      3|   85|                    XCTAssertNotNil(availableEventNames.remove(eventName) , "Non-unique value for event name: \(eventName). Event name values are expected to be unique for this test.")
      3|   86|
      1|   87|                    if eventName == LoginRegisterMixpanelExpectedValues.EventNames.FlurryAccountSignUp {
      1|   88|                        let key = "Normal", value = event.dictionaryRepresentation()[key] as? String
      1|   89|                        XCTAssertNotNil(value)
      1|   90|                        XCTAssertEqual(value, "Type")
      1|   91|                    }
      3|   92|
      1|   93|                    if eventName == LoginRegisterMixpanelExpectedValues.EventNames.PPRegistration {
      1|   94|                        XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[anyArea])
      1|   95|                        XCTAssertEqual(event.accountActivityValue(), LoginRegisterMixpanelExpectedValues.AccountActivityStep.Register)
      1|   96|                        XCTAssertNil(event.authenticationStepValue(), "event should not have a value for key \(AuthenticationStepKey) ")
      1|   97|                    }
      3|   98|                }
      0|   99|                else {
      0|  100|                    XCTFail("The event name (\(eventName)) did not match any of the expected names: \(availableEventNames)")
      0|  101|                }
      3|  102|            }
      0|  103|            else {
      0|  104|                XCTFail("The event (\(event)), or its event name (\(event?.eventName())) cannot be nil")
      0|  105|            }
      3|  106|        }
      1|  107|    }
       |  108|}
       |  109|
       |  110|extension PPAnalyticsSerializable {
       |  111|
      6|  112|    func eventName() -> String? {
      6|  113|        return self.dynamicType.analyticsEventName()
      6|  114|    }
       |  115|}
       |  116|
       |  117|extension PPAuthenticationViewControllerAnalyticsUserInputTests {
       |  118|
       |  119|    private struct LoginRegisterMixpanelExpectedValues {
       |  120|
       |  121|        struct EventNames {
       |  122|            static let FlurryAccountLogin = "Accounts_Login"
       |  123|            static let PPStatCountLogin = "log_in"
       |  124|            static let PPAuthentication = "Account Activity"
       |  125|            static let FlurryAccountSignUp = "Accounts_NewSignUp"
       |  126|            static let PPStatCountSignUp = "sign_up"
       |  127|            static let PPRegistration = "Account Activity"
       |  128|        }
       |  129|
       |  130|        struct AccountActivityStep {
       |  131|            static let LogIn = "Log in"
       |  132|            static let Register = "Register"
       |  133|        }
       |  134|    }
       |  135|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPAuthenticationViewControllerTests.swift:
       |    1|//
       |    2|//  PPAuthenticationViewControllerTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 9/24/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|import PaperlessPost
       |   11|
       |   12|typealias RequestType = PPAPIAccountRequestType
       |   13|typealias EventFactory = PPAnalyticsViewAuthenticationModalFactory
       |   14|
       |   15|// MARK: Analytics Spy
       |   16|
       |   17|class AnalyticsProviderSpy : NSObject, PPAnalyticsProviderObjC {
       |   18|
       |   19|    var capturedEvents: [PPAnalyticsSerializable?] = []
       |   20|
     17|   21|    var capturedEvent: PPAnalyticsSerializable? {
     17|   22|        if let lastEvent = capturedEvents.last {
     17|   23|            return lastEvent
      0|   24|        } else {
      0|   25|            return nil
      0|   26|        }
      0|   27|    }
       |   28|
     25|   29|    @objc func trackEvent(event: PPAnalyticsSerializable) {
     25|   30|        capturedEvents.append(event)
     25|   31|    }
       |   32|}
       |   33|
       |   34|// MARK: Unit Test
       |   35|
       |   36|class PPAuthenticationViewControllerTests: XCTestCase {
       |   37|
      1|   38|    func testItStartsWithLoginMode() {
      1|   39|
      1|   40|        let spy = AnalyticsProviderSpy()
      1|   41|
      1|   42|        let viewController = AuthenticationViewController(requestType: RequestType.Authentication, source: AuthArea.Create)
      1|   43|        viewController.analyticsProvider = spy
      1|   44|        viewController.viewDidAppear(false)
      1|   45|
      1|   46|        if let event = spy.capturedEvent {
      1|   47|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Create])
      1|   48|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      0|   49|        } else {
      0|   50|            XCTFail("an event was not triggered.")
      0|   51|        }
      1|   52|    }
       |   53|
      1|   54|    func testItCanMoveToSignUpMode() {
      1|   55|
      1|   56|        let spy = AnalyticsProviderSpy()
      1|   57|
      1|   58|        let viewController = AuthenticationViewController(requestType: RequestType.NewAccount, source: AuthArea.Create)
      1|   59|        viewController.analyticsProvider = spy
      1|   60|        viewController.viewDidAppear(false)
      1|   61|
      1|   62|        if let event = spy.capturedEvent {
      1|   63|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Create])
      1|   64|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Register])
      0|   65|        } else {
      0|   66|            XCTFail("an event was not triggered.")
      0|   67|        }
      1|   68|    }
       |   69|
       |   70|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPCameraAssetsSourceTests.swift:
       |    1|//
       |    2|//  PPCameraAssetsSourceTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 10/6/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|
       |   11|// MARK: -
       |   12|// MARK: Unit Tests
       |   13|// MARK: -
       |   14|
       |   15|class PPCameraAssetsSourceTests: XCTestCase {
       |   16|
      0|   17|    func testAssetsSourceInitializesCorrectly() {
      0|   18|
      0|   19|        guard let assetsSource: PPCameraAssetsSourceStub! = PPCameraAssetsSource.current() as? PPCameraAssetsSourceStub! else {
      0|   20|            XCTFail("unit test is not setup correctly"); return
      0|   21|        }
      0|   22|
      0|   23|        let expectation = expectationWithDescription("assetsSource initialized correctly")
      0|   24|        assetsSource.signalForObservingIsLoadedPropertyChange().subscribeNext {
      0|   25|
      0|   26|            guard let tuple = $0 as? RACTuple! else { XCTFail(); return }
      0|   27|            guard let isLoaded = tuple.first as? Bool else { XCTFail(); return }
      0|   28|            guard let error = tuple.second as? NSError? else { XCTFail(); return }
      0|   29|
      0|   30|            XCTAssertTrue(isLoaded)
      0|   31|            XCTAssertNil(error)
      0|   32|            expectation.fulfill()
      0|   33|        }
      0|   34|
      0|   35|        assetsSource.startLoading()
      0|   36|
      0|   37|        waitForExpectationsWithTimeout(2.0, handler: nil)
      0|   38|    }
       |   39|
      0|   40|    func testAssetsSourceLoadingShouldOccurOnlyOnce() {
      0|   41|
      0|   42|        guard let assetsSource: PPCameraAssetsSourceStub! = PPCameraAssetsSource.current() as? PPCameraAssetsSourceStub! else {
      0|   43|            XCTFail("unit test is not setup correctly"); return
      0|   44|        }
      0|   45|
      0|   46|        let expectation = expectationWithDescription("assetsSource loading occurs once")
      0|   47|        let maxAllowedInitializations = 1
      0|   48|        var currentInitializations = 0
      0|   49|
      0|   50|        assetsSource.signalForObservingIsLoadedPropertyChange().subscribeNext {
      0|   51|
      0|   52|            guard let tuple = $0 as? RACTuple! else { XCTFail(); return }
      0|   53|            guard let isLoaded = tuple.first as? Bool else { XCTFail(); return }
      0|   54|            guard let error = tuple.second as? NSError? else { XCTFail(); return }
      0|   55|
      0|   56|            XCTAssertTrue(isLoaded)
      0|   57|            XCTAssertNil(error)
      0|   58|            XCTAssertTrue(currentInitializations <= maxAllowedInitializations)
      0|   59|            currentInitializations++
      0|   60|            expectation.fulfill()
      0|   61|        }
      0|   62|
      0|   63|        assetsSource.startLoading()
      0|   64|        assetsSource.startLoading()
      0|   65|
      0|   66|        waitForExpectationsWithTimeout(2.0, handler: nil)
      0|   67|    }
       |   68|
      0|   69|    func testAssetsSourceProducesErrorFromLibrary() {
      0|   70|
      0|   71|        guard let assetsSource: PPCameraAssetsSourceStub! = PPCameraAssetsSource.current() as? PPCameraAssetsSourceStub! else {
      0|   72|            XCTFail("unit test is not setup correctly"); return
      0|   73|        }
      0|   74|
      0|   75|        let expectation = expectationWithDescription("assetsSource produces error from library")
      0|   76|        assetsSource.expectedError = errorForAssetsSourceErrorCode(PPCameraAssetsSourceErrorCode.CameraRollNotFound)
      0|   77|        assetsSource.signalForObservingIsLoadedPropertyChange().subscribeNext {
      0|   78|
      0|   79|            guard let tuple = $0 as? RACTuple! else { XCTFail(); return }
      0|   80|            guard let isLoaded = tuple.first as? Bool else { XCTFail(); return }
      0|   81|            guard let error = tuple.second as? NSError? else { XCTFail(); return }
      0|   82|
      0|   83|            XCTAssertFalse(isLoaded)
      0|   84|            XCTAssertNotNil(error)
      0|   85|            XCTAssertEqual(error!.code, Int(PPCameraAssetsSourceErrorCode.CameraRollNotFound.rawValue) )
      0|   86|            expectation.fulfill()
      0|   87|        }
      0|   88|
      0|   89|        assetsSource.startLoading()
      0|   90|
      0|   91|        waitForExpectationsWithTimeout(2.0, handler: nil)
      0|   92|    }
       |   93|
      0|   94|    func testAssetsSourceProducesErrorFromAssetEnumeration() {
      0|   95|
      0|   96|        guard let assetsSource: PPCameraAssetsSourceStub! = PPCameraAssetsSource.current() as? PPCameraAssetsSourceStub! else {
      0|   97|            XCTFail("unit test is not setup correctly"); return
      0|   98|        }
      0|   99|
      0|  100|        let expectation = expectationWithDescription("assetsSource produced error from asset enumeration")
      0|  101|
      0|  102|        assetsSource.expectedError = errorForAssetsErrorCode(ALAssetsLibraryAccessUserDeniedError)
      0|  103|        assetsSource.signalForObservingIsLoadedPropertyChange().subscribeNext {
      0|  104|
      0|  105|            guard let tuple = $0 as? RACTuple! else { XCTFail(); return }
      0|  106|            guard let isLoaded = tuple.first as? Bool else { XCTFail(); return }
      0|  107|            guard let error = tuple.second as? NSError? else { XCTFail(); return }
      0|  108|
      0|  109|            XCTAssertFalse(isLoaded)
      0|  110|            XCTAssertNotNil(error)
      0|  111|            XCTAssertEqual(error!.code, ALAssetsLibraryAccessUserDeniedError )
      0|  112|            expectation.fulfill()
      0|  113|        }
      0|  114|
      0|  115|        assetsSource.startLoading()
      0|  116|
      0|  117|        waitForExpectationsWithTimeout(2.0, handler: nil)
      0|  118|    }
       |  119|}
       |  120|
       |  121|// MARK: -
       |  122|// MARK: PPCameraAssetsSource Partial Mock
       |  123|// MARK: -
       |  124|
       |  125|class PPCameraAssetsSourceStub : PPCameraAssetsSource {
       |  126|
       |  127|    private static var sharedInstance = PPCameraAssetsSourceStub()
       |  128|
      0|  129|    static func currentStub() -> PPCameraAssetsSourceStub {
      0|  130|        return sharedInstance
      0|  131|    }
       |  132|
      0|  133|    static func cleanup() {
      0|  134|        sharedInstance = PPCameraAssetsSourceStub()
      0|  135|    }
       |  136|
       |  137|    var expectedAssetsFromGroup: [AnyObject]! = [ALAsset(), ALAsset()]
       |  138|
       |  139|    var expectedError: NSError! {
      0|  140|        didSet {
      0|  141|            self.expectedAssetsFromGroup = nil
      0|  142|        }
       |  143|    }
       |  144|
      0|  145|    override var currentGroup: PPCameraAssetGroup! {
      0|  146|        class PPCameraAssetGroupMock : PPCameraAssetGroup {
      0|  147|            var expectedAssets : [AnyObject]!
      0|  148|            override var assets: [AnyObject]! {
      0|  149|                get { return expectedAssets }
      0|  150|                set {} // NO-OP
      0|  151|            }
      0|  152|        }
      0|  153|        let mock = PPCameraAssetGroupMock()
      0|  154|        mock.expectedAssets = expectedAssetsFromGroup
      0|  155|        return mock
      0|  156|    }
       |  157|
      0|  158|    override func startLoading() {
      0|  159|        loadTaskWithCallback {
      0|  160|            self.loadingError = $0
      0|  161|            self.isLoading = false
      0|  162|        }
      0|  163|    }
       |  164|
      0|  165|    override func loadTaskWithCallback(callback: ((NSError!) -> Void)!) {
      0|  166|        callback(expectedError)
      0|  167|    }
       |  168|}
       |  169|
       |  170|// MARK: -
       |  171|// MARK: PPCameraAssetsSource Swizzable Additions
       |  172|// MARK: -
       |  173|
       |  174|extension PPCameraAssetsSource {
      0|  175|    static func swz_current() -> PPCameraAssetsSource! {
      0|  176|        return PPCameraAssetsSourceStub.currentStub()
      0|  177|    }
       |  178|}
       |  179|
       |  180|// MARK: -
       |  181|// MARK: PPCameraAssetsSourceTests setup, teardown, helper methods
       |  182|// MARK: -
       |  183|
       |  184|extension PPCameraAssetsSourceTests {
       |  185|
      0|  186|    override func setUp() {
      0|  187|        super.setUp()
      0|  188|
      0|  189|        do {
      0|  190|            let originalSelector = Selector("current")
      0|  191|            let swizzledSelector = Selector("swz_current")
      0|  192|            try PPCameraAssetsSourceTests.swizzleStaticMethodSelector(originalSelector, withSelector: swizzledSelector, forClass: PPCameraAssetsSource.classForCoder())
      0|  193|        } catch ( SwizzleErrorType.OriginalMethodNotFound ) {
      0|  194|            XCTFail("Original method not found")
      0|  195|        } catch (SwizzleErrorType.SwizzleMethodNotFound) {
      0|  196|            XCTFail("Swizzable method not found")
      0|  197|        } catch _ {
      0|  198|            XCTFail("Unknown error")
      0|  199|        }
      0|  200|    }
       |  201|
      0|  202|    override func tearDown() {
      0|  203|
      0|  204|        do {
      0|  205|            let originalSelector = Selector("current")
      0|  206|            let swizzledSelector = Selector("swz_current")
      0|  207|            try PPCameraAssetsSourceTests.swizzleStaticMethodSelector(originalSelector, withSelector: swizzledSelector, forClass: PPCameraAssetsSource.classForCoder())
      0|  208|        } catch ( SwizzleErrorType.OriginalMethodNotFound ) {
      0|  209|            XCTFail("Original method not found")
      0|  210|        } catch (SwizzleErrorType.SwizzleMethodNotFound) {
      0|  211|            XCTFail("Swizzable method not found")
      0|  212|        } catch _ {
      0|  213|            XCTFail("Unknown error")
      0|  214|        }
      0|  215|
      0|  216|        PPCameraAssetsSourceStub.cleanup()
      0|  217|
      0|  218|        super.tearDown()
      0|  219|    }
       |  220|
      0|  221|    func errorForAssetsSourceErrorCode(errorCode:PPCameraAssetsSourceErrorCode) -> NSError! {
      0|  222|        return NSError(domain: PPCameraAssetSourceErrorDomain, code: Int(errorCode.rawValue), userInfo: [NSLocalizedDescriptionKey : "Fake Error"])
      0|  223|    }
       |  224|
      0|  225|    func errorForAssetsErrorCode(errorCode:Int) -> NSError! {
      0|  226|        return NSError(domain: ALAssetsLibraryErrorDomain, code: errorCode, userInfo: [NSLocalizedDescriptionKey : "Fake Error"])
      0|  227|    }
       |  228|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPCardBrowserViewControllerAuthenticationTests.swift:
       |    1|//
       |    2|//  PPCardBrowserViewControllerAuthenticationTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 9/28/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|
       |   11|class PPCardBrowserViewControllerAuthenticationTests: XCTestCase {
       |   12|
      0|   13|    let dummyClosure : ClosureType = { arg in }
  ------------------
  | _TFC18PaperlessPostTests46PPCardBrowserViewControllerAuthenticationTestsCfMS0_FT10invocationGSqCSo12NSInvocation__S0_ :
  |      0|   13|    let dummyClosure : ClosureType = { arg in }
  ------------------
  | _TFC18PaperlessPostTests46PPCardBrowserViewControllerAuthenticationTestsCfMS0_FT8selectorV10ObjectiveC8Selector_S0_ :
  |      0|   13|    let dummyClosure : ClosureType = { arg in }
  ------------------
  | _TFC18PaperlessPostTests46PPCardBrowserViewControllerAuthenticationTestsCfMS0_FT_S0_ :
  |      0|   13|    let dummyClosure : ClosureType = { arg in }
  ------------------
       |   14|
      1|   15|    func testAuthModalFromCardBrowserViewController() {
      1|   16|
      1|   17|        // Corresponds to PPCardBrowserViewController -favoritePackage:
      1|   18|
      1|   19|        let vc = PPCardBrowserViewController()
      1|   20|        let navDouble: PPNavigatorDouble! = PPNavigatorDouble.currentNavigator()
      1|   21|        navDouble.presentAuthenticationModalFromViewController(vc, authenticationArea:.Create, withCompletionBlock: dummyClosure)
      1|   22|
      1|   23|        if let event = navDouble.capturedEvent {
      1|   24|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      1|   25|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Create])
      0|   26|        } else {
      0|   27|            XCTFail("PPNavigator should had captured an event.")
      0|   28|        }
      1|   29|    }
       |   30|
      1|   31|    func testAuthModalFromCardDetailViewController() {
      1|   32|
      1|   33|        // Corresponds to PPCardBrowserViewController -favoritePackage:
      1|   34|
      1|   35|        let vc = PPCardBrowserViewController()
      1|   36|        let navDouble: PPNavigatorDouble! = PPNavigatorDouble.currentNavigator()
      1|   37|        navDouble.presentAuthenticationModalFromViewController(vc, authenticationArea:.Create, withCompletionBlock: dummyClosure)
      1|   38|
      1|   39|        if let event = navDouble.capturedEvent {
      1|   40|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      1|   41|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Create])
      0|   42|        } else {
      0|   43|            XCTFail("PPNavigator should had captured an event.")
      0|   44|        }
      1|   45|    }
       |   46|
       |   47|}
       |   48|
       |   49|extension PPCardBrowserViewControllerAuthenticationTests {
      2|   50|    override func setUp() {
      2|   51|        super.setUp()
      2|   52|        // Put setup code here. This method is called before the invocation of each test method in the class.
      2|   53|    }
       |   54|
      2|   55|    override func tearDown() {
      2|   56|        // Put teardown code here. This method is called after the invocation of each test method in the class.
      2|   57|        super.tearDown()
      2|   58|    }
       |   59|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPCardDetailViewFoldedFoilCardViewTests.swift:
       |    1|//
       |    2|//  PPCardDetailViewFoldedFoilCardViewTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Jabari Bell on 6/1/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|class PPCardDetailViewFoldedFoilCardViewTests: FBSnapshotTestCase {
       |   13|    
       |   14|    private let kViewRect = CGRect(x: 0, y: 0, width: 320, height: 50)
       |   15|    
      2|   16|    override func setUp() {
      2|   17|        super.setUp()
      2|   18|        self.recordMode = false
      2|   19|    }
       |   20|    
      1|   21|    func testThatViewLaysOutForForFoilView() {
      1|   22|        let cardView = PPCardDetailViewFoldedFoilCardView(frame: kViewRect, cardViewType: PPCardDetailViewFoldedFoilCardViewType.Foil);
      1|   23|        cardView.backgroundColor = UIColor.whiteColor()
      1|   24|        FBSnapShotVerifyView(cardView, identifier:nil)
      1|   25|    }
       |   26|    
      1|   27|    func testThatViewLaysOutForForFoldedView() {
      1|   28|        let cardView = PPCardDetailViewFoldedFoilCardView(frame: kViewRect, cardViewType: PPCardDetailViewFoldedFoilCardViewType.Folded);
      1|   29|        cardView.backgroundColor = UIColor.whiteColor()
      1|   30|        FBSnapShotVerifyView(cardView, identifier:nil)
      1|   31|    }
       |   32|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPCardViewTests.swift:
       |    1|//
       |    2|//  PPCardViewTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 9/29/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|@available(iOS 8.0, *)
       |   13|class PPCardViewTests: FBSnapshotTestCase {
       |   14|
      1|   15|    override func setUp() {
      1|   16|        super.setUp()
      1|   17|        self.recordMode = false
      1|   18|    }
       |   19|
      1|   20|    func testCardRendersCorrectly() {
      1|   21|     
      1|   22|        let cardView = PPCardView()
      1|   23|        cardView.frontImage = CardViewTestHelper().cardFrontImage()
      1|   24|        cardView.backImage = CardViewTestHelper().cardBackImage()
      1|   25|
      1|   26|        cardView.frame = CGRectMake(0, 0, 768, 1024)
      1|   27|    
      1|   28|        FBSnapShotVerifyView(cardView, identifier: nil)
      1|   29|    }
       |   30|}
       |   31|
       |   32|@available(iOS 8.0, *)
       |   33|struct CardViewTestHelper {
       |   34|    
      1|   35|    func cardFrontImage() -> UIImage! {
      1|   36|        
      1|   37|        return PPFixtureFactory.Images.VerticalSnapshotCard.front
      1|   38|    }
       |   39|    
      1|   40|    func cardBackImage() -> UIImage! {
      1|   41|        return PPFixtureFactory.Images.VerticalSnapshotCard.back
      1|   42|    }
       |   43|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPCartManagerViewObserverTests.swift:
       |    1|//
       |    2|//  PPCartManagerViewObserverTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 10/28/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import ObjectiveC
       |   11|import XCTest
       |   12|import PaperlessPost
       |   13|
       |   14|class MockUpdateObject {
       |   15|    var numberOfItemsInCart: Int = 0
       |   16|}
       |   17|
       |   18|typealias CartItemCurry = ((mockObject: MockUpdateObject) -> CartUpdateBlock)
       |   19|
       |   20|let cartItemCurry: CartItemCurry = { (mockObject: MockUpdateObject) -> CartUpdateBlock in
       |   21|    return { (numItems) -> Void in mockObject.numberOfItemsInCart = numItems }
       |   22|}
       |   23|
       |   24|class PPCartManagerViewObserverTests: XCTestCase {
       |   25|
       |   26|    //Define our mock CartManger (We don't want to use the shared instance)
       |   27|    let mockManager = PPMockCartManager()
       |   28|
      4|   29|    override func setUp() {
      4|   30|        super.setUp()
      4|   31|    }
       |   32|    
      4|   33|    override func tearDown() {
      4|   34|        super.tearDown()
      4|   35|        mockManager.itemsInCart = 0
      4|   36|    }
       |   37|    
      1|   38|    func testItUpdatesCorrectly() {
      1|   39|        
      1|   40|        let itemObserver = PPCartManagerItemObserver()
      1|   41|        itemObserver.cartManager = mockManager
      1|   42|        
      1|   43|        //Set up a conforming object that should be updated
      1|   44|        let myMockObject = MockUpdateObject()
      1|   45|        myMockObject.numberOfItemsInCart = 0
      1|   46|        
      1|   47|        itemObserver.cartManager = mockManager
      1|   48|        
      1|   49|        XCTAssertTrue(itemObserver.cartManager === mockManager, "After setting the cartManagerInstance, it should be set to the initial value provided")
      1|   50|        
      1|   51|        itemObserver.subscribeNext(cartItemCurry(mockObject: myMockObject))
      1|   52|        
      1|   53|        mockManager.internalItems = 10
      1|   54|        
      1|   55|        XCTAssert(myMockObject.numberOfItemsInCart == 10, "After updating the number of items in the CartManager, the conforming object's `numberOfItemInCart` property should have been auto-updated")
      1|   56|    }
       |   57|    
      1|   58|    func testItUnobservers() {
      1|   59|        
      1|   60|        let itemObserver = PPCartManagerItemObserver()
      1|   61|        itemObserver.cartManager = mockManager
      1|   62|        
      1|   63|        let myMockObject = MockUpdateObject()
      1|   64|        myMockObject.numberOfItemsInCart = 0
      1|   65|        
      1|   66|        itemObserver.subscribeNext(cartItemCurry(mockObject: myMockObject))
      1|   67|        
      1|   68|        mockManager.internalItems = 15
      1|   69|        
      1|   70|        XCTAssert(myMockObject.numberOfItemsInCart == 15, "After updating the number of items in the CartManager, the conforming object's `numberOfItemInCart` property should have been auto-updated")
      1|   71|
      1|   72|        itemObserver.unsubscribeAll()
      1|   73|        
      1|   74|        mockManager.internalItems = 25
      1|   75|        
      1|   76|        XCTAssertTrue(myMockObject.numberOfItemsInCart == 15 && myMockObject.numberOfItemsInCart != 25, "Once the item is unmanaged, it's value should not be udpated to reflect the manager")
      1|   77|    }
       |   78|    
      1|   79|    func testSwappingOutItsCartManagerUpdatesItemsCorrectly() {
      1|   80|        
      1|   81|        let itemObserver = PPCartManagerItemObserver()
      1|   82|        itemObserver.cartManager = mockManager
      1|   83|        
      1|   84|        let myMockObject = MockUpdateObject()
      1|   85|        myMockObject.numberOfItemsInCart = 0
      1|   86|        
      1|   87|        itemObserver.subscribeNext(cartItemCurry(mockObject:myMockObject))
      1|   88|        mockManager.internalItems = 23
      1|   89|        
      1|   90|        XCTAssertTrue(myMockObject.numberOfItemsInCart == 23 , "The object should have the same number of items as the cartmanager")
      1|   91|
      1|   92|        //Swap out the cartManager
      1|   93|        let newCartManager = PPMockCartManager()
      1|   94|        newCartManager.internalItems = 923
      1|   95|        
      1|   96|        itemObserver.cartManager = newCartManager
      1|   97|        
      1|   98|        XCTAssertTrue(myMockObject.numberOfItemsInCart == newCartManager.internalItems , "The object should have the same number of items as the newly set cartmanager")
      1|   99|    }
       |  100|    
      1|  101|    func testItsCategoryWorksCorrecty() {
      1|  102|        
      1|  103|        //Set up a conforming object that should be updated
      1|  104|        let myMockObject = MockUpdateObject()
      1|  105|        myMockObject.numberOfItemsInCart = 0
      1|  106|        
      1|  107|        self.cartItemObserver.cartManager = mockManager
      1|  108|        self.cartItemObserver.subscribeNext(cartItemCurry(mockObject:myMockObject))
      1|  109|        
      1|  110|        mockManager.internalItems = 27
      1|  111|        
      1|  112|        XCTAssert(myMockObject.numberOfItemsInCart == 27, "After updating the number of items in the CartManager, the conforming object's `numberOfItemInCart` property should have been auto-updated")
      1|  113|    }
       |  114|}
       |  115|
       |  116|//MARK: Mock class for simulating PPCartManager updates/refreshes
       |  117|public class PPMockCartManager: PPCartManager {
       |  118|    
       |  119|    var internalItems: Int = 0 {
     10|  120|        willSet {
     10|  121|            self.willChangeValueForKey("itemsInCart")
     10|  122|        }
     10|  123|        didSet {
     10|  124|            self.didChangeValueForKey("itemsInCart")
     10|  125|        }
       |  126|    }
       |  127|
       |  128|    override public var itemsInCart: Int {
     24|  129|        get {
     24|  130|            return internalItems
      4|  131|        } set {
      4|  132|            internalItems = newValue
      4|  133|        }
       |  134|    }
       |  135|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPCartViewButtonTests.swift:
       |    1|//
       |    2|//  PPCartViewButtonTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 11/3/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|import PaperlessPost
       |   12|
       |   13|class PPCartViewButtonTests: FBSnapshotTestCase {
       |   14|
      4|   15|    override func setUp() {
      4|   16|        super.setUp()
      4|   17|        self.recordMode = false
      4|   18|    }
       |   19|    
      1|   20|    func testItRendersCorrectlyWithNoBadgeText() {
      1|   21|        let cartButton = PPCartViewButton(frame: CGRectZero)
      1|   22|        cartButton.badgeText = nil
      1|   23|        
      1|   24|        //Store in container view so we see it's drop shadow which lives outside it's bounds
      1|   25|        let container = placeInContainer(cartButton)
      1|   26|        FBSnapShotVerifyLayer(container.layer, identifier: nil)
      1|   27|    }
       |   28|    
      1|   29|    func testItRendersCorrectlyWithBadgeText() {
      1|   30|        let cartButton = PPCartViewButton(frame: CGRectZero)
      1|   31|        cartButton.badgeText = "7"
      1|   32|        
      1|   33|        //Store in container view so we see it's drop shadow which lives outside it's bounds
      1|   34|        let container = placeInContainer(cartButton)
      1|   35|        FBSnapShotVerifyLayer(container.layer, identifier: nil)
      1|   36|    }
       |   37|    
      1|   38|    func testItRendersCorrectlyWithTwoDigitBadgeText() {
      1|   39|        let cartButton = PPCartViewButton(frame: CGRectZero)
      1|   40|        cartButton.badgeText = "30"
      1|   41|        
      1|   42|        //Store in container view so we see it's drop shadow which lives outside it's bounds
      1|   43|        let container = placeInContainer(cartButton)
      1|   44|        FBSnapShotVerifyLayer(container.layer, identifier: nil)
      1|   45|    }
       |   46|    
      1|   47|    func testItRendersCorrectlyWithThreeDigitBadgeText() {
      1|   48|        let cartButton = PPCartViewButton(frame: CGRectZero)
      1|   49|        cartButton.badgeText = "777"
      1|   50|        
      1|   51|        //Store in container view so we see it's drop shadow which lives outside it's bounds
      1|   52|        let container = placeInContainer(cartButton)
      1|   53|        FBSnapShotVerifyLayer(container.layer, identifier: nil)
      1|   54|    }
       |   55|    
       |   56|    //Helper functions
       |   57|    
       |   58|    //NOTE: Important that the BG of this view NOT be transparant, transparant snapshots have failure issues
      4|   59|    func placeInContainer(subview: UIView) -> UIView {
      4|   60|        let container = UIView(frame: CGRectInset(subview.frame, -10, -10))
      4|   61|        container.backgroundColor = UIColor.lightGrayColor()
      4|   62|        container.addSubview(subview)
      4|   63|        subview.frame.origin = CGPoint(x:container.frame.width/2 - subview.frame.width/2, y: container.frame.height/2 - subview.frame.height/2)
      4|   64|        return container
      4|   65|    }
       |   66|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPEventModeTests.swift:
       |    1|//
       |    2|//  PPEventModeTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 5/21/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import Foundation
       |   10|import XCTest
       |   11|import PaperlessPost
       |   12|
       |   13|class PPEventModeTests: XCTestCase {
       |   14|
      6|   15|    override func setUp() {
      6|   16|        super.setUp()
      6|   17|        // Put setup code here. This method is called before the invocation of each test method in the class.
      6|   18|    }
       |   19|    
      6|   20|    override func tearDown() {
      6|   21|        // Put teardown code here. This method is called after the invocation of each test method in the class.
      6|   22|        super.tearDown()
      6|   23|    }
       |   24|    
      1|   25|    func testSettingTheEventModeValueSetsTheEventModeOnPPEventDetails() {
      1|   26|        
      1|   27|        //Online
      1|   28|        let eventDetailsOnline = PPEventDetails.createEntity() as! PPEventDetails
      1|   29|        eventDetailsOnline.eventModeValue = .Online
      1|   30|        XCTAssertTrue(eventDetailsOnline.eventMode == "online", "After setting the eventModeValue to online, the eventMode string should have also been set")
      1|   31|
      1|   32|        //Print
      1|   33|        let eventDetailsPrint = PPEventDetails.createEntity() as! PPEventDetails
      1|   34|        eventDetailsPrint.eventModeValue = .Print
      1|   35|        XCTAssertTrue(eventDetailsPrint.eventMode == "print", "After setting the eventModeValue to print, the eventMode string should have also been set")
      1|   36|        
      1|   37|        //Crane
      1|   38|        let eventDetailsCrane = PPEventDetails.createEntity() as! PPEventDetails
      1|   39|        eventDetailsCrane.eventModeValue = .Crane
      1|   40|        XCTAssertTrue(eventDetailsCrane.eventMode == "crane", "After setting the eventModeValue to crane, the eventMode string should have also been set")
      1|   41|    }
       |   42|    
      0|   43|    func thatThatTheEventModeValueReturnsCorrectlyAfterSettingEventMode() {
      0|   44|        
      0|   45|        //online
      0|   46|        let eventDetailsOnline = PPEventDetails.createEntity() as! PPEventDetails
      0|   47|        eventDetailsOnline.eventMode = "online"
      0|   48|        XCTAssertTrue(eventDetailsOnline.eventModeValue == .Online, "After setting the eventModeValue to online, the eventMode string should have also been set")
      0|   49|
      0|   50|        //Print
      0|   51|        let eventDetailsPrint = PPEventDetails.createEntity() as! PPEventDetails
      0|   52|        eventDetailsPrint.eventMode = "print"
      0|   53|        XCTAssertTrue(eventDetailsPrint.eventModeValue == .Print, "After setting the eventModeValue to print, the eventMode string should have also been set")
      0|   54|        
      0|   55|        //Crane
      0|   56|        let eventDetailsCrane = PPEventDetails.createEntity() as! PPEventDetails
      0|   57|        eventDetailsCrane.eventMode = "crane"
      0|   58|        XCTAssertTrue(eventDetailsCrane.eventModeValue == .Crane, "After setting the eventModeValue to crane, the eventMode string should have also been set")
      0|   59|        
      0|   60|    }
       |   61|    
      1|   62|    func testEventModeAPIStringsAreConvertedCorrectly() {
      1|   63|        
      1|   64|        let online = PPEventModeAPIStrings.Online
      1|   65|        XCTAssertTrue(online.toEventMode() == PPEventMode.Online, "API String for event mode 'online' should transform to PPEventMode.Online")
      1|   66|        
      1|   67|        let print = PPEventModeAPIStrings.Print
      1|   68|        XCTAssertTrue(print.toEventMode() == PPEventMode.Print, "API String for event mode 'print' should transform to PPEventMode.Print")
      1|   69|        
      1|   70|        let crane = PPEventModeAPIStrings.Crane
      1|   71|        XCTAssertTrue(crane.toEventMode() == PPEventMode.Crane, "API String for event mode 'crane' should transform to PPEventMode.Crane")
      1|   72|        
      1|   73|        let undefined = PPEventModeAPIStrings.Undefined
      1|   74|        XCTAssertTrue(undefined.toEventMode() == PPEventMode.Undefined, "API String for event mode 'undefined' should transform to PPEventMode.Undefined")
      1|   75|    }
       |   76|    
      1|   77|    func testsInitializingPPEventModeFromStrings() {
      1|   78|        
      1|   79|        let online = PPEventMode.fromString("online")
      1|   80|        XCTAssertTrue(online == .Online, "creating an event mode from string 'online', should yield PPEventMode.Online")
      1|   81|        
      1|   82|        let print = PPEventMode.fromString("print")
      1|   83|        XCTAssertTrue(print == .Print, "creating an event mode from string 'print', should yield PPEventMode.Print")
      1|   84|        
      1|   85|        let crane = PPEventMode.fromString("crane")
      1|   86|        XCTAssertTrue(crane == .Crane, "creating an event mode from string 'crane', should yield PPEventMode.Crane")
      1|   87|        
      1|   88|        let undefinedShouldBeNil = PPEventMode.fromString("STAMPY MODE")
      1|   89|        XCTAssertTrue(undefinedShouldBeNil == nil, "creating an event mode from an invalid string should yield a nil value")
      1|   90|    }
       |   91|    
      1|   92|    func testItConvertsEventModesToAPIStrings() {
      1|   93|        
      1|   94|        let online = PPEventMode.Online
      1|   95|        XCTAssertTrue(online.toAPIString() == "online", "PPEventMode.Online should convert to string 'online'")
      1|   96|        
      1|   97|        let print = PPEventMode.Print
      1|   98|        XCTAssertTrue(print.toAPIString() == "print", "PPEventMode.Online should convert to string 'print'")
      1|   99|        
      1|  100|        let crane = PPEventMode.Crane
      1|  101|        XCTAssertTrue(crane.toAPIString() == "crane", "PPEventMode.Online should convert to string 'crane'")
      1|  102|        
      1|  103|        let undefined = PPEventMode.Undefined
      1|  104|        XCTAssertTrue(undefined.toAPIString() == "", "PPEventMode.Undefined should convert to an empty string")
      1|  105|    }
       |  106|    
      1|  107|    func testEventModeHelpersConvertPreviewEventModesCorrectly() {
      1|  108|        
      1|  109|        let previewEventModeOnline = PPEventModeHelpers.previewEventModeFromEventMode(PPEventMode.Online)
      1|  110|        XCTAssertTrue(previewEventModeOnline == PreviewEventMode.Online, "PPEventMode.Online should convert to PPEventMode.Online")
      1|  111|        
      1|  112|        let previewEventModePrint = PPEventModeHelpers.previewEventModeFromEventMode(PPEventMode.Print)
      1|  113|        XCTAssertTrue(previewEventModePrint == PreviewEventMode.Print, "PPEventMode.Print should convert to PPEventMode.Print")
      1|  114|        
      1|  115|        let unsupportedEventModeShouldDefaultToOnline = PPEventModeHelpers.previewEventModeFromEventMode(PPEventMode.Crane)
      1|  116|        XCTAssertTrue(unsupportedEventModeShouldDefaultToOnline == PreviewEventMode.Online, "Unsupported event modes should convert to PPEventMode.Online")
      1|  117|    }
       |  118|    
       |  119|    
      1|  120|    func testItCorrectlyDeterminesIfItIsPrint() {
      1|  121|        
      1|  122|        let eventDetails = PPEventDetails.createEntity() as! PPEventDetails
      1|  123|        
      1|  124|        eventDetails.eventModeValue = .Print
      1|  125|        XCTAssertTrue(eventDetails.isPrintable == true, "An event with mode print should be print based")
      1|  126|        
      1|  127|        let eventDetailsCrane = PPEventDetails.createEntity() as! PPEventDetails
      1|  128|        eventDetailsCrane.eventModeValue = .Crane
      1|  129|        XCTAssertTrue(eventDetailsCrane.isPrintable == true, "An event with mode print should be print based")
      1|  130|        
      1|  131|        let eventDetailsOnline = PPEventDetails.createEntity() as! PPEventDetails
      1|  132|        eventDetailsOnline.eventModeValue = .Online
      1|  133|        XCTAssertTrue(eventDetailsOnline.isPrintable == false, "An event with mode online should not be print based")
      1|  134|        
      1|  135|        let eventDetailsUndefined = PPEventDetails.createEntity() as! PPEventDetails
      1|  136|        eventDetailsUndefined.eventModeValue = .Undefined
      1|  137|        XCTAssertTrue(eventDetailsUndefined.isPrintable == false, "An event with mode undefined should not be print based")
      1|  138|    }
       |  139|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPEventPagePhotosHeaderInactiveTests.swift:
       |    1|//
       |    2|//  PPEventPagePhotosHeaderInactiveTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 10/6/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|import PaperlessPost
       |   12|
       |   13|class PPEventPagePhotosHeaderInactiveTests: FBSnapshotTestCase {
       |   14|
      1|   15|    override func setUp() {
      1|   16|        super.setUp()
      1|   17|        self.recordMode = false
      1|   18|    }
       |   19|
      1|   20|    func testItRendersCorrectly() {
      1|   21|        let header = PPEventPagePhotosHeaderInactive(frame: CGRect(x: 0, y: 0, width: 300, height: 44))
      1|   22|        header.text = "View the Photo Gallery"
      1|   23|        header.backgroundColor = UIColor.whiteColor()
      1|   24|        FBSnapShotVerifyView(header, identifier: nil)
      1|   25|    }
       |   26|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPEventPagePhotosHeaderTests.swift:
       |    1|//
       |    2|//  PPEventPagePhotosHeaderTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 10/3/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|@available(iOS 8.0, *)
       |   13|class PPEventPagePhotosHeaderTests: FBSnapshotTestCase {
       |   14|
      3|   15|    override func setUp() {
      3|   16|        super.setUp()
      3|   17|        self.recordMode = false
      3|   18|        //Disable all UIView animations, as some things fade in alpha
      3|   19|        UIView.setAnimationsEnabled(false)
      3|   20|    }
       |   21|    
      3|   22|    override func tearDown() {
      3|   23|        super.tearDown()
      3|   24|        UIView.setAnimationsEnabled(true)
      3|   25|    }
       |   26|
      1|   27|    func testVerifyingTheViewWhenItHasAnImage() {
      1|   28|        
      1|   29|        let container = UIView(frame: CGRectMake(0, 0, 320, 180))
      1|   30|        container.backgroundColor = UIColor.whiteColor()
      1|   31|        
      1|   32|        let photoHeader = PPEventPagePhotosHeader(frame: CGRectMake(0, 0, 320, 140))
      1|   33|        photoHeader.borderInsets = UIEdgeInsetsMake(15, 15, 15, 15);
      1|   34|        photoHeader.coverPhotoImage = UIImage(named: "sample-image-believe.jpg", inBundle: NSBundle(forClass: PPEventPagePhotosHeaderTests.self), compatibleWithTraitCollection: nil)
      1|   35|        photoHeader.headerText = "Such photo! Many smile! wow"
      1|   36|        
      1|   37|        container.addSubview(photoHeader)
      1|   38|
      1|   39|        FBSnapShotVerifyView(container, identifier:nil)
      1|   40|    }
       |   41|    
      1|   42|    func testItRendersMultiLineTextCorrectly() {
      1|   43|        let container = UIView(frame: CGRectMake(0, 0, 320, 180))
      1|   44|        container.backgroundColor = UIColor.whiteColor()
      1|   45|        
      1|   46|        let photoHeader = PPEventPagePhotosHeader(frame: CGRectMake(0, 0, 320, 140))
      1|   47|        photoHeader.borderInsets = UIEdgeInsetsMake(15, 15, 15, 15);
      1|   48|        photoHeader.coverPhotoImage = UIImage(named: "sample-image-believe.jpg", inBundle: NSBundle(forClass: PPEventPagePhotosHeaderTests.self), compatibleWithTraitCollection: nil)
      1|   49|        photoHeader.headerText = "Such photo! Many smile! wow This has much multi line and should overflow to some extent wow! what lines. many text. overflowz. how low can i goez. many line must elipse. one such more linez. where does i end. ok seriously how much text do i have to type here"
      1|   50|        
      1|   51|        container.addSubview(photoHeader)
      1|   52|        
      1|   53|        FBSnapShotVerifyView(container, identifier:nil)
      1|   54|
      1|   55|    }
       |   56|    
      1|   57|    func testVerifyingTheViewWhenItHasNoImage() {
      1|   58|        
      1|   59|        let container = UIView(frame: CGRectMake(0, 0, 320, 180))
      1|   60|        container.backgroundColor = UIColor.whiteColor()
      1|   61|
      1|   62|        let photoHeader = PPEventPagePhotosHeader(frame: CGRectMake(0, 0, 320, 140))
      1|   63|        photoHeader.borderInsets = UIEdgeInsetsMake(15, 15, 15, 15);
      1|   64|        photoHeader.headerText = "None photos. only frown"
      1|   65|        
      1|   66|        container.addSubview(photoHeader)
      1|   67|        FBSnapShotVerifyView(container, identifier:nil)
      1|   68|    }
       |   69|}
       |   70|

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPEventSegmentedControlleriPadTests.swift:
       |    1|//
       |    2|//  PPEventSegmentedControlleriPadTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 8/3/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|import PaperlessPost
       |   11|
       |   12|typealias EventSegmentedControlleriPadData = (controller : PPEventSegmentedController_iPad, currentIndex: Int)
       |   13|
       |   14|class PPEventSegmentedControlleriPadTests : XCTestCase {
       |   15|    
       |   16|    var controller : PPEventSegmentedController_iPad = PPEventSegmentedController_iPad()
       |   17|    
      2|   18|    override func setUp() {
      2|   19|        super.setUp()
      2|   20|        let data = self.setupControllerWithNumberOfViewControllers(2)
      2|   21|        controller = data.controller
      2|   22|    }
       |   23|    
      2|   24|    override func tearDown() {
      2|   25|        // Put teardown code here. This method is called after the invocation of each test method in the class.
      2|   26|        super.tearDown()
      2|   27|    }
       |   28|    
      1|   29|    func testCurrentIndexInitiallyIsZero() {
      1|   30|        // given
      1|   31|        
      1|   32|        // when
      1|   33|        
      1|   34|        // where
      1|   35|        XCTAssertEqual(controller.selectedIndex, 0, "Index should initially point to zero.")
      1|   36|    }
       |   37|    
      1|   38|    func testCurrentIndexShouldKeepPointingToEquivalentInstance() {
      1|   39|        // given
      1|   40|        let data: EventSegmentedControlleriPadData = self.setupControllerWithNumberOfViewControllers(2)
      1|   41|        controller = data.controller
      1|   42|        controller.selectedIndex = data.currentIndex
      1|   43|        
      1|   44|        if let vc = controller.selectedViewController {
      1|   45|            XCTAssertTrue((controller.selectedIndex >= 0 && controller.selectedIndex < controller.viewControllers.count), "selectedIndex should be in the range [0, n-1]")
      1|   46|            XCTAssertTrue(vc.isKindOfClass(MyViewController), "Selected Controller should be of the correct class type")
      0|   47|        } else {
      0|   48|            XCTFail("controller.selectedController should not be nil for this test.")
      0|   49|        }        
      1|   50|  
      1|   51|        // when
      1|   52|        controller.viewControllers = utilDataWithNumberOfViewControllers(3).viewControllers
      1|   53|        
      1|   54|        // where
      1|   55|        if let selectedViewController = controller.selectedViewController {
      1|   56|            XCTAssertTrue(selectedViewController.isKindOfClass(MyViewController), "The selected controller should be an instance of the correct class")
      0|   57|        } else {
      0|   58|            XCTFail("controller.selectedController should not be nil for this test.")
      0|   59|        }
      1|   60|    }
       |   61|    
       |   62|    // MARK: Setup and Util methods
       |   63|    
      3|   64|    func setupControllerWithNumberOfViewControllers(numControllers : Int) -> EventSegmentedControlleriPadData {
      3|   65|        let data = utilDataWithNumberOfViewControllers(numControllers)
      3|   66|        let controller : PPEventSegmentedController_iPad = PPEventSegmentedController_iPad()
      3|   67|        controller.viewControllers = data.viewControllers
      3|   68|        return (controller, data.currentIndex)
      3|   69|    }
       |   70|    
      4|   71|    func utilDataWithNumberOfViewControllers(numControllers: Int) -> SegmentedControllerViewData {
      4|   72|        
      4|   73|        let selectedIndex = Int.random(1...numControllers)
      4|   74|        
      4|   75|        var viewControllers : [UIViewController] = [UIViewController]()
      4|   76|        var controlItems : [String] = [String]()
      9|   77|        for index in 1...numControllers {
      5|   78|            let instance = (index == selectedIndex) ? MyViewController() : UIViewController()
      9|   79|            viewControllers.append(instance)
      9|   80|            controlItems.append(String(index))
      9|   81|        }
      4|   82|        
      4|   83|        return (viewControllers, controlItems, selectedIndex - 1)
      4|   84|    }
       |   85|}
       |   86|
       |   87|class MyViewController : UIViewController {
       |   88|    // Empty class...
       |   89|}
       |   90|

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPNavigatorAuthenticationModalTests.swift:
       |    1|//
       |    2|//  PPNavigatorTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 9/24/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|import Foundation
       |   11|
       |   12|typealias ClosureType = (PPAPIRequest!) -> Void
       |   13|
       |   14|// MARK: Authentication Modal Tests
       |   15|
       |   16|class PPNavigatorAuthenticationModalTests: XCTestCase {
       |   17|
       |   18|    // Corresponds to PPNavigator(Navigation) showEventWithID:recordType:showReplyCard:
       |   19|
      1|   20|    func testAuthModalFromShowEvent() {
      1|   21|
      1|   22|        class TestableNavigatorForEventShowing : PPNavigatorDouble {
      0|   23|            let dummyBlock: ClosureType = { _ in }
      1|   24|
      1|   25|            @objc override func showEventWithID(eventID: String!, recordType: PPRecordType, showReplyCard replyCard: Bool) -> UIViewController! {
      1|   26|                // Make the call to the present authentication view controller
      1|   27|                let caller = self.primaryViewController
      1|   28|                self.presentAuthenticationModalFromViewController(caller, authenticationArea: .More, withCompletionBlock: dummyBlock)
      1|   29|                // return value is of no consequence to the test.
      1|   30|                return UIViewController()
      1|   31|            }
      1|   32|        }
      1|   33|
      1|   34|        let sut = TestableNavigatorForEventShowing()
      1|   35|        let anyReplyCardValue = false
      1|   36|        let anyRecordType = PPRecordType.Undefined
      1|   37|        sut.showEventWithID("ID not Important", recordType: anyRecordType, showReplyCard: anyReplyCardValue)
      1|   38|
      0|   39|        if let event = sut.capturedEvent {
      0|   40|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      0|   41|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.More])
      1|   42|        } else {
      1|   43|            XCTFail("PPNavigator should had captured an event.")
      1|   44|        }
      1|   45|    }
       |   46|
       |   47|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPOrderDetailChangeQuantityTableViewCellTests.swift:
       |    1|//
       |    2|//  PPOrderDetailChangeQuantityTableViewCellTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 9/25/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|@available(iOS 8.0, *)
       |   13|class PPOrderDetailChangeQuantityTableViewCellTests: FBSnapshotTestCase {
       |   14|    
       |   15|    private var sizingCell = PPOrderDetailChangeQuantityTableViewCell()
       |   16|    let widthCondensed: CGFloat = 320
       |   17|    let widthExpanded: CGFloat = 500
       |   18|    
      3|   19|    override func setUp() {
      3|   20|        super.setUp()
      3|   21|        self.recordMode = false
      3|   22|    }
       |   23|    
      1|   24|    func testItSizesCorrectlyWithAllOptions() {
      1|   25|        resetCell(sizingCell)
      1|   26|        
      1|   27|        reframeCell(sizingCell, width: widthCondensed)
      1|   28|        FBSnapShotVerifyView(sizingCell, identifier: "Cell with all options")
      1|   29|        
      1|   30|        sizingCell.cellStyle = PPOrderDetailQuantityCellStyle.Expanded;
      1|   31|        reframeCell(sizingCell, width: widthExpanded)
      1|   32|        FBSnapShotVerifyView(sizingCell, identifier: "Cell with all options - Expanded (iPad)")
      1|   33|        sizingCell.cellStyle = PPOrderDetailQuantityCellStyle.Compact;
      1|   34|    }
       |   35|    
      1|   36|    func testItSizesCorrectlyWithNoSubtitle() {
      1|   37|        resetCell(sizingCell)
      1|   38|        
      1|   39|        //Remove subtitle
      1|   40|        sizingCell.subtitleText = nil
      1|   41|        reframeCell(sizingCell, width: widthCondensed)
      1|   42|        FBSnapShotVerifyView(sizingCell, identifier: "Cell with no subtitle")
      1|   43|        
      1|   44|        sizingCell.cellStyle = PPOrderDetailQuantityCellStyle.Expanded;
      1|   45|        reframeCell(sizingCell, width: widthExpanded)
      1|   46|        FBSnapShotVerifyView(sizingCell, identifier: "Cell with no subtitle - Expanded (iPad)")
      1|   47|        sizingCell.cellStyle = PPOrderDetailQuantityCellStyle.Compact;
      1|   48|    }
       |   49|    
      1|   50|    func testItSizesCorrectlyWithNoSubtitleOrRadioButton() {
      1|   51|        resetCell(sizingCell)
      1|   52|
      1|   53|        //Remove radio buttons
      1|   54|        sizingCell.subtitleText = nil
      1|   55|        sizingCell.radioButtonTitles = nil
      1|   56|        reframeCell(sizingCell, width: widthCondensed)
      1|   57|        FBSnapShotVerifyView(sizingCell, identifier: "Cell with no subtitle or radio buttons")
      1|   58|        
      1|   59|        sizingCell.cellStyle = PPOrderDetailQuantityCellStyle.Expanded;
      1|   60|        reframeCell(sizingCell, width: widthExpanded)
      1|   61|        FBSnapShotVerifyView(sizingCell, identifier: "Cell with no subtitle or radio buttons - Expanded (iPad)")
      1|   62|    }
       |   63|    
       |   64|    
       |   65|    //MARK: Helper Funcs
       |   66|    
      6|   67|    func calculateReccomendedHeight(cell: PPOrderDetailChangeQuantityTableViewCell, width: CGFloat) -> CGFloat {
      6|   68|        return PPOrderDetailChangeQuantityTableViewCell.reccomendedHeightWithStyle(cell.cellStyle, mainTitle: cell.primaryDescription, subtitle: cell.subtitleText, radioButtonTitles: cell.radioButtonTitles, constrainedToWidth: width)
      6|   69|    }
       |   70|    
      6|   71|    func reframeCell(cell: PPOrderDetailChangeQuantityTableViewCell, width: CGFloat) {
      6|   72|        let height = calculateReccomendedHeight(cell, width: width)
      6|   73|        cell.frame = CGRect(x: 0, y: 0, width: width, height: height)
      6|   74|    }
       |   75|    
      3|   76|    func resetCell(cell: PPOrderDetailChangeQuantityTableViewCell) {
      3|   77|        cell.backgroundColor = UIColor.whiteColor()
      3|   78|        
      3|   79|        cell.primaryDescription = "Primary Card 5.5"
      3|   80|        cell.subtitleText = "*Single card orders come with a plain white envelope"
      3|   81|        cell.radioButtonTitles = ["Single Thick (16pt)", "Double Thick (32 pt) + $0.70 Ea.", "Folding Card + $0.99"]
      3|   82|        let frontImage =  UIImage(named: "test_image_paper-front-0_001.jpg", inBundle: NSBundle(forClass: PPOrderDetailChangeQuantityTableViewCellTests.self), compatibleWithTraitCollection: nil)
      3|   83|        let backImage =  UIImage(named: "test_image_paper-back-0_001.jpg", inBundle: NSBundle(forClass: PPOrderDetailChangeQuantityTableViewCellTests.self), compatibleWithTraitCollection: nil)
      3|   84|        
      3|   85|        cell.thumbnailImageView!.image = frontImage
      3|   86|        cell.secondaryThumbnailImageView!.image = backImage
      3|   87|        cell.updateDropDownViewWithString("Single Card - $5.00 Includes Something Else")
      3|   88|    }
       |   89|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPOrderManagerTests.swift:
       |    1|//
       |    2|//  PPOrderManagerTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 9/30/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|@available(iOS 8.0, *)
       |   13|class PPOrderManagerTests: XCTestCase {
       |   14|
      1|   15|    func testUpdatingOrders() {
      1|   16|        
      1|   17|        let orderManager = MockPPOrderManager(eventID: "123", setupCompletion: nil)
      1|   18|        orderManager.setPricings(PPFixtureFactory.PaperFixtures.PricingFixture)
      1|   19|        XCTAssertTrue(orderManager.total == 0, "When setting up an order manager, the inital price should be zero")
      1|   20|        
      1|   21|        //Find a pricing and update
      1|   22|        var postOrderLineItem = orderManager.postOrder.lineItems[0] as! PPPOSTOrderLineItem
      1|   23|        
      1|   24|        let pricing = orderManager.pricingForCardSideID(postOrderLineItem.cardSideID)
      1|   25|        let pricingQuantity200 = pricing.pricingForQuantity(200)
      1|   26|        XCTAssertNotNil(pricingQuantity200, "Should not be nil in tests")
      1|   27|        
      1|   28|        orderManager.updateLineItem(postOrderLineItem, withPricing: pricingQuantity200)
      1|   29|        
      1|   30|        //Refetch the line item, assert price is correct
      1|   31|        postOrderLineItem = orderManager.postOrder.lineItemWithCardSideID(postOrderLineItem.cardSideID)
      1|   32|        XCTAssertTrue(postOrderLineItem.quantity == 200, "The quantity of the updated postorder line item should be 200 after updating it")
      1|   33|        
      1|   34|        XCTAssertTrue(orderManager.total == postOrderLineItem.totalCostCents(), "The price of the entire order should equal 200")
      1|   35|        
      1|   36|        //Update all items to quantity 100
      1|   37|        orderManager.updateAllLineItemsToQuantity(100)
      2|   38|        for lineItem in orderManager.postOrder.lineItems as! [PPPOSTOrderLineItem]! {
      2|   39|            XCTAssertTrue(lineItem.quantity == 100, "The quantity of all items after updatingAll to 100 should be 100")
      2|   40|        }
      1|   41|    }
       |   42|    
       |   43|    
      1|   44|    func testSingleSKUFunctionalityAutomaticallyWorks() {
      1|   45|        
      1|   46|        let orderManager = MockPPOrderManager(eventID: "123", setupCompletion: nil)
      1|   47|        orderManager.setPricings(PPFixtureFactory.PaperFixtures.PricingFixture)
      1|   48|        
      1|   49|        //Find a pricing and update to 1 (single/keepsake)
      1|   50|        var postOrderLineItem = orderManager.postOrder.lineItems[0] as! PPPOSTOrderLineItem
      1|   51|        let currentSKU = postOrderLineItem.sku
      1|   52|        
      1|   53|        let pricing = orderManager.pricingForCardSideID(postOrderLineItem.cardSideID)
      1|   54|        let pricingQuantity1 = pricing.pricingForQuantity(1)
      1|   55|        XCTAssertNotNil(pricingQuantity1, "Should not be nil in tests")
      1|   56|        
      1|   57|        //Verify the first item is not currently a single item to start
      1|   58|        let firstLineItem = orderManager.postOrder.lineItems[0] as! PPPOSTOrderLineItem
      1|   59|        XCTAssertTrue(firstLineItem.quantity != 1, "First item shouldn't already be a single card, otherwise test logic is flawed");
      1|   60|        
      1|   61|        //Update
      1|   62|        orderManager.updateLineItem(postOrderLineItem, withPricing: pricingQuantity1)
      1|   63|        
      1|   64|        //Check that the SKU is different, and is one of the keep sake skus
      1|   65|        postOrderLineItem = orderManager.postOrder.lineItemWithCardSideID(postOrderLineItem.cardSideID)
      1|   66|        XCTAssertTrue(postOrderLineItem.sku.skuID !== currentSKU.skuID, "After setting the quantity to 1 (singlecard/keepsake) the SKUs should automatically be swapped for single card SKUs")
      1|   67|        
      1|   68|        var newSKUs = orderManager.skusForLineItemWithCardSideID(postOrderLineItem.cardSideID) as! [PPPricingSKU]
      1|   69|        
      3|   70|        for aSKU in newSKUs {
      3|   71|            XCTAssertTrue(aSKU.isKeepSake, "All skus fetched for cardSide should now be keepsake skus")
      3|   72|        }
      1|   73|        
      1|   74|        //Switch back away from keepsake
      1|   75|        let pricingQuantity200 = pricing.pricingForQuantity(200)
      1|   76|        orderManager.updateLineItem(postOrderLineItem, withPricing: pricingQuantity200)
      1|   77|        
      1|   78|        newSKUs = orderManager.skusForLineItemWithCardSideID(postOrderLineItem.cardSideID) as! [PPPricingSKU]
      3|   79|        for aSKU in newSKUs {
      3|   80|            XCTAssertTrue(aSKU.isKeepSake == false, "All skus fetched for cardSide should no longer be keepsake SKUs")
      3|   81|        }
      1|   82|        
      1|   83|        //Test update all functionality also properly handles keepsakes
      1|   84|        orderManager.updateAllLineItemsToQuantity(1)
      1|   85|        newSKUs = orderManager.skusForLineItemWithCardSideID(postOrderLineItem.cardSideID) as! [PPPricingSKU]
      3|   86|        for aSKU in newSKUs {
      3|   87|            XCTAssertTrue(aSKU.isKeepSake, "All skus fetched for cardSide should now be keepsake skus")
      3|   88|        }
      1|   89|       
      1|   90|        
      1|   91|        orderManager.updateAllLineItemsToQuantity(1)
      1|   92|        newSKUs = orderManager.skusForLineItemWithCardSideID(postOrderLineItem.cardSideID) as! [PPPricingSKU]
      3|   93|        for aSKU in newSKUs {
      3|   94|            XCTAssertTrue(aSKU.isKeepSake, "All skus fetched for cardSide should now be keepsake skus")
      3|   95|        }
      1|   96|        
      1|   97|        for lineItem in orderManager.postOrder.lineItems as! [PPPOSTOrderLineItem] {
      1|   98|            XCTAssertTrue(lineItem.sku.isKeepSake, "All skus fetched for cardSide should now be keepsake skus")
      1|   99|        }
      1|  100|        
      1|  101|    }
       |  102|    
      1|  103|    func testPricingWorksCorrectly() {
      1|  104|        
      1|  105|        let orderManager = MockPPOrderManager(eventID: "123", setupCompletion: nil)
      1|  106|        orderManager.setPricings(PPFixtureFactory.PaperFixtures.PricingFixture)
      1|  107|        
      1|  108|        orderManager.updateAllLineItemsToQuantity(200)
      1|  109|        
      1|  110|        var totalPrice = 0
      2|  111|        for lineItem in orderManager.postOrder.lineItems as! [PPPOSTOrderLineItem] {
      2|  112|            totalPrice += lineItem.totalCostCents()
      2|  113|        }
      1|  114|        
      1|  115|        let dollarAmount = Double(totalPrice/100)
      1|  116|        XCTAssertTrue(totalPrice == orderManager.total, "The total price is not being calculated correctly. Expected \(totalPrice) but got \(orderManager.total) instead")
      1|  117|        XCTAssertTrue(dollarAmount == orderManager.totalDollars,  "The total dollar amount is not being calculated correctly. Expected \(dollarAmount) but got \(orderManager.totalDollars) instead")
      1|  118|    }
       |  119|}
       |  120|
       |  121|
       |  122|//MARK: Helpers and Mock objects
       |  123|
       |  124|class MockPPOrderManager : PPOrderManager {
       |  125|    
      3|  126|    override func reloadPricing(completion: ((PPOrderManager!) -> Void)!) {
      3|  127|        //Do nothing, prevent network activity
      3|  128|    }
       |  129|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPPOSTOrderTests.swift:
       |    1|//
       |    2|//  PPPOSTOrderTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 9/22/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|class PPPOSTOrderTests: XCTestCase {
       |   13|
      1|   14|    func testAddingAndUpdatingLineItems() {
      1|   15|
      1|   16|        let postOrder = PPPOSTOrder()
      1|   17|        
      1|   18|        let cardSideID1 = 123
      1|   19|        let lineItem1 = PPPostOrderTestsHelper.lineItem(cardSideID1)
      1|   20|        
      1|   21|        postOrder.addNewLineItem(lineItem1)
      1|   22|        
      1|   23|        XCTAssertTrue(postOrder.lineItems.count == 1, "Post order should contain only 1 line item")
      1|   24|        
      1|   25|        postOrder.addNewLineItem(lineItem1)
      1|   26|        
      1|   27|        XCTAssertTrue(postOrder.lineItems.count == 1, "Attempting to add the same line item twice should replace the existing")
      1|   28|        
      1|   29|        let updatedDescription = "A new fake appears! This should have different text"
      1|   30|        let updatedLineItem1 = PPPostOrderTestsHelper.lineItem(cardSideID1)
      1|   31|        updatedLineItem1.itemDescription = updatedDescription
      1|   32|
      1|   33|        postOrder.updateLineItem(updatedLineItem1)
      1|   34|        
      1|   35|        XCTAssertTrue(postOrder.lineItems.count == 1, "After updating a line item with an identical ID, the order should replace the existing")
      1|   36|        
      1|   37|        let fetchedLineItem = postOrder.lineItemWithCardSideID(cardSideID1)
      1|   38|        XCTAssertTrue(fetchedLineItem.itemDescription == updatedDescription, "Updating an item should replace it entirely")
      1|   39|    }
       |   40|    
      1|   41|    func testRemovingLineItems() {
      1|   42|        
      1|   43|        let postOrder = PPPOSTOrder()
      1|   44|        let lineItem1 = PPPostOrderTestsHelper.lineItem(123)
      1|   45|        postOrder.addNewLineItem(lineItem1)
      1|   46|        
      1|   47|        XCTAssertTrue(postOrder.lineItems.count == 1, "Post order should contain only 1 line item")
      1|   48|
      1|   49|        postOrder.removeLineItem(lineItem1)
      1|   50|        
      1|   51|        XCTAssertTrue(postOrder.lineItems.count == 0, "Post order should contain zero line items after removing them")
      1|   52|    }
       |   53|    
      1|   54|    func testIndexingWorks() {
      1|   55|        
      1|   56|        let postOrder = PPPOSTOrder()
      1|   57|        
      1|   58|        let lineItem1 = PPPostOrderTestsHelper.lineItem(123)
      1|   59|        
      1|   60|        let index = postOrder.addNewLineItem(lineItem1)
      1|   61|        XCTAssertTrue(index == 0, "When adding the first lineItem to an order, it's index should be zero")
      1|   62|        
      1|   63|        let lineItem2 = PPPostOrderTestsHelper.lineItem(567)
      1|   64|        let index2 = postOrder.addNewLineItem(lineItem2)
      1|   65|        XCTAssertTrue(index2 == 1, "The second item added should have an index of 1")
      1|   66|        
      1|   67|        let removeIndex0 = postOrder.removeLineItem(lineItem1)
      1|   68|        XCTAssertTrue(removeIndex0 == 0, "When removing the item at the first index, the returned index should be 0 because that is where it was")
      1|   69|        
      1|   70|        let newIndexOfSecondItem = postOrder.indexOfLineItem(lineItem2)
      1|   71|        XCTAssertTrue(newIndexOfSecondItem == 0, "The new index of the second line item should be zero once we remove the other item")
      1|   72|        
      1|   73|        let indexOfRemovedItem = postOrder.indexOfLineItem(lineItem1)
      1|   74|                
      1|   75|        let indexSigned = Int(indexOfRemovedItem)
      1|   76|        XCTAssertTrue(indexSigned == NSNotFound, "Index of removed item should return NSNotFound")
      1|   77|    }
       |   78|    
      1|   79|    func testPricesAreAddedCorrectly() {
      1|   80|        
      1|   81|        let firstTotalPrice = 7000
      1|   82|        let secondTotalPrice = 5500
      1|   83|        
      1|   84|        let finalPriceCents = 12500
      1|   85|        let finalPriceDollars = 125.00
      1|   86|        
      1|   87|        let postOrder = PPPOSTOrder()
      1|   88|
      1|   89|        let price70Cents = PPPricingPrice()
      1|   90|        price70Cents.quantity = 100
      1|   91|        price70Cents.unitPrice = 70
      1|   92|        price70Cents.price = firstTotalPrice
      1|   93|        let lineItem70Cents = PPPOSTOrderLineItem(cardSideID: 1, cardNum: 0, sideType: "paper", price: price70Cents, sku: nil, description: "7 dollars")
      1|   94|        
      1|   95|        postOrder.addNewLineItem(lineItem70Cents)
      1|   96|        
      1|   97|        XCTAssertTrue(postOrder.totalPrice() == 7000, "The post order's total price should equal 7000 cents")
      1|   98|        XCTAssertTrue(postOrder.totalPriceDollars() == 70, "The post order's total price in dollars should equal 70")
      1|   99|        
      1|  100|        let price50Cents = PPPricingPrice()
      1|  101|        price50Cents.quantity = 100
      1|  102|        price50Cents.unitPrice = 55
      1|  103|        price50Cents.price = secondTotalPrice
      1|  104|        let lineItem50Cents = PPPOSTOrderLineItem(cardSideID: 2, cardNum: 0, sideType: "paper", price: price50Cents, sku: nil, description: "55 dollars")
      1|  105|        
      1|  106|        postOrder.addNewLineItem(lineItem50Cents)
      1|  107|        
      1|  108|        XCTAssertTrue(finalPriceCents == postOrder.totalPrice(), "The total price aftering adding up line items should equal \(finalPriceCents)")
      1|  109|        
      1|  110|        XCTAssertTrue(finalPriceDollars == postOrder.totalPriceDollars(), "The total price in dollars should equal up to \(finalPriceDollars)")
      1|  111|    }
       |  112|    
      1|  113|    func testItHasCorrectQuantities() {
      1|  114|
      1|  115|        let quantity1 = 100
      1|  116|        let quantity2 = 160
      1|  117|        let finalquantity = quantity1 + quantity2
      1|  118|        
      1|  119|        let postOrder = PPPOSTOrder()
      1|  120|
      1|  121|        let priceQuantity100 = PPPricingPrice()
      1|  122|        priceQuantity100.quantity = quantity1
      1|  123|        let lineItem100 = PPPOSTOrderLineItem(cardSideID: 1, cardNum: 0, sideType: "paper", price: priceQuantity100, sku: nil, description: "100")
      1|  124|        postOrder.addNewLineItem(lineItem100)
      1|  125|        XCTAssertTrue(postOrder.totalQuantity == quantity1, "Should have a quantity of \(quantity1)")
      1|  126|        
      1|  127|        let priceQuantity160 = PPPricingPrice()
      1|  128|        priceQuantity160.quantity = quantity2
      1|  129|        let lineItem160 = PPPOSTOrderLineItem(cardSideID: 2, cardNum: 0, sideType: "paper", price: priceQuantity160, sku: nil, description: "160")
      1|  130|        postOrder.addNewLineItem(lineItem160)
      1|  131|        XCTAssertTrue(postOrder.totalQuantity == finalquantity, "Should have a quantity of \(finalquantity)")
      1|  132|
      1|  133|        postOrder.removeLineItem(lineItem100)
      1|  134|        XCTAssertTrue(postOrder.totalQuantity == quantity2, "After removing a line item, it should have a quantity of \(quantity2)")
      1|  135|    }
       |  136|    
      1|  137|    func testItHasFoldingCards() {
      1|  138|        
      1|  139|        let postOrder = PPPOSTOrder()
      1|  140|        
      1|  141|        let foldingSKUId = PPPricingSKU.knownFoldingCardSKUIDs().first as! Int
      1|  142|        let foldingSKU = PPPricingSKU(SKUID: foldingSKUId, readableText: "A folding SKU", price: 12345)
      1|  143|        XCTAssertTrue(foldingSKU.isFoldingCardSKU(), "The sku should evaluate to true since it is a folding card sku")
      1|  144|        
      1|  145|        let price = PPPricingPrice(quantity: 100, text: nil, price: 100, unitPrice: 100)
      1|  146|        
      1|  147|        let lineItem = PPPOSTOrderLineItem(cardSideID: 1, cardNum: 0, sideType: "paper", price: price, sku: foldingSKU, description: "100")
      1|  148|
      1|  149|        postOrder.addNewLineItem(lineItem)
      1|  150|        XCTAssertTrue(postOrder.containsFoldingCardItems(), "The order should return true when it contains a folding card item")
      1|  151|    }
       |  152|}
       |  153|
       |  154|
       |  155|class PPPostOrderTestsHelper {
       |  156|    
      5|  157|    class func lineItem(cardID: Int) -> PPPOSTOrderLineItem {
      5|  158|        let cardSideID1 = cardID
      5|  159|        let pricing = PPPricingPrice()
      5|  160|        let lineItem1 = PPPOSTOrderLineItem(cardSideID: cardSideID1, cardNum: 0, sideType: "paper", price: pricing, sku: nil, description: "A fake!")
      5|  161|        return lineItem1
      5|  162|    }
       |  163|    
       |  164|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPPackagePricingWebViewControllerAnalyticsTests.swift:
       |    1|//
       |    2|//  PPPackagePricingWebViewControllerAnalyticsTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 10/5/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|
       |   11|// MARK: Unit Test
       |   12|
       |   13|class PPPackagePricingWebViewControllerAnalyticsTests: XCTestCase {
       |   14|
      1|   15|    func testCoinInformationModalHasCorrectMixpanelEvent() {
      1|   16|
      1|   17|        // GIVEN
      1|   18|        let spy = AnalyticsProviderSpy()
      1|   19|        let mode = PPPackagePricingWebViewControllerMode.Online
      1|   20|        let viewController = PPPackagePricingWebViewController(packageID: 12, mode: mode)
      1|   21|        viewController.analyticsProvider = spy
      1|   22|
      1|   23|        // WHEN
      1|   24|        viewController.viewDidLoad()
      1|   25|
      1|   26|        // WHERE
      0|   27|        guard let event = spy.capturedEvent else {
      0|   28|            XCTFail("event was not triggered."); return
      0|   29|        }
      1|   30|
      1|   31|        XCTAssertEqual(event.dynamicType.analyticsEventName(), ExpectedValues.EventNames.BrowseCards)
      1|   32|        XCTAssertEqual(event.packagePricingValue(), ExpectedValues.BrowseCardStep.ViewPricingInfo)
      1|   33|        XCTAssertEqual(event.infoTypeValue(), ExpectedValues.InfoType.Coins)
      1|   34|    }
       |   35|
      1|   36|    func testPaperInformationModalHasCorrectMixpanelEvent() {
      1|   37|
      1|   38|        // GIVEN
      1|   39|        let spy = AnalyticsProviderSpy()
      1|   40|        let mode = PPPackagePricingWebViewControllerMode.Print
      1|   41|        let viewController = PPPackagePricingWebViewController(packageID: 12, mode: mode)
      1|   42|        viewController.analyticsProvider = spy
      1|   43|
      1|   44|        // WHEN
      1|   45|        viewController.viewDidLoad()
      1|   46|
      1|   47|        // WHERE
      0|   48|        guard let event = spy.capturedEvent else {
      0|   49|            XCTFail("Event was not triggered."); return
      0|   50|        }
      1|   51|
      1|   52|        XCTAssertEqual(event.dynamicType.analyticsEventName(), ExpectedValues.EventNames.BrowseCards)
      1|   53|        XCTAssertEqual(event.packagePricingValue(), ExpectedValues.BrowseCardStep.ViewPricingInfo)
      1|   54|        XCTAssertEqual(event.infoTypeValue(), ExpectedValues.InfoType.Paper)
      1|   55|    }
       |   56|}
       |   57|
       |   58|// MARK: Unit Test Expected Values and Event Property Keys
       |   59|
       |   60|extension PPPackagePricingWebViewControllerAnalyticsTests {
       |   61|
       |   62|    private typealias ExpectedValues = CoinPaperInfoModalEventExpectedValues
       |   63|
       |   64|    private struct CoinPaperInfoModalEventExpectedValues {
       |   65|        struct EventNames {
       |   66|            static let BrowseCards = "Browse Cards"
       |   67|        }
       |   68|        struct BrowseCardStep {
       |   69|            static let ViewPricingInfo = "View Pricing Info"
       |   70|        }
       |   71|        struct InfoType {
       |   72|            static let Paper = "paper"
       |   73|            static let Coins = "coins"
       |   74|        }
       |   75|    }
       |   76|
       |   77|    private struct EventPropertyKeys {
       |   78|        static let EventKey = "Event"
       |   79|        static let BrowseCardStep = "browse_card_step"
       |   80|        static let InfoTypeKey = "info_type"
       |   81|    }
       |   82|}
       |   83|
       |   84|// MARK: PPAnalyticsSerializable util methods for exposing event properties
       |   85|
       |   86|extension PPAnalyticsSerializable {
       |   87|
      2|   88|    func packagePricingValue() -> String? {
      2|   89|        return dictionaryRepresentation()[PPPackagePricingWebViewControllerAnalyticsTests.EventPropertyKeys.BrowseCardStep] as? String
      2|   90|    }
       |   91|
      2|   92|    func infoTypeValue() -> String? {
      2|   93|        return dictionaryRepresentation()[PPPackagePricingWebViewControllerAnalyticsTests.EventPropertyKeys.InfoTypeKey] as? String
      2|   94|    }
       |   95|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPPostOrderLineItemTests.swift:
       |    1|//
       |    2|//  PPPostOrderLineItemTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 10/1/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|@available(iOS 8.0, *)
       |   13|class PPPostOrderLineItemTests: XCTestCase {
       |   14|
      1|   15|    func testCostsTotalsAreCalculatedCorrectly() {
      1|   16|
      1|   17|        let pricingPrice = PPPricingPrice(quantity: 100, text: "yolo", price: 7000, unitPrice: 70)
      1|   18|        let pricingSKU = PPPricingSKU(SKUID: 123, readableText: "A fake SKU", price: 25)
      1|   19|        
      1|   20|        
      1|   21|        let anticipatedTotalCost = pricingPrice.price.integerValue + (pricingPrice.quantity.integerValue * pricingSKU.price.integerValue)
      1|   22|        
      1|   23|        let lineItem = PPPOSTOrderLineItem(cardSideID: 123, cardNum: 0, sideType: "paper", price: pricingPrice, sku: pricingSKU, description: "Whoomp there it is")
      1|   24|        
      1|   25|        XCTAssertTrue(lineItem.totalCostCents() == anticipatedTotalCost, "The anticipated cost does not equal the line item's calculated cost")
      1|   26|    }
       |   27|
      1|   28|    func testMergingLineItemsWithPricingWorks() {
      1|   29|        
      1|   30|        var pricings = PPFixtureFactory.PaperFixtures.PricingFixture
      1|   31|        
      1|   32|        let startQuantity = 200
      1|   33|
      1|   34|        let firstPricing = pricings[0]
      1|   35|        let validCardSideID = firstPricing.cardSideID
      1|   36|        
      1|   37|        //Start with an unreasonable price that wouldn't be found in fixture data
      1|   38|        let startPrice = PPPricingPrice(quantity: startQuantity, text: "yolo", price: 999999999, unitPrice: 99999999)
      1|   39|        let startSKU = PPPricingSKU(SKUID: 999999, readableText: "A fake SKU", price: 25)
      1|   40|        // Create the line item with the start price and start SKU
      1|   41|        let lineItem = PPPOSTOrderLineItem(cardSideID: validCardSideID, cardNum: 0, sideType: "paper", price: startPrice, sku: startSKU, description: "Whoomp there it is")
      1|   42|        
      1|   43|        //Merge the fixture pricing into the line item
      1|   44|        let newLineItem = lineItem.lineItemByMergingWithNewPricing(firstPricing)
      1|   45|        
      1|   46|        //Assert the merge was successful
      1|   47|        XCTAssertTrue(newLineItem.price.quantity == startQuantity, "After merging, quantities should be kept the same")
      1|   48|        XCTAssertTrue(newLineItem.price.price.integerValue != lineItem.price.price.integerValue, "After merging, quantities should be the same, but prices, if they have changed, should be updated")
      1|   49|        XCTAssertTrue(newLineItem.skuID !== lineItem.skuID, "After merging, SKU's should only be the same if they can be carried over. If the existing SKU does not existing in the new SKU array, it shoudl be replaced")
      1|   50|        
      1|   51|        XCTAssertNotNil(newLineItem.price, "Price should not be nil after merging")
      1|   52|        XCTAssertNotNil(newLineItem.sku, "Price should not be nil")
      1|   53|    }
       |   54|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPPricingPriceTests.swift:
       |    1|//
       |    2|//  PPPricingPriceTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 9/22/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|import PaperlessPost
       |   12|
       |   13|class PPPricingPriceTests: XCTestCase {
       |   14|
      1|   15|    func testThePrceInDollarsIsCorrectlyCalculated() {
      1|   16|
      1|   17|        let price = PPPricingPrice()
      1|   18|        price.unitPrice = 127
      1|   19|        let expectedPriceInDollarsString = "$1.27"
      1|   20|        let priceInDollars = price.amountForSingleItemInUSDollars()
      1|   21|        
      1|   22|        XCTAssertTrue(priceInDollars == expectedPriceInDollarsString, "The expected price should have output as \(expectedPriceInDollarsString)")
      1|   23|    }
       |   24|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPPricingSkuTests.swift:
       |    1|//
       |    2|//  PPPricingSkuTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 9/12/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|class PPPricingSkuTests: XCTestCase {
       |   13|
      1|   14|    func testItProperlyCalculatesDollars() {
      1|   15|        
      1|   16|        //1.25 dollars
      1|   17|        var pricingSKU = PPPricingSKU(SKUID: nil, readableText: nil, price: 125)
      1|   18|        XCTAssertTrue(pricingSKU.dollars() == 1.25, "Price for the SKU in dollars for 125 cents should be 1.25")
      1|   19|        
      1|   20|        //37.50 dollars
      1|   21|        pricingSKU = PPPricingSKU(SKUID: nil, readableText: nil, price: 3750)
      1|   22|        XCTAssertTrue(pricingSKU.dollars() == 37.50, "Price for the SKU in dollars for 2750 cents should be 37.50")
      1|   23|    }
       |   24|    
      1|   25|    func testTheDescriptionContainsTheCorrectThings() {
      1|   26|        
      1|   27|        var pricingSKU = PPPricingSKU(SKUID: 1234, readableText: "Card 5.5 x 5.5", price: 125)
      1|   28|        
      1|   29|        var description = pricingSKU.descriptionAndPrice()
      1|   30|        
      1|   31|        let dollarString = "\(pricingSKU.dollars())"
      1|   32|        
      1|   33|        _ = NSMakeRange(0, description.lengthOfBytesUsingEncoding(NSUTF8StringEncoding))
      1|   34|        let rangeOfResults = description.rangeOfString(dollarString)
      1|   35|        
      1|   36|        XCTAssertTrue(rangeOfResults != nil, "Description should contain the price in dollars")
      1|   37|        
      1|   38|        //Test descriptions match
      1|   39|        pricingSKU = PPPricingSKU(SKUID: 1234, readableText: "Card 5.5 x 5.5", price: 0)
      1|   40|        description = pricingSKU.descriptionAndPrice()
      1|   41|        XCTAssertTrue(description == pricingSKU.readableText, "When no price is provided, the description should match the readableText")
      1|   42|    }
       |   43|    
      1|   44|    func testFoldingSKUsAreCorrectlyIdentified() {
      1|   45|        
      1|   46|        let sku1 = PPPricingSKU(SKUID: 93204029, readableText: "Not a folding card", price: 123)
      1|   47|        
      1|   48|        XCTAssertFalse(sku1.isFoldingCardSKU(), "This SKU should NOT evaluate as true for being a folding SKU")
      1|   49|        
      1|   50|        var knownFoldingCardSKUs = PPPricingSKU.knownFoldingCardSKUIDs() as! [Int]
      1|   51|        let randomFoldingSKUID = knownFoldingCardSKUs[random() % knownFoldingCardSKUs.count]
      1|   52|        
      1|   53|        let sku2Folding = PPPricingSKU(SKUID: randomFoldingSKUID, readableText: "This is a folding card", price: 3324)
      1|   54|        
      1|   55|        XCTAssertTrue(sku2Folding.isFoldingCardSKU(), "This SKU should evaluate as true for being a folding SKU")
      1|   56|    }
       |   57|    
      1|   58|    func testDollarsAreCalculatedCorrectly() {
      1|   59|        let dollarAmount = 1.33
      1|   60|        let sku = PPPricingSKU(SKUID: 93204029, readableText: "This should cost $1.33", price: 133)
      1|   61|        XCTAssertTrue(dollarAmount == sku.dollars(), "The dollar price should be equal to 1.33")
      1|   62|    }
       |   63|    
       |   64|    
       |   65|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPPricingTests.swift:
       |    1|//
       |    2|//  PPPricingTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 9/19/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|class PPPricingTests: XCTestCase {
       |   13|
      1|   14|    func testRemovingFoldingSKUs() {
      1|   15|        
      1|   16|        let sku1 = PPPricingSKU(SKUID: 93204029, readableText: "Not a folding card", price: 123)
      1|   17|        
      1|   18|        var knownFoldingCardSKUs = PPPricingSKU.knownFoldingCardSKUIDs() as! [Int]
      1|   19|        let randomFoldingSKUID = knownFoldingCardSKUs[random() % knownFoldingCardSKUs.count]
      1|   20|        let sku2Folding = PPPricingSKU(SKUID: randomFoldingSKUID, readableText: "This is a folding card", price: 3324)
      1|   21|        
      1|   22|        let mixedSKUs = [sku1, sku2Folding];
      1|   23|        
      1|   24|        let pricing = PPPricing()
      1|   25|        pricing.skus = mixedSKUs
      1|   26|        
      1|   27|        pricing.removeFoldingCardSKUs()
      1|   28|        
      1|   29|        XCTAssertTrue(pricing.skus.count == 1, "Should only have one SKU left over after removign folding card SKUs")
      1|   30|    
      1|   31|        for aSKU: PPPricingSKU in pricing.skus as! [PPPricingSKU] {
      1|   32|            XCTAssertTrue(aSKU.isFoldingCardSKU() == false, "Remaining SKUs after filtering the pricing should not be folding")
      1|   33|        }
      1|   34|    }
       |   35|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPPrimaryTabBarControllerTabletAuthenticationTests.swift:
       |    1|//
       |    2|//  PPPrimaryTabBarControllerTabletAuthenticationTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 9/28/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|
       |   11|class PPPrimaryTabBarControllerTabletAuthenticationTests : XCTestCase {
       |   12|
       |   13|    // All of these tests correspond to different scenarios for [PPPrimaryTabBarController_iPad -selectedIndex]
       |   14|
       |   15|    // Corresponds to PPPrimaryTabBarController_iPad -newLoginButton
       |   16|    // AKA The Login button that appears on top of the nav bar on iPad.
      1|   17|    func testAuthModalFromiPadTabControllerLoginButton() {
      1|   18|
      0|   19|        guard let navDouble: PPNavigatorDouble! = PPNavigator.currentNavigator() as? PPNavigatorDouble! else {
      0|   20|            XCTFail("The test was not set appropiately."); return
      0|   21|        }
      1|   22|
      1|   23|        let vc = PPPrimaryTabBarController_iPad()
      1|   24|        vc.onLoginButtonTapped()
      1|   25|
      0|   26|        guard let event = navDouble.capturedEvent else {
      0|   27|            XCTFail("PPNavigator should had captured an event."); return
      0|   28|        }
      1|   29|
      1|   30|        XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      1|   31|        XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.TabletMenu])
      1|   32|    }
       |   33|
      1|   34|    func testSelectingHomeIndexShouldNotCaptureEvent() {
      1|   35|
      0|   36|        guard let navDouble:PPNavigatorDouble! = PPNavigator.currentNavigator() as? PPNavigatorDouble! else {
      0|   37|            XCTFail("The test was not set appropiately.")
      0|   38|            return
      0|   39|        }
      1|   40|
      1|   41|        let vc = PPPrimaryTabBarController_iPad()
      1|   42|        vc.selectedIndex = UInt(PPTabBarTabType.HomePage.rawValue)
      1|   43|
      0|   44|        if let event = navDouble.capturedEvent {
      0|   45|            XCTFail("PPNavigator should NOT had captured an event. Captured event: \(event)")
      0|   46|        }
      1|   47|    }
       |   48|
      1|   49|    func testSelectingFavoriteIndexShouldCaptureCorrectEvent() {
      1|   50|
      0|   51|        guard let navDouble:PPNavigatorDouble! = PPNavigator.currentNavigator() as? PPNavigatorDouble! else {
      0|   52|            XCTFail("The test was not set appropiately.")
      0|   53|            return
      0|   54|        }
      1|   55|
      1|   56|        let vc = PPPrimaryTabBarController_iPad()
      1|   57|        vc.selectedIndex = UInt(PPTabBarTabType.Favorites.rawValue)
      1|   58|
      1|   59|        if let event = navDouble.capturedEvent {
      1|   60|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      1|   61|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Favorites])
      0|   62|        } else {
      0|   63|            XCTFail("PPNavigator should had captured an event.")
      0|   64|        }
      1|   65|    }
       |   66|
      1|   67|    func testSelectingPostboxIndexShouldCaptureCorrectEvent() {
      1|   68|
      0|   69|        guard let navDouble:PPNavigatorDouble! = PPNavigator.currentNavigator() as? PPNavigatorDouble! else {
      0|   70|            XCTFail("The test was not set appropiately.")
      0|   71|            return
      0|   72|        }
      1|   73|
      1|   74|        let vc = PPPrimaryTabBarController_iPad()
      1|   75|        vc.selectedIndex = UInt(PPTabBarTabType.Postbox.rawValue)
      1|   76|
      1|   77|        if let event = navDouble.capturedEvent {
      1|   78|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      1|   79|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Postbox])
      0|   80|        } else {
      0|   81|            XCTFail("PPNavigator should had captured an event.")
      0|   82|        }
      1|   83|    }
       |   84|
      1|   85|    func testSelectingSettingsIndexShouldCaptureCorrectEvent() {
      1|   86|
      0|   87|        guard let navDouble:PPNavigatorDouble! = PPNavigator.currentNavigator() as? PPNavigatorDouble! else {
      0|   88|            XCTFail("The test was not set appropiately.")
      0|   89|            return
      0|   90|        }
      1|   91|
      1|   92|        let vc = PPPrimaryTabBarController_iPad()
      1|   93|        vc.selectedIndex = UInt(PPTabBarTabType.Settings.rawValue)
      1|   94|
      1|   95|        if let event = navDouble.capturedEvent {
      1|   96|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      1|   97|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.More])
      0|   98|        } else {
      0|   99|            XCTFail("PPNavigator should had captured an event.")
      0|  100|        }
      1|  101|    }
       |  102|
       |  103|}
       |  104|
       |  105|extension PPPrimaryTabBarControllerTabletAuthenticationTests {
       |  106|
      5|  107|    override func setUp() {
      5|  108|        super.setUp()
      5|  109|
      5|  110|        // Setup Method Swizzling
      5|  111|        do {
      5|  112|            let originalSelector = Selector("navigator")
      5|  113|            let swizzledSelector = Selector("swz_navigator")
      5|  114|            try PPNavigator.swizzleStaticMethodSelector(originalSelector, withSelector: swizzledSelector, forClass: PPNavigator.classForCoder())
      5|  115|
      5|  116|            let usrOriginalSelector = Selector("currentUser")
      5|  117|            let usrSwizzledSelector = Selector("swz_currentUser")
      5|  118|            try PPUser.swizzleStaticMethodSelector(usrOriginalSelector, withSelector: usrSwizzledSelector, forClass: PPUser.classForCoder())
      5|  119|        }
      0|  120|        catch ( SwizzleErrorType.OriginalMethodNotFound ) {
      0|  121|            XCTFail("Original method not found")
      0|  122|        } catch (SwizzleErrorType.SwizzleMethodNotFound) {
      0|  123|            XCTFail("Swizzable method not found")
      0|  124|        } catch _ {
      0|  125|            XCTFail("Unknown error")
      0|  126|        }
      5|  127|    }
       |  128|
      5|  129|    override func tearDown() {
      5|  130|
      5|  131|        // Undo Method Swizzling
      5|  132|        do {
      5|  133|            let originalSelector = Selector("navigator")
      5|  134|            let swizzledSelector = Selector("swz_navigator")
      5|  135|            try PPNavigator.swizzleStaticMethodSelector(originalSelector, withSelector: swizzledSelector, forClass: PPNavigator.classForCoder())
      5|  136|
      5|  137|            let usrOriginalSelector = Selector("currentUser")
      5|  138|            let usrSwizzledSelector = Selector("swz_currentUser")
      5|  139|            try PPUser.swizzleStaticMethodSelector(usrOriginalSelector, withSelector: usrSwizzledSelector, forClass: PPUser.classForCoder())
      5|  140|        }
      0|  141|        catch ( SwizzleErrorType.OriginalMethodNotFound ) {
      0|  142|            XCTFail("Original method not found")
      0|  143|        } catch (SwizzleErrorType.SwizzleMethodNotFound) {
      0|  144|            XCTFail("Swizzable method not found")
      0|  145|        } catch _ {
      0|  146|            XCTFail("Unknown error")
      0|  147|        }
      5|  148|
      5|  149|        // Cleanup captured event.
      5|  150|        PPNavigatorDouble.currentNavigator().capturedEvent = nil
      5|  151|
      5|  152|        super.tearDown()
      5|  153|    }
       |  154|}
       |  155|
       |  156|// MARK: Singleton Swizzling - Extensions
       |  157|
       |  158|extension PPPrimaryTabBarController_iPad {
       |  159|
      5|  160|    func setupLifeCycleObservers() {
      5|  161|        // NO-OP
      5|  162|    }
      5|  163|    func teardownLifeCycleObservers() {
      5|  164|        // NO-OP
      5|  165|    }
       |  166|}
       |  167|
       |  168|extension PPNavigator {
     20|  169|    static func swz_navigator() -> PPNavigator! {
     20|  170|        return PPNavigatorDouble.currentNavigator()
     20|  171|    }
       |  172|}
       |  173|
       |  174|extension PPUser {
     87|  175|    static func swz_currentUser() -> PPUser! {
     87|  176|        return PPUserDouble.currentInstance()
     87|  177|    }
       |  178|}
       |  179|
       |  180|class PPNavigatorDouble : PPNavigator {
       |  181|
       |  182|    static let sharedInstance = PPNavigatorDouble()
       |  183|
     34|  184|    override static func currentNavigator() -> PPNavigatorDouble! {
     34|  185|        return sharedInstance
     34|  186|    }
       |  187|
       |  188|    var capturedEvent : PPAnalyticsSerializable?
       |  189|
     13|  190|    @objc override func presentAuthenticationModalFromViewController(viewController: UIViewController!, authenticationArea: AuthArea, withCompletionBlock completionBlock:((PPAPIRequest!) -> Void)!) {
     13|  191|        let spy = AnalyticsProviderSpy()
     13|  192|        let authModal = AuthenticationViewController(requestType: RequestType.Authentication, source: authenticationArea)
     13|  193|        authModal.analyticsProvider = spy
     13|  194|        authModal.viewDidAppear(false)
     13|  195|
     13|  196|        capturedEvent = spy.capturedEvent
     13|  197|    }
       |  198|}
       |  199|
       |  200|class PPUserDouble : PPUser {
       |  201|
       |  202|    static let sharedInstance = PPUserDouble()
       |  203|
     87|  204|    static func currentInstance() -> PPUserDouble! {
     87|  205|        return sharedInstance
     87|  206|    }
       |  207|
     15|  208|    @objc override var isLoggedIn: Bool {
     15|  209|        return false
     15|  210|    }
       |  211|
     15|  212|    @objc override func canAutomaticallyLoginWithStoredInformation() -> Bool {
     15|  213|        return false
     15|  214|    }
       |  215|
      1|  216|    override init() {
      1|  217|        // do nothing...
      1|  218|    }
       |  219|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPPrimaryTabBarViewControllerAuthenticationTests.swift:
       |    1|//
       |    2|//  PPPrimaryTabBarViewControllerAuthenticationTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 9/28/15.
       |    6|//  Copyright  2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|
       |   11|class PPPrimaryTabBarViewControllerAuthenticationTests: XCTestCase {
       |   12|
       |   13|    // [PrimaryTabBarViewController tabBarController:shouldSelectViewController:]
       |   14|
      1|   15|    func testWhenSelectingHomePageShouldNotCaptureEvent() {
      1|   16|
      0|   17|        guard let navDouble:PPNavigatorDouble! = PPNavigator.currentNavigator() as? PPNavigatorDouble! else {
      0|   18|            XCTFail("The test was not set appropiately.")
      0|   19|            return
      0|   20|        }
      1|   21|
      0|   22|        guard let sut = PPPrimaryTabBarViewController() as? UITabBarControllerDelegate else {
      0|   23|            XCTFail("PPPPrimaryTabBarViewController is not a UITabBarControllerDelegate.  Cannot proceed with Unit Test.")
      0|   24|            return
      0|   25|        }
      1|   26|
      1|   27|        let toSelect = PPHomePageViewController()
      1|   28|        let dummyTabBar = UITabBarController()
      1|   29|        sut.tabBarController!(dummyTabBar, shouldSelectViewController: toSelect)
      1|   30|
      0|   31|        if let event = navDouble.capturedEvent {
      0|   32|            XCTFail("PPNavigator should NOT had captured an event. Captured event: \(event)")
      0|   33|        }
      1|   34|    }
       |   35|
      1|   36|    func testWhenSelectingMoreViewControllerCorrectEventIsCaught() {
      1|   37|
      0|   38|        guard let navDouble:PPNavigatorDouble! = PPNavigator.currentNavigator() as? PPNavigatorDouble! else {
      0|   39|            XCTFail("The test was not set appropiately.")
      0|   40|            return
      0|   41|        }
      1|   42|
      0|   43|        guard let sut = PPPrimaryTabBarViewController() as? UITabBarControllerDelegate else {
      0|   44|            XCTFail("PPPPrimaryTabBarViewController is not a UITabBarControllerDelegate.  Cannot proceed with Unit Test.")
      0|   45|            return
      0|   46|        }
      1|   47|
      1|   48|        let toSelect = PPMoreViewController()
      1|   49|        let dummyTabBar = UITabBarController()
      1|   50|        sut.tabBarController!(dummyTabBar, shouldSelectViewController: toSelect)
      1|   51|
      1|   52|        if let event = navDouble.capturedEvent {
      1|   53|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      1|   54|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.More])
      0|   55|        } else {
      0|   56|            XCTFail("PPNavigator should had captured an event.")
      0|   57|        }
      1|   58|    }
       |   59|
      1|   60|    func testWhenSelectingPostboxViewControllerCorrectEventIsCaught() {
      1|   61|
      0|   62|        guard let navDouble:PPNavigatorDouble! = PPNavigator.currentNavigator() as? PPNavigatorDouble! else {
      0|   63|            XCTFail("The test was not set appropiately.")
      0|   64|            return
      0|   65|        }
      1|   66|
      0|   67|        guard let sut = PPPrimaryTabBarViewController() as? UITabBarControllerDelegate else {
      0|   68|            XCTFail("PPPPrimaryTabBarViewController is not a UITabBarControllerDelegate.  Cannot proceed with Unit Test.")
      0|   69|            return
      0|   70|        }
      1|   71|
      1|   72|        let toSelect = PPPostboxViewController()
      1|   73|        let dummyTabBar = UITabBarController()
      1|   74|        sut.tabBarController!(dummyTabBar, shouldSelectViewController: toSelect)
      1|   75|
      1|   76|        if let event = navDouble.capturedEvent {
      1|   77|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      1|   78|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Postbox])
      0|   79|        } else {
      0|   80|            XCTFail("PPNavigator should had captured an event.")
      0|   81|        }
      1|   82|    }
       |   83|
       |   84|
      1|   85|    func testWhenSelectingPhotoViewControllerCorrectEventIsCaught() {
      1|   86|
      1|   87|        class PPPostboxDataSourceMock: PPPostboxDataSource {
      1|   88|            override var postBoxType: PPPostBoxType {
      1|   89|                get { return PPPostBoxType.Photos }
      0|   90|                set {} // no-op
      1|   91|            }
      1|   92|        }
      1|   93|
      1|   94|        class TestablePhotoViewController: PPPostboxViewController {
      1|   95|            // Do not setup any observation
      1|   96|            override func setupObservation() {}
      1|   97|            override func cleanObservation() {}
      1|   98|        }
      1|   99|
      0|  100|        guard let navDouble:PPNavigatorDouble! = PPNavigator.currentNavigator() as? PPNavigatorDouble! else {
      0|  101|            XCTFail("The test was not set appropiately.")
      0|  102|            return
      0|  103|        }
      1|  104|
      0|  105|        guard let sut = PPPrimaryTabBarViewController() as? UITabBarControllerDelegate else {
      0|  106|            XCTFail("PPPPrimaryTabBarViewController is not a UITabBarControllerDelegate.  Cannot proceed with Unit Test.")
      0|  107|            return
      0|  108|        }
      1|  109|
      1|  110|        let dataSource = PPPostboxDataSourceMock()
      1|  111|        let toSelect = TestablePhotoViewController(layoutType: PPPostBoxLayoutType.Grid, dataSource: dataSource)
      1|  112|        let dummyTabBar = UITabBarController()
      1|  113|        sut.tabBarController!(dummyTabBar, shouldSelectViewController: toSelect)
      1|  114|
      0|  115|        if let event = navDouble.capturedEvent {
      0|  116|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      0|  117|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Photos])
      1|  118|        } else {
      1|  119|            XCTFail("PPNavigator should had captured an event.")
      1|  120|        }
      1|  121|    }
       |  122|
      1|  123|    func testWhenSelectingPostboxSplitViewControllerCorrectEventIsCaught() {
      1|  124|
      0|  125|        guard let navDouble:PPNavigatorDouble! = PPNavigator.currentNavigator() as? PPNavigatorDouble! else {
      0|  126|            XCTFail("The test was not set appropiately.")
      0|  127|            return
      0|  128|        }
      1|  129|
      0|  130|        guard let sut = PPPrimaryTabBarViewController() as? UITabBarControllerDelegate else {
      0|  131|            XCTFail("PPPPrimaryTabBarViewController is not a UITabBarControllerDelegate.  Cannot proceed with Unit Test.")
      0|  132|            return
      0|  133|        }
      1|  134|
      1|  135|        let toSelect = PPPostboxSplitViewController()
      1|  136|        let dummyTabBar = UITabBarController()
      1|  137|        sut.tabBarController!(dummyTabBar, shouldSelectViewController: toSelect)
      1|  138|
      1|  139|        if let event = navDouble.capturedEvent {
      1|  140|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      1|  141|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Postbox])
      0|  142|        } else {
      0|  143|            XCTFail("PPNavigator should had captured an event.")
      0|  144|        }
      1|  145|    }
       |  146|
      1|  147|    func testWhenSelectingFavoritesViewControllerCorrectEventIsCaught() {
      1|  148|
      0|  149|        guard let navDouble:PPNavigatorDouble! = PPNavigator.currentNavigator() as? PPNavigatorDouble! else {
      0|  150|            XCTFail("The test was not set appropiately.")
      0|  151|            return
      0|  152|        }
      1|  153|
      0|  154|        guard let sut = PPPrimaryTabBarViewController() as? UITabBarControllerDelegate else {
      0|  155|            XCTFail("PPPPrimaryTabBarViewController is not a UITabBarControllerDelegate.  Cannot proceed with Unit Test.")
      0|  156|            return
      0|  157|        }
      1|  158|
      1|  159|        let toSelect = PPFavoritesViewController()
      1|  160|        let dummyTabBar = UITabBarController()
      1|  161|        sut.tabBarController!(dummyTabBar, shouldSelectViewController: toSelect)
      1|  162|
      1|  163|        if let event = navDouble.capturedEvent {
      1|  164|            XCTAssertEqual(event.authenticationStepValue(), ExpectedValues.Steps[AuthStep.Login])
      1|  165|            XCTAssertEqual(event.authenticationAreaValue(), ExpectedValues.Areas[AuthArea.Favorites])
      0|  166|        } else {
      0|  167|            XCTFail("PPNavigator should had captured an event.")
      0|  168|        }
      1|  169|    }
       |  170|}
       |  171|
       |  172|extension PPPrimaryTabBarViewControllerAuthenticationTests {
       |  173|
      6|  174|    override func setUp() {
      6|  175|        super.setUp()
      6|  176|
      6|  177|        // Setup Method Swizzling
      6|  178|        do {
      6|  179|            let originalSelector = Selector("navigator")
      6|  180|            let swizzledSelector = Selector("swz_navigator")
      6|  181|            try PPNavigator.swizzleStaticMethodSelector(originalSelector, withSelector: swizzledSelector, forClass: PPNavigator.classForCoder())
      6|  182|
      6|  183|            let usrOriginalSelector = Selector("currentUser")
      6|  184|            let usrSwizzledSelector = Selector("swz_currentUser")
      6|  185|            try PPUser.swizzleStaticMethodSelector(usrOriginalSelector, withSelector: usrSwizzledSelector, forClass: PPUser.classForCoder())
      6|  186|        }
      0|  187|        catch ( SwizzleErrorType.OriginalMethodNotFound ) {
      0|  188|            XCTFail("Original method not found")
      0|  189|        } catch (SwizzleErrorType.SwizzleMethodNotFound) {
      0|  190|            XCTFail("Swizzable method not found")
      0|  191|        } catch _ {
      0|  192|            XCTFail("Unknown error")
      0|  193|        }
      6|  194|    }
       |  195|
      6|  196|    override func tearDown() {
      6|  197|
      6|  198|        // Undo Method Swizzling
      6|  199|        do {
      6|  200|            let originalSelector = Selector("navigator")
      6|  201|            let swizzledSelector = Selector("swz_navigator")
      6|  202|            try PPNavigator.swizzleStaticMethodSelector(originalSelector, withSelector: swizzledSelector, forClass: PPNavigator.classForCoder())
      6|  203|
      6|  204|            let usrOriginalSelector = Selector("currentUser")
      6|  205|            let usrSwizzledSelector = Selector("swz_currentUser")
      6|  206|            try PPUser.swizzleStaticMethodSelector(usrOriginalSelector, withSelector: usrSwizzledSelector, forClass: PPUser.classForCoder())
      6|  207|        }
      0|  208|        catch ( SwizzleErrorType.OriginalMethodNotFound ) {
      0|  209|            XCTFail("Original method not found")
      0|  210|        } catch (SwizzleErrorType.SwizzleMethodNotFound) {
      0|  211|            XCTFail("Swizzable method not found")
      0|  212|        } catch _ {
      0|  213|            XCTFail("Unknown error")
      0|  214|        }
      6|  215|
      6|  216|        // Cleanup captured event.
      6|  217|        PPNavigatorDouble.currentNavigator().capturedEvent = nil
      6|  218|
      6|  219|        super.tearDown()
      6|  220|    }
       |  221|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPPushNotificationHelpersTests.swift:
       |    1|//
       |    2|//  PPPushNotificationHelpersTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 5/26/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|class PPPushNotificationHelpersTests: XCTestCase {
       |   13|    
      1|   14|    func testItParsesStringOfCommaSeparatedValuesToInts() {
      1|   15|        let stringValue = "1,2,3,4,55,66,777,888,9999"
      1|   16|        let integerValues = [1,2,3,4,55,66,777,888,9999]
      1|   17|        let parsedIntegerValue = stringValue.toInts()
      1|   18|        XCTAssertTrue(parsedIntegerValue == integerValues, "The parsed integer values should equal the original Int values")
      1|   19|    }
       |   20|    
      1|   21|    func testItParsesStringOfCommaSeparatedValuesWithSpacesToInts() {
      1|   22|        let stringValue = "1, 2, 3,4,55, 66,777,888, 9999"
      1|   23|        let integerValues = [1,2,3,4,55,66,777,888,9999]
      1|   24|        let parsedIntegerValue = stringValue.toInts()
      1|   25|        XCTAssertTrue(parsedIntegerValue == integerValues, "The parsed integer values should equal the original Int values")
      1|   26|    }
       |   27|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPSegmentedControllerTests.swift:
       |    1|//
       |    2|//  PPSegmentedControllerTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Daniel Rodriguez on 8/3/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|import PaperlessPost
       |   11|
       |   12|typealias SegmentedControllerData = (controller : PPSegmentedController, currentIndex: Int)
       |   13|typealias SegmentedControllerViewData = (viewControllers: [UIViewController], controlItems:[String], currentIndex:Int)
       |   14|
       |   15|extension Int {
     11|   16|    static func random(range: Range<Int> ) -> Int {
     11|   17|        var offset = 0
     11|   18|        
      0|   19|        if range.startIndex < 0 {  // allow negative ranges
      0|   20|            offset = abs(range.startIndex)
      0|   21|        }
     11|   22|        
     11|   23|        let mini = UInt32(range.startIndex + offset)
     11|   24|        let maxi = UInt32(range.endIndex   + offset)
     11|   25|        
     11|   26|        return Int(mini + arc4random_uniform(maxi - mini)) - offset
     11|   27|    }
       |   28|}
       |   29|
       |   30|class PPSegmentedControllerTests: XCTestCase {
       |   31|
       |   32|    var controller : PPSegmentedController = PPSegmentedController()
       |   33|    
      3|   34|    override func setUp() {
      3|   35|        super.setUp()
      3|   36|        let data = self.setupControllerWithNumberOfViewControllers(3)
      3|   37|        controller = data.controller
      3|   38|        controller.selectedIndex = data.currentIndex
      3|   39|    }
       |   40|    
      3|   41|    override func tearDown() {
      3|   42|        super.tearDown()
      3|   43|    }
       |   44|    
      1|   45|    func testCurrentIndexShouldNotChange() {
      1|   46|        // given
      1|   47|        let originalIndex = controller.selectedIndex
      1|   48|        
      1|   49|        // when
      1|   50|        controller.viewControllers = utilDataWithNumberOfViewControllers(3).viewControllers
      1|   51|        
      1|   52|        // then
      1|   53|        XCTAssertEqual(originalIndex, controller.selectedIndex,  "index should not change.")
      1|   54|    }
       |   55|    
      1|   56|    func testAddingViewControllersShouldNotChangeIndex() {
      1|   57|        // given
      1|   58|        let data = self.setupControllerWithNumberOfViewControllers(2)
      1|   59|        controller = data.controller
      1|   60|        controller.selectedIndex = data.currentIndex
      1|   61|        let originalIndex = data.currentIndex
      1|   62|        
      1|   63|        // when
      1|   64|        controller.viewControllers = utilDataWithNumberOfViewControllers(3).viewControllers
      1|   65|        
      1|   66|        // then
      1|   67|        XCTAssertEqual(originalIndex, controller.selectedIndex,  "index should not change.")
      1|   68|    }
       |   69|    
      1|   70|    func testCurrentIndexShouldChangeToPreventOutOfBounds() {
      1|   71|        // given
      1|   72|        controller.selectedIndex = controller.viewControllers.count - 1
      1|   73|        let originalIndex = controller.selectedIndex
      1|   74|        
      1|   75|        // when
      1|   76|        controller.viewControllers = utilDataWithNumberOfViewControllers(2).viewControllers
      1|   77|
      1|   78|        // then
      1|   79|        XCTAssertNotEqual(originalIndex, controller.selectedIndex, "current index should have changed.")
      1|   80|        XCTAssertEqual(controller.selectedIndex, 0, "current index should be zero.")
      1|   81|    }
       |   82|    
       |   83|    // MARK: Setup and Util methods
       |   84|    
      4|   85|    func setupControllerWithNumberOfViewControllers(numControllers : Int) -> SegmentedControllerData {
      4|   86|        let data = utilDataWithNumberOfViewControllers(numControllers)
      4|   87|        var controller : PPSegmentedController = PPSegmentedController(viewControllers:data.viewControllers, segmentedControlItems:data.controlItems)
      4|   88|        return (controller, data.currentIndex)
      4|   89|    }
       |   90|    
      7|   91|    func utilDataWithNumberOfViewControllers(numControllers: Int) -> SegmentedControllerViewData {
      7|   92|        
      7|   93|        let selectedIndex = Int.random(1...numControllers)
      7|   94|        
      7|   95|        var viewControllers : [UIViewController] = [UIViewController]()
      7|   96|        var controlItems : [String] = [String]()
     19|   97|        for index in 1...numControllers {
     12|   98|            let instance = (index == selectedIndex) ? MyViewController() : UIViewController()
     19|   99|            viewControllers.append(instance)
     19|  100|            controlItems.append(String(index))
     19|  101|        }
      7|  102|        
      7|  103|        return (viewControllers, controlItems, selectedIndex - 1)
      7|  104|    }
       |  105|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PPUserTests.swift:
       |    1|//
       |    2|//  PPUserTests.swift
       |    3|//  
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 1/29/15.
       |    6|//
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|class PPUserTests: XCTestCase {
       |   13|
      1|   14|    override func setUp() {
      1|   15|        super.setUp()
      1|   16|        // Put setup code here. This method is called before the invocation of each test method in the class.
      1|   17|    }
       |   18|
       |   19|
      1|   20|    func testItCorrectlyIdentifiersUsersWithPPEmails() {
      1|   21|
      1|   22|        let newUser = PPUser()
      1|   23|        newUser.setEmailAddress("sal@paperlesspost.com", andPassword: "blah blah")
      1|   24|        
      1|   25|        XCTAssertTrue(newUser.hasPaperlessPostEmailAddress(), "User with a paperless post email address should be identified such")
      1|   26|        
      1|   27|        newUser.setEmailAddress("sal@gmail.com", andPassword: "blah")
      1|   28|        XCTAssertFalse(newUser.hasPaperlessPostEmailAddress(), "Users without the paperless post email address should not return true")
      1|   29|    }
       |   30|
       |   31|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PhoneNumberUtilitiesTests.swift:
       |    1|//
       |    2|//  PhoneNumberUtilitiesTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Jabari Bell on 4/13/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import XCTest
       |   10|import PaperlessPost
       |   11|import Foundation
       |   12|
       |   13|class PhoneNumberUtilitiesTests: XCTestCase {
       |   14|    
      1|   15|    func testThatProperlyFormattedNumberIsReturnedFromFormatter() {
      1|   16|        let inputNumber = "+1 (917) 555 - 1234"
      1|   17|        let outputNumber = "tel://19175551234"
      1|   18|        let formattedNumber = PhoneNumberUtilities.formattedTelephoneStringForFormattedNumber(inputNumber)
      1|   19|        XCTAssert(formattedNumber == outputNumber, "Outputted number should be tel:// plus the number stripped of any special symbols or white spaces.")        
      1|   20|    }
       |   21| 
       |   22|    
       |   23|    
       |   24|    
       |   25|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/PostboxCollectionCellTests.swift:
       |    1|//
       |    2|//  PostboxCollectionCellTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Wyatt McBain on 6/11/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|
       |   12|@available(iOS 8.0, *)
       |   13|class PostboxCollectionCellTests: FBSnapshotTestCase {
       |   14|
      2|   15|    override func setUp() {
      2|   16|        super.setUp()
      2|   17|        self.recordMode = false
      2|   18|    }
       |   19|
      1|   20|    func testPostboxCellTableRow() {
      1|   21|        let postbox = PPPostboxCell(frame: CGRectMake(0, 0, 300, 100))
      1|   22|        self.setUpContentHelper(postbox)
      1|   23|        FBSnapShotVerifyLayer(postbox.layer)
      1|   24|    }
       |   25|
      1|   26|    func testPostboxCellGrid() {
      1|   27|        let postbox = PPPostboxCell(frame: CGRectMake(0, 0, 200, 260))
      1|   28|        self.setUpContentHelper(postbox)
      1|   29|        FBSnapShotVerifyLayer(postbox.layer)
      1|   30|    }
       |   31|
      2|   32|    func setUpContentHelper(postbox: PPPostboxCell) {
      2|   33|        postbox.imageView.image = PPFixtureFactory.Images.polaroid
      2|   34|        postbox.textLabel.text = "A Nice Title"
      2|   35|        postbox.detailTextLabel.text = "From Yours Truly"
      2|   36|        postbox.additionalTextLabel.text = "Please Reply"
      2|   37|        postbox.setNeedsDisplay()
      2|   38|        postbox.layoutIfNeeded()
      2|   39|    }
       |   40|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/StateMachineTests.swift:
       |    1|//
       |    2|//  StateMachineTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Jabari Bell on 6/30/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import Foundation
       |   10|@testable import PaperlessPost
       |   11|import XCTest
       |   12|
       |   13|//Mark: Datasource
       |   14|enum ColorState: StateMachineDatasource {
       |   15|    
       |   16|    case Red, Orange, Green, Blue
       |   17|    
      7|   18|    func shouldTransitionFrom(from: ColorState, to: ColorState) -> Should<ColorState> {
      7|   19|        switch (from, to) {
      5|   20|        case (.Red, .Green), (.Orange, .Green), (.Green, .Blue):
      5|   21|            return .Continue
      1|   22|        case (.Red, .Orange):
      1|   23|            return .Redirect(.Blue)
      1|   24|        default:
      1|   25|            return .Abort
      7|   26|        }
      7|   27|    }
       |   28|    
       |   29|    var description: String {
     12|   30|        get {
     12|   31|            switch self {
     10|   32|            case .Red: return "Red"
      0|   33|            case .Orange: return "Orange"
      2|   34|            case .Blue: return "Blue"
      0|   35|            case .Green: return "Green"
     12|   36|            }
     12|   37|        }
       |   38|    }
       |   39|}
       |   40|
       |   41|
       |   42|class StateMachineTests: XCTestCase, StateMachineDelegate {
       |   43|
       |   44|    
       |   45|    //MARK: Property
       |   46|    var serializer: StateMachineSerializer<StateMachineTests>!
       |   47|    
       |   48|    
       |   49|    //MARK: Setup
      6|   50|    override func setUp() {
      6|   51|        super.setUp()
      6|   52|        serializer = StateMachineSerializer<StateMachineTests>(identifier: "com.thelolz.statemachinetests")
      6|   53|    }
       |   54|    
       |   55|    
      6|   56|    override func tearDown() {
      6|   57|        serializer.reset()
      6|   58|        super.tearDown()
      6|   59|    }
       |   60|    
       |   61|    
       |   62|    //MARK: StateMachineDelegate
       |   63|    typealias StateType = ColorState
       |   64|    
      6|   65|    func didTransitionFrom(from: StateType, to: StateType) {
      6|   66|        switch (from, to) {
      4|   67|        case (.Red, .Green):
      4|   68|            serializer.satisfy(.Red)
      0|   69|        case (.Red, .Orange):
      0|   70|            break
      0|   71|        case (.Orange, .Green):
      0|   72|            break
      1|   73|        case (.Green, .Blue):
      1|   74|            serializer.unsatisfy(.Red)
      1|   75|        default:
      1|   76|            break
      6|   77|        }
      6|   78|    }
       |   79|    
       |   80|
       |   81|    //MARK: Test - State Machine
      1|   82|    func testThatValidStateTransitionUpdatesStateMachineAsExpected() {
      1|   83|        let machine = StateMachine(initialState: StateType.Red, delegate: self)
      1|   84|        machine.state = .Green
      1|   85|        XCTAssert(machine.state == .Green, "StateType should be green")
      1|   86|    }
       |   87|    
      1|   88|    func testThatInvalidStateTransitionDoesNotUpdateStateMachine() {
      1|   89|        let machine = StateMachine(initialState: StateType.Red, delegate: self)
      1|   90|        machine.state = .Blue
      1|   91|        XCTAssert(machine.state == .Red, "StateType should not be blue")
      1|   92|    }
       |   93|    
      1|   94|    func testThatRedirectDirectsMachineToIntendedState() {
      1|   95|        let machine = StateMachine(initialState: StateType.Red, delegate: self)
      1|   96|        machine.state = .Orange
      1|   97|        XCTAssert(machine.state == .Blue, "StateType should redirect to blue")
      1|   98|    }
       |   99|    
       |  100|
       |  101|    //MARK: Test - Serializer
      1|  102|    func testThatMovingFromRedStateToGreenStateSatisfiesRedState() {
      1|  103|        let machine = StateMachine(initialState: .Red, delegate: self)
      1|  104|        machine.state = .Green
      1|  105|        XCTAssert(serializer.isSatisfied(.Red), "Moving from red state to green should satisfy red state.")
      1|  106|    }
       |  107|    
      1|  108|    func testThatMovingFromRedStateToGreenStateSatisfiesRedStateAndThenMovingToBlueUnsatisfiesRedState() {
      1|  109|        let machine = StateMachine(initialState: .Red, delegate: self)
      1|  110|        machine.state = .Green
      1|  111|        XCTAssert(serializer.isSatisfied(.Red), "Moving from red state to green should satisfy red state.")
      1|  112|        machine.state = .Blue
      1|  113|        XCTAssert(serializer.isSatisfied(.Red) == false, "Moving from green to blue state should unsatisfy red state.")
      1|  114|    }
       |  115|    
      1|  116|    func testThatResetingSerializerSetsPreviouslySatisfiedStateToUnsatisfied() {
      1|  117|        let machine = StateMachine(initialState: .Red, delegate: self)
      1|  118|        machine.state = .Green 
      1|  119|        XCTAssert(serializer.isSatisfied(.Red), "Moving from red state to green should satisfy red state.")
      1|  120|        serializer.satisfy(.Blue)
      1|  121|        serializer.reset()
      1|  122|        XCTAssert(serializer.isSatisfied(.Red) == false && serializer.isSatisfied(.Blue) == false, "Reseting serializer should set previously satisfied states to unsatisfied.")
      1|  123|    }
       |  124|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/TooltipTests.swift:
       |    1|//
       |    2|//  TooltipTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Wyatt McBain on 7/16/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|@testable import PaperlessPost
       |   12|
       |   13|class TooltipTests: FBSnapshotTestCase {
       |   14|
      7|   15|    override func setUp() {
      7|   16|        super.setUp()
      7|   17|        self.recordMode = false
      7|   18|    }
       |   19|    
      1|   20|    func testThatItHandlesUnknownsCorrectly() {
      1|   21|        let bgView = UIView(frame: CGRectMake(0, 0, 400, 50))
      1|   22|        bgView.backgroundColor = UIColor.blackColor()
      1|   23|        
      1|   24|        let tooltip = Tooltip(options:
      1|   25|            TooltipOptions(
      1|   26|                text: "Just doing some testing with the frame and what not.",
      1|   27|                alignment: .AlignUnknown,
      1|   28|                orientation: .UnknownOrientation),
      1|   29|            parentFrame: bgView.frame)
      1|   30|        
      1|   31|        bgView.addSubview(tooltip)
      1|   32|        tooltip.setNeedsLayout()
      1|   33|        
      1|   34|        FBSnapShotVerifyLayer(bgView.layer, identifier: "Unknown alignment unkown orientation")
      1|   35|    }
       |   36|    
      1|   37|    func testThatItRendersATopCenterCorrectly() {
      1|   38|        let bgView = UIView(frame: CGRectMake(0, 0, 400, 50))
      1|   39|        bgView.backgroundColor = UIColor.blackColor()
      1|   40|        
      1|   41|        let tooltip = Tooltip(options:
      1|   42|            TooltipOptions(
      1|   43|                text: "Just doing some testing with the frame and what not.",
      1|   44|                alignment: .AlignCenter,
      1|   45|                orientation: .TopOrientation),
      1|   46|            parentFrame: bgView.frame)
      1|   47|        
      1|   48|        bgView.addSubview(tooltip)
      1|   49|        tooltip.setNeedsLayout()
      1|   50|        
      1|   51|        FBSnapShotVerifyLayer(bgView.layer, identifier: "Center alignment top orientation")
      1|   52|    }
       |   53|    
      1|   54|    func testThatItRendersATopLeftCorrectly() {
      1|   55|        let bgView = UIView(frame: CGRectMake(0, 0, 400, 50))
      1|   56|        bgView.backgroundColor = UIColor.blackColor()
      1|   57|        
      1|   58|        let tooltip = Tooltip(options:
      1|   59|            TooltipOptions(
      1|   60|                text: "Just doing some testing with the frame and what not.",
      1|   61|                alignment: .AlignLeft,
      1|   62|                orientation: .TopOrientation),
      1|   63|            parentFrame: bgView.frame)
      1|   64|        
      1|   65|        bgView.addSubview(tooltip)
      1|   66|        tooltip.setNeedsLayout()
      1|   67|        
      1|   68|        FBSnapShotVerifyLayer(bgView.layer, identifier: "Left alignment top orientation")
      1|   69|    }
       |   70|    
      1|   71|    func testThatItRendersATopRightCorrectly() {
      1|   72|        let bgView = UIView(frame: CGRectMake(0, 0, 400, 50))
      1|   73|        bgView.backgroundColor = UIColor.blackColor()
      1|   74|        
      1|   75|        let tooltip = Tooltip(options:
      1|   76|            TooltipOptions(
      1|   77|                text: "Just doing some testing with the frame and what not.",
      1|   78|                alignment: .AlignRight,
      1|   79|                orientation: .TopOrientation),
      1|   80|            parentFrame: bgView.frame)
      1|   81|        
      1|   82|        bgView.addSubview(tooltip)
      1|   83|        tooltip.setNeedsLayout()
      1|   84|        
      1|   85|        FBSnapShotVerifyLayer(bgView.layer, identifier: "Right alignment top orientation")
      1|   86|    }
       |   87|    
      1|   88|    func testThatItRendersABottomCenterCorrectly() {
      1|   89|        let bgView = UIView(frame: CGRectMake(0, 0, 400, 50))
      1|   90|        bgView.backgroundColor = UIColor.blackColor()
      1|   91|        
      1|   92|        let tooltip = Tooltip(options:
      1|   93|            TooltipOptions(
      1|   94|                text: "Just doing some testing with the frame and what not.",
      1|   95|                alignment: .AlignCenter,
      1|   96|                orientation: .BottomOrientation),
      1|   97|            parentFrame: bgView.frame)
      1|   98|        
      1|   99|        bgView.addSubview(tooltip)
      1|  100|        tooltip.setNeedsLayout()
      1|  101|        
      1|  102|        FBSnapShotVerifyLayer(bgView.layer, identifier: "Center alignment bottom orientation")
      1|  103|    }
       |  104|    
      1|  105|    func testThatItRendersABottomLeftCorrectly() {
      1|  106|        let bgView = UIView(frame: CGRectMake(0, 0, 400, 50))
      1|  107|        bgView.backgroundColor = UIColor.blackColor()
      1|  108|        
      1|  109|        let tooltip = Tooltip(options:
      1|  110|            TooltipOptions(
      1|  111|                text: "Just doing some testing with the frame and what not.",
      1|  112|                alignment: .AlignLeft,
      1|  113|                orientation: .BottomOrientation),
      1|  114|            parentFrame: bgView.frame)
      1|  115|        
      1|  116|        bgView.addSubview(tooltip)
      1|  117|        tooltip.setNeedsLayout()
      1|  118|        
      1|  119|        FBSnapShotVerifyLayer(bgView.layer, identifier: "Left alignment left orientation")
      1|  120|    }
       |  121|    
      1|  122|    func testThatItRendersABottomRightCorrectly() {
      1|  123|        let bgView = UIView(frame: CGRectMake(0, 0, 400, 50))
      1|  124|        bgView.backgroundColor = UIColor.blackColor()
      1|  125|        
      1|  126|        let tooltip = Tooltip(options:
      1|  127|            TooltipOptions(
      1|  128|                text: "Just doing some testing with the frame and what not.",
      1|  129|                alignment: .AlignRight,
      1|  130|                orientation: .BottomOrientation),
      1|  131|            parentFrame: bgView.frame)
      1|  132|        
      1|  133|        bgView.addSubview(tooltip)
      1|  134|        tooltip.setNeedsLayout()
      1|  135|        
      1|  136|        FBSnapShotVerifyLayer(bgView.layer, identifier: "Right alignment bottom orientation")
      1|  137|    }
       |  138|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/TutorialAnimatedTooltipTests.swift:
       |    1|//
       |    2|//  TutorialAnimatedTooltipTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Wyatt McBain on 7/16/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|@testable import PaperlessPost
       |   12|
       |   13|class TutorialAnimatedTooltipTests: FBSnapshotTestCase {
       |   14|
      3|   15|    override func setUp() {
      3|   16|        super.setUp()
      3|   17|        self.recordMode = false
      3|   18|    }
       |   19|    
      1|   20|    func testThatItRendersCorrectlyBeforeAnimation() {
      1|   21|        let bgView = UIView(frame: CGRectMake(0, 0, 400, 600))
      1|   22|        bgView.backgroundColor = UIColor.blueColor()
      1|   23|        
      1|   24|        let scale: CGFloat = 10.0
      1|   25|        
      1|   26|        let tooltipOptions = TooltipOptions(text: "Just testing this thing out, let's see if it works or naw.", alignment: .AlignCenter, orientation: .BottomOrientation)
      1|   27|        
      1|   28|        let animatedViewOptions = TutorialTooltipViewOptions(target: bgView.center, targetSize: CGSize(width: 100, height: 100), initialTargetScale: scale, parentFrame: bgView.frame, duration: 0.1, delay: 0.0, tooltipDelay: 0.0)
      1|   29|        
      1|   30|        let animatedView = TutorialTooltipAnimatedView(tooltipOptions: tooltipOptions, viewOptions: animatedViewOptions)
      1|   31|        
      1|   32|        bgView.addSubview(animatedView)
      1|   33|        
      1|   34|        FBSnapShotVerifyLayer(bgView.layer, identifier: "Rendering before animating")
      1|   35|    }
       |   36|    
      1|   37|    func testThatItRendersCorrectlyAfterAnimation() {
      1|   38|        let bgView = UIView(frame: CGRectMake(0, 0, 400, 600))
      1|   39|        bgView.backgroundColor = UIColor.blueColor()
      1|   40|        
      1|   41|        let scale: CGFloat = 10.0
      1|   42|        
      1|   43|        let tooltipOptions = TooltipOptions(text: "Just testing this thing out, let's see if it works or naw.", alignment: .AlignCenter, orientation: .BottomOrientation)
      1|   44|        
      1|   45|        let animatedViewOptions = TutorialTooltipViewOptions(target: bgView.center, targetSize: CGSize(width: 100, height: 100), initialTargetScale: scale, parentFrame: bgView.frame, duration: 0.1, delay: 0.0, tooltipDelay: 0.0)
      1|   46|        
      1|   47|        let animatedView = TutorialTooltipAnimatedView(tooltipOptions: tooltipOptions, viewOptions: animatedViewOptions)
      1|   48|        
      1|   49|        bgView.addSubview(animatedView)
      1|   50|        animatedView.animate()
      1|   51|        
      1|   52|        FBSnapShotVerifyLayer(bgView.layer, identifier: "Rendering before animating")
      1|   53|    }
       |   54|    
      1|   55|    func testThatItRendersCorrectlyAfterOutAnimation() {
      1|   56|        let bgView = UIView(frame: CGRectMake(0, 0, 400, 600))
      1|   57|        bgView.backgroundColor = UIColor.blueColor()
      1|   58|        
      1|   59|        let scale: CGFloat = 10.0
      1|   60|        
      1|   61|        let tooltipOptions = TooltipOptions(text: "Just testing this thing out, let's see if it works or naw.", alignment: .AlignCenter, orientation: .BottomOrientation)
      1|   62|        
      1|   63|        let animatedViewOptions = TutorialTooltipViewOptions(target: bgView.center, targetSize: CGSize(width: 100, height: 100), initialTargetScale: scale, parentFrame: bgView.frame, duration: 0.1, delay: 0.0, tooltipDelay: 0.0)
      1|   64|        
      1|   65|        let animatedView = TutorialTooltipAnimatedView(tooltipOptions: tooltipOptions, viewOptions: animatedViewOptions)
      1|   66|        
      1|   67|        bgView.addSubview(animatedView)
      1|   68|        animatedView.animate()
      1|   69|        animatedView.animateOut()
      1|   70|        
      1|   71|        FBSnapShotVerifyLayer(bgView.layer, identifier: "Rendering before animating")
      1|   72|    }
       |   73|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/PaperlessPostTests/TutorialControlAnimatorTests.swift:
       |    1|//
       |    2|//  TutorialControlAnimatorTests.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Wyatt McBain on 6/29/15.
       |    6|//  Copyright (c) 2015 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import UIKit
       |   10|import XCTest
       |   11|@testable import PaperlessPost
       |   12|
       |   13|class TutorialControlAnimatorTests: XCTestCase {
       |   14|
      1|   15|    func testThatAnimatorSetsUpCorrectly() {
      1|   16|        let view = UIView(frame: CGRectMake(20, 20, 200, 200))
      1|   17|        let animator = TutorialControlAnimator(control: view, axis: AnimationAxis.XAxis)
      1|   18|        
      1|   19|        XCTAssertTrue(animator.duration == 0.4, "Animator should be initialized with a default duration value")
      1|   20|        XCTAssertTrue(animator.bounceChange == 5.0, "Animator should be initialized with a default bounce change value.")
      1|   21|    }
       |   22|    
      1|   23|    func testThatAnimatorSetsValuesCorrectly() {
      1|   24|        let view = UIView(frame: CGRectMake(20, 20, 200, 200))
      1|   25|        let animator = TutorialControlAnimator(control: view, axis: AnimationAxis.XAxis)
      1|   26|        animator.duration = 0.4
      1|   27|        animator.bounceChange = 10.0
      1|   28|        
      1|   29|        XCTAssertTrue(animator.duration == 0.4, "Animator should be initialized with a default duration value")
      1|   30|        XCTAssertTrue(animator.bounceChange == 10.0, "Animator should be initialized with a default bounce change value.")
      1|   31|    }
       |   32|
      1|   33|    func testThatAnimatorAnimatesCorrectly() {
      1|   34|        let view = UIView(frame: CGRectMake(20, 20, 200, 200))
      1|   35|        let animator = TutorialControlAnimator(control: view, axis: AnimationAxis.XAxis)
      1|   36|        
      1|   37|        var keys: AnyObject? = nil
      0|   38|        if let startingKeys = view.pop_animationKeys() {
      0|   39|            keys = startingKeys
      0|   40|        }
      1|   41|        
      1|   42|        XCTAssertNil(keys, "View should have no animations attached.")
      1|   43|
      1|   44|        animator.bounce()
      1|   45|        var bounceAnimation: POPBasicAnimation?
      1|   46|        if let testBounceAnimation: POPBasicAnimation = view.pop_animationForKey("bounce") as? POPBasicAnimation {
      1|   47|            bounceAnimation = testBounceAnimation
      1|   48|        }
      1|   49|        XCTAssertFalse(view.pop_animationKeys().isEmpty, "View should have animations attached.")
      1|   50|        XCTAssertNotNil(bounceAnimation, "Bounce animation should be attached")
      1|   51|        
      1|   52|        view.pop_removeAllAnimations()
      1|   53|        var keyArray: [AnyObject] = [AnyObject]()
      0|   54|        if let testKeyArray = view.pop_animationKeys() {
      0|   55|            keyArray = testKeyArray
      0|   56|        }
      1|   57|        bounceAnimation = nil
      0|   58|        if let testBounceAnimation: POPBasicAnimation = view.pop_animationForKey("bounce") as? POPBasicAnimation {
      0|   59|            bounceAnimation = testBounceAnimation
      0|   60|        }
      1|   61|        
      1|   62|        XCTAssertTrue(keyArray.isEmpty, "View should have no animations attached.")
      1|   63|        XCTAssertNil(bounceAnimation, "Bounce animation should not exist")
      1|   64|    }
       |   65|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/Shared/FBSnapShotTestCase+SwiftHelper.swift:
       |    1|//
       |    2|//  FBSnapShotTestCase+SwiftHelper.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 9/26/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import Foundation
       |   10|
       |   11|extension FBSnapshotTestCase {
       |   12|    
     13|   13|    func FBSnapShotVerifyView(view: UIView, identifier: String?) {
     13|   14|                
     13|   15|        var error: NSError?
     13|   16|        let referenceImagesDirectory = FB_REFERENCE_IMAGE_DIR
     13|   17|        var comparisonSuccess: Bool
     13|   18|        do {
     13|   19|            try self.compareSnapshotOfView(view, referenceImagesDirectory: referenceImagesDirectory, identifier: identifier)
     13|   20|            comparisonSuccess = true
      0|   21|        } catch let error1 as NSError {
      0|   22|            error = error1
      0|   23|            comparisonSuccess = false
      0|   24|        }
     13|   25|        XCTAssertTrue(comparisonSuccess, "Snapshot comparison failed: \(error)")
     13|   26|        XCTAssertFalse(self.recordMode, "Test ran in record mode. Reference image is now saved. Disable record mode to perform an actual snapshot comparison!")
     13|   27|    }
       |   28|    
     44|   29|    func FBSnapShotVerifyLayer(layer: CALayer, identifier: String?) {
     44|   30|        
     44|   31|        var error: NSError?
     44|   32|        let referenceImagesDirectory = FB_REFERENCE_IMAGE_DIR
     44|   33|        let comparisonSuccess: Bool
     44|   34|        do {
     44|   35|            try self.compareSnapshotOfLayer(layer, referenceImagesDirectory: referenceImagesDirectory, identifier: identifier)
     44|   36|            comparisonSuccess = true
      0|   37|        } catch let error1 as NSError {
      0|   38|            error = error1
      0|   39|            comparisonSuccess = false
      0|   40|        }
     44|   41|        XCTAssertTrue(comparisonSuccess, "Snapshot comparison failed: \(error)")
     44|   42|        XCTAssertFalse(self.recordMode, "Test ran in record mode. Reference image is now saved. Disable record mode to perform an actual snapshot comparison!")
     44|   43|    }
       |   44|    
     25|   45|    func FBSnapShotVerifyLayer(layer: CALayer) {
     25|   46|        FBSnapShotVerifyLayer(layer, identifier: nil)
     25|   47|    }
       |   48|}
       |   49|
       |   50|extension FBSnapshotTestCase {
       |   51|    
       |   52|//    func FBSnapShotVerifyNode(node: ASDisplayNode) {
       |   53|//        
       |   54|//    }
       |   55|}

/Users/Sal/Sites/paperlesspost/paperless-ios/PaperlessPostTests/Shared/PPTestingFixtureFactory.swift:
       |    1|//
       |    2|//  PPTestingFixtureFactory.swift
       |    3|//  PaperlessPost
       |    4|//
       |    5|//  Created by Salvatore Randazzo on 10/1/14.
       |    6|//  Copyright (c) 2014 PaperlessPost. All rights reserved.
       |    7|//
       |    8|
       |    9|import Foundation
       |   10|
       |   11|class _TestingBundle {}
       |   12|
       |   13|@available(iOS 8.0, *)
       |   14|struct PPFixtureFactory {
       |   15|    
      1|   16|    static func loadData(fileName: String, ofType type: String) -> NSDictionary! {
      1|   17|        let JSON = NSData(contentsOfFile: NSBundle(forClass: _TestingBundle.self).pathForResource(fileName, ofType:type)!)
      1|   18|        if let JSON = JSON {
      1|   19|            return JSON.objectFromPPJSONData() as? NSDictionary
      0|   20|        } else {
      0|   21|            return nil
      0|   22|        }
      0|   23|    }
       |   24|    
       |   25|    // MARK: Paper iOS fixtures
       |   26|    struct PaperFixtures {
       |   27|        
       |   28|        static let PricingFixture: [PPPricing] = {
       |   29|            var asDictionary = PPFixtureFactory.loadData("pricings", ofType: "json")
       |   30|            
       |   31|            var key = NSString(string: "pricing")
       |   32|            var pricingsDictionaries = asDictionary[key] as! NSArray
       |   33|            
       |   34|            var newPricings = [PPPricing]()
       |   35|            for pricingDict in pricingsDictionaries {
       |   36|                var asDictionary = pricingDict as! NSDictionary
       |   37|                var pricingObject = PPPricing.objectFromJSONDictionary(asDictionary as [NSObject : AnyObject]) as! PPPricing
       |   38|                newPricings.append(pricingObject)
       |   39|            }
       |   40|            return newPricings
       |   41|            }()
       |   42|    }
       |   43|    
       |   44|    struct Images {
       |   45|        static let Believe = UIImage.testingImage(name: "sample-image-believe.jpg")
       |   46|        static let polaroid = UIImage.testingImage(name: "test_image_paper-back-0_002.jpg")
       |   47|        
       |   48|        struct VerticalSnapshotCard {
       |   49|            static let front = UIImage.testingImage(name: "test_image_paper-front-0_002.jpg")
       |   50|            static let back = UIImage.testingImage(name: "test_image_paper-back-0_002.jpg")
       |   51|        }
       |   52|        
       |   53|    }
       |   54|    
       |   55|}
       |   56|
       |   57|//Extension for cleaner image loading when in the testing bundle
       |   58|@available(iOS 8.0, *)
       |   59|extension UIImage {
      4|   60|    class func testingImage(name name: String) -> UIImage? {
      4|   61|        return UIImage(named: name, inBundle: NSBundle(forClass: _TestingBundle.self), compatibleWithTraitCollection: nil)
      4|   62|    }
       |   63|}

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/NSInvocation+OCMAdditions.m:
       |    1|/*
       |    2| *  Copyright (c) 2006-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "NSInvocation+OCMAdditions.h"
       |   18|#import "OCMFunctions.h"
       |   19|
       |   20|
       |   21|@implementation NSInvocation(OCMAdditions)
       |   22|
       |   23|- (BOOL)hasCharPointerArgument
     59|   24|{
     59|   25|    NSMethodSignature *signature = [self methodSignature];
    210|   26|    for(NSUInteger i = 0; i < [signature numberOfArguments]; i++)
    151|   27|    {
    151|   28|        const char *argType = OCMTypeWithoutQualifiers([signature getArgumentTypeAtIndex:i]);
    151|   29|        if(strcmp(argType, "*") == 0)
      0|   30|            return YES;
    151|   31|    }
     59|   32|    return NO;
     59|   33|}
       |   34|
       |   35|
       |   36|- (id)getArgumentAtIndexAsObject:(NSInteger)argIndex
     78|   37|{
     78|   38|	const char *argType = OCMTypeWithoutQualifiers([[self methodSignature] getArgumentTypeAtIndex:(NSUInteger)argIndex]);
     78|   39|
     78|   40|	if((strlen(argType) > 1) && (strchr("{^", argType[0]) == NULL) && (strcmp("@?", argType) != 0))
      0|   41|		[NSException raise:NSInvalidArgumentException format:@"Cannot handle argument type '%s'.", argType];
     78|   42|
     78|   43|    if(OCMIsObjectType(argType))
     78|   44|    {
     78|   45|        id value;
     78|   46|     	[self getArgument:&value atIndex:argIndex];
     78|   47|     	return value;
     78|   48|    }
     78|   49|
      0|   50|	switch(argType[0])
      0|   51|	{
      0|   52|		case ':':
      0|   53| 		{
      0|   54| 			SEL s = (SEL)0;
      0|   55| 			[self getArgument:&s atIndex:argIndex];
      0|   56|            return [NSValue valueWithBytes:&s objCType:":"];
      0|   57| 		}
      0|   58|		case 'i': 
      0|   59|		{
      0|   60|			int value;
      0|   61|			[self getArgument:&value atIndex:argIndex];
      0|   62|			return @(value);
      0|   63|		}	
      0|   64|		case 's':
      0|   65|		{
      0|   66|			short value;
      0|   67|			[self getArgument:&value atIndex:argIndex];
      0|   68|			return @(value);
      0|   69|		}	
      0|   70|		case 'l':
      0|   71|		{
      0|   72|			long value;
      0|   73|			[self getArgument:&value atIndex:argIndex];
      0|   74|			return @(value);
      0|   75|		}	
      0|   76|		case 'q':
      0|   77|		{
      0|   78|			long long value;
      0|   79|			[self getArgument:&value atIndex:argIndex];
      0|   80|			return @(value);
      0|   81|		}	
      0|   82|		case 'c':
      0|   83|		{
      0|   84|			char value;
      0|   85|			[self getArgument:&value atIndex:argIndex];
      0|   86|			return @(value);
      0|   87|		}	
      0|   88|		case 'C':
      0|   89|		{
      0|   90|			unsigned char value;
      0|   91|			[self getArgument:&value atIndex:argIndex];
      0|   92|			return @(value);
      0|   93|		}	
      0|   94|		case 'I':
      0|   95|		{
      0|   96|			unsigned int value;
      0|   97|			[self getArgument:&value atIndex:argIndex];
      0|   98|			return @(value);
      0|   99|		}	
      0|  100|		case 'S':
      0|  101|		{
      0|  102|			unsigned short value;
      0|  103|			[self getArgument:&value atIndex:argIndex];
      0|  104|			return @(value);
      0|  105|		}	
      0|  106|		case 'L':
      0|  107|		{
      0|  108|			unsigned long value;
      0|  109|			[self getArgument:&value atIndex:argIndex];
      0|  110|			return @(value);
      0|  111|		}	
      0|  112|		case 'Q':
      0|  113|		{
      0|  114|			unsigned long long value;
      0|  115|			[self getArgument:&value atIndex:argIndex];
      0|  116|			return @(value);
      0|  117|		}	
      0|  118|		case 'f':
      0|  119|		{
      0|  120|			float value;
      0|  121|			[self getArgument:&value atIndex:argIndex];
      0|  122|			return @(value);
      0|  123|		}	
      0|  124|		case 'd':
      0|  125|		{
      0|  126|			double value;
      0|  127|			[self getArgument:&value atIndex:argIndex];
      0|  128|			return @(value);
      0|  129|		}	
      0|  130|		case 'D':
      0|  131|		{
      0|  132|			long double value;
      0|  133|			[self getArgument:&value atIndex:argIndex];
      0|  134|			return [NSValue valueWithBytes:&value objCType:@encode(__typeof__(value))];
      0|  135|		}
      0|  136|		case 'B':
      0|  137|		{
      0|  138|			bool value;
      0|  139|			[self getArgument:&value atIndex:argIndex];
      0|  140|			return @(value);
      0|  141|		}
      0|  142|		case '^':
      0|  143|        case '*':
      0|  144|        {
      0|  145|            void *value = NULL;
      0|  146|            [self getArgument:&value atIndex:argIndex];
      0|  147|            return [NSValue valueWithPointer:value];
      0|  148|        }
      0|  149|		case '{': // structure
      0|  150|		{
      0|  151|			NSUInteger argSize;
      0|  152|			NSGetSizeAndAlignment([[self methodSignature] getArgumentTypeAtIndex:(NSUInteger)argIndex], &argSize, NULL);
      0|  153|			if(argSize == 0) // TODO: Can this happen? Is frameLength a good choice in that case?
      0|  154|                argSize = [[self methodSignature] frameLength];
      0|  155|			NSMutableData *argumentData = [[[NSMutableData alloc] initWithLength:argSize] autorelease];
      0|  156|			[self getArgument:[argumentData mutableBytes] atIndex:argIndex];
      0|  157|			return [NSValue valueWithBytes:[argumentData bytes] objCType:argType];
      0|  158|		}       
      0|  159|			
      0|  160|	}
      0|  161|	[NSException raise:NSInvalidArgumentException format:@"Argument type '%s' not supported", argType];
      0|  162|	return nil;
      0|  163|}
       |  164|
       |  165|- (NSString *)invocationDescription
      0|  166|{
      0|  167|	NSMethodSignature *methodSignature = [self methodSignature];
      0|  168|	NSUInteger numberOfArgs = [methodSignature numberOfArguments];
      0|  169|	
      0|  170|	if (numberOfArgs == 2)
      0|  171|		return NSStringFromSelector([self selector]);
      0|  172|	
      0|  173|	NSArray *selectorParts = [NSStringFromSelector([self selector]) componentsSeparatedByString:@":"];
      0|  174|	NSMutableString *description = [[NSMutableString alloc] init];
      0|  175|	NSUInteger i;
      0|  176|	for(i = 2; i < numberOfArgs; i++)
      0|  177|	{
      0|  178|		[description appendFormat:@"%@%@:", (i > 2 ? @" " : @""), [selectorParts objectAtIndex:(i - 2)]];
      0|  179|		[description appendString:[self argumentDescriptionAtIndex:(NSInteger)i]];
      0|  180|	}
      0|  181|	
      0|  182|	return [description autorelease];
      0|  183|}
       |  184|
       |  185|- (NSString *)argumentDescriptionAtIndex:(NSInteger)argIndex
      0|  186|{
      0|  187|	const char *argType = OCMTypeWithoutQualifiers([[self methodSignature] getArgumentTypeAtIndex:(NSUInteger)argIndex]);
      0|  188|
      0|  189|	switch(*argType)
      0|  190|	{
      0|  191|		case '@':	return [self objectDescriptionAtIndex:argIndex];
      0|  192|		case 'B':	return [self boolDescriptionAtIndex:argIndex];
      0|  193|		case 'c':	return [self charDescriptionAtIndex:argIndex];
      0|  194|		case 'C':	return [self unsignedCharDescriptionAtIndex:argIndex];
      0|  195|		case 'i':	return [self intDescriptionAtIndex:argIndex];
      0|  196|		case 'I':	return [self unsignedIntDescriptionAtIndex:argIndex];
      0|  197|		case 's':	return [self shortDescriptionAtIndex:argIndex];
      0|  198|		case 'S':	return [self unsignedShortDescriptionAtIndex:argIndex];
      0|  199|		case 'l':	return [self longDescriptionAtIndex:argIndex];
      0|  200|		case 'L':	return [self unsignedLongDescriptionAtIndex:argIndex];
      0|  201|		case 'q':	return [self longLongDescriptionAtIndex:argIndex];
      0|  202|		case 'Q':	return [self unsignedLongLongDescriptionAtIndex:argIndex];
      0|  203|		case 'd':	return [self doubleDescriptionAtIndex:argIndex];
      0|  204|		case 'f':	return [self floatDescriptionAtIndex:argIndex];
      0|  205|		case 'D':	return [self longDoubleDescriptionAtIndex:argIndex];
      0|  206|		case '{':	return [self structDescriptionAtIndex:argIndex];
      0|  207|		case '^':	return [self pointerDescriptionAtIndex:argIndex];
      0|  208|		case '*':	return [self cStringDescriptionAtIndex:argIndex];
      0|  209|		case ':':	return [self selectorDescriptionAtIndex:argIndex];
      0|  210|		default:	return [@"<??" stringByAppendingString:@">"];  // avoid confusion with trigraphs...
      0|  211|	}
      0|  212|	
      0|  213|}
       |  214|
       |  215|
       |  216|- (NSString *)objectDescriptionAtIndex:(NSInteger)anInt
      0|  217|{
      0|  218|	id object;
      0|  219|	
      0|  220|	[self getArgument:&object atIndex:anInt];
      0|  221|	if (object == nil)
      0|  222|		return @"nil";
      0|  223|	else if(![object isProxy] && [object isKindOfClass:[NSString class]])
      0|  224|		return [NSString stringWithFormat:@"@\"%@\"", [object description]];
      0|  225|	else
      0|  226|		// The description cannot be nil, if it is then replace it
      0|  227|		return [object description] ?: @"<nil description>";
      0|  228|}
       |  229|
       |  230|- (NSString *)boolDescriptionAtIndex:(NSInteger)anInt
      0|  231|{
      0|  232|	bool value;
      0|  233|	[self getArgument:&value atIndex:anInt];
      0|  234|	return value? @"YES" : @"NO";
      0|  235|}
       |  236|
       |  237|- (NSString *)charDescriptionAtIndex:(NSInteger)anInt
      0|  238|{
      0|  239|	unsigned char buffer[128];
      0|  240|	memset(buffer, 0x0, 128);
      0|  241|	
      0|  242|	[self getArgument:&buffer atIndex:anInt];
      0|  243|	
      0|  244|	// If there's only one character in the buffer, and it's 0 or 1, then we have a BOOL
      0|  245|	if (buffer[1] == '\0' && (buffer[0] == 0 || buffer[0] == 1))
      0|  246|		return (buffer[0] == 1 ? @"YES" : @"NO");
      0|  247|	else
      0|  248|		return [NSString stringWithFormat:@"'%c'", *buffer];
      0|  249|}
       |  250|
       |  251|- (NSString *)unsignedCharDescriptionAtIndex:(NSInteger)anInt
      0|  252|{
      0|  253|	unsigned char buffer[128];
      0|  254|	memset(buffer, 0x0, 128);
      0|  255|	
      0|  256|	[self getArgument:&buffer atIndex:anInt];
      0|  257|	return [NSString stringWithFormat:@"'%c'", *buffer];
      0|  258|}
       |  259|
       |  260|- (NSString *)intDescriptionAtIndex:(NSInteger)anInt
      0|  261|{
      0|  262|	int intValue;
      0|  263|	
      0|  264|	[self getArgument:&intValue atIndex:anInt];
      0|  265|	return [NSString stringWithFormat:@"%d", intValue];
      0|  266|}
       |  267|
       |  268|- (NSString *)unsignedIntDescriptionAtIndex:(NSInteger)anInt
      0|  269|{
      0|  270|	unsigned int intValue;
      0|  271|	
      0|  272|	[self getArgument:&intValue atIndex:anInt];
      0|  273|	return [NSString stringWithFormat:@"%d", intValue];
      0|  274|}
       |  275|
       |  276|- (NSString *)shortDescriptionAtIndex:(NSInteger)anInt
      0|  277|{
      0|  278|	short shortValue;
      0|  279|	
      0|  280|	[self getArgument:&shortValue atIndex:anInt];
      0|  281|	return [NSString stringWithFormat:@"%hi", shortValue];
      0|  282|}
       |  283|
       |  284|- (NSString *)unsignedShortDescriptionAtIndex:(NSInteger)anInt
      0|  285|{
      0|  286|	unsigned short shortValue;
      0|  287|	
      0|  288|	[self getArgument:&shortValue atIndex:anInt];
      0|  289|	return [NSString stringWithFormat:@"%hu", shortValue];
      0|  290|}
       |  291|
       |  292|- (NSString *)longDescriptionAtIndex:(NSInteger)anInt
      0|  293|{
      0|  294|	long longValue;
      0|  295|	
      0|  296|	[self getArgument:&longValue atIndex:anInt];
      0|  297|	return [NSString stringWithFormat:@"%ld", longValue];
      0|  298|}
       |  299|
       |  300|- (NSString *)unsignedLongDescriptionAtIndex:(NSInteger)anInt
      0|  301|{
      0|  302|	unsigned long longValue;
      0|  303|	
      0|  304|	[self getArgument:&longValue atIndex:anInt];
      0|  305|	return [NSString stringWithFormat:@"%lu", longValue];
      0|  306|}
       |  307|
       |  308|- (NSString *)longLongDescriptionAtIndex:(NSInteger)anInt
      0|  309|{
      0|  310|	long long longLongValue;
      0|  311|	
      0|  312|	[self getArgument:&longLongValue atIndex:anInt];
      0|  313|	return [NSString stringWithFormat:@"%qi", longLongValue];
      0|  314|}
       |  315|
       |  316|- (NSString *)unsignedLongLongDescriptionAtIndex:(NSInteger)anInt
      0|  317|{
      0|  318|	unsigned long long longLongValue;
      0|  319|	
      0|  320|	[self getArgument:&longLongValue atIndex:anInt];
      0|  321|	return [NSString stringWithFormat:@"%qu", longLongValue];
      0|  322|}
       |  323|
       |  324|- (NSString *)doubleDescriptionAtIndex:(NSInteger)anInt
      0|  325|{
      0|  326|	double doubleValue;
      0|  327|	
      0|  328|	[self getArgument:&doubleValue atIndex:anInt];
      0|  329|	return [NSString stringWithFormat:@"%f", doubleValue];
      0|  330|}
       |  331|
       |  332|- (NSString *)floatDescriptionAtIndex:(NSInteger)anInt
      0|  333|{
      0|  334|	float floatValue;
      0|  335|	
      0|  336|	[self getArgument:&floatValue atIndex:anInt];
      0|  337|	return [NSString stringWithFormat:@"%f", floatValue];
      0|  338|}
       |  339|
       |  340|- (NSString *)longDoubleDescriptionAtIndex:(NSInteger)anInt
      0|  341|{
      0|  342|	long double longDoubleValue;
      0|  343|	
      0|  344|	[self getArgument:&longDoubleValue atIndex:anInt];
      0|  345|	return [NSString stringWithFormat:@"%Lf", longDoubleValue];
      0|  346|}
       |  347|
       |  348|- (NSString *)structDescriptionAtIndex:(NSInteger)anInt
      0|  349|{
      0|  350|    return [NSString stringWithFormat:@"(%@)", [[self getArgumentAtIndexAsObject:anInt] description]];
      0|  351|}
       |  352|
       |  353|- (NSString *)pointerDescriptionAtIndex:(NSInteger)anInt
      0|  354|{
      0|  355|	void *buffer;
      0|  356|	
      0|  357|	[self getArgument:&buffer atIndex:anInt];
      0|  358|	return [NSString stringWithFormat:@"%p", buffer];
      0|  359|}
       |  360|
       |  361|- (NSString *)cStringDescriptionAtIndex:(NSInteger)anInt
      0|  362|{
      0|  363|	char buffer[104];
      0|  364|	char *cStringPtr;
      0|  365|	
      0|  366|	[self getArgument:&cStringPtr atIndex:anInt];
      0|  367|	strlcpy(buffer, cStringPtr, sizeof(buffer));
      0|  368|	strlcpy(buffer + 100, "...", (sizeof(buffer) - 100));
      0|  369|	return [NSString stringWithFormat:@"\"%s\"", buffer];
      0|  370|}
       |  371|
       |  372|- (NSString *)selectorDescriptionAtIndex:(NSInteger)anInt
      0|  373|{
      0|  374|	SEL selectorValue;
      0|  375|	
      0|  376|	[self getArgument:&selectorValue atIndex:anInt];
      0|  377|	return [NSString stringWithFormat:@"@selector(%@)", NSStringFromSelector(selectorValue)];
      0|  378|}
       |  379|
       |  380|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/NSMethodSignature+OCMAdditions.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "NSMethodSignature+OCMAdditions.h"
       |   18|#import "OCMFunctions.h"
       |   19|#import <objc/runtime.h>
       |   20|
       |   21|
       |   22|@implementation NSMethodSignature(OCMAdditions)
       |   23|
       |   24|- (BOOL)usesSpecialStructureReturn
    124|   25|{
    124|   26|    const char *types = OCMTypeWithoutQualifiers([self methodReturnType]);
    124|   27|
    124|   28|    if((types == NULL) || (types[0] != '{'))
    122|   29|        return NO;
    124|   30|
    124|   31|    /* In some cases structures are returned by ref. The rules are complex and depend on the
    124|   32|       architecture, see:
    124|   33|
    124|   34|       http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html
    124|   35|       http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/LowLevelABI/000-Introduction/introduction.html
    124|   36|       https://github.com/atgreen/libffi/blob/master/src/x86/ffi64.c
    124|   37|       http://www.uclibc.org/docs/psABI-x86_64.pdf
    124|   38|       http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf
    124|   39|
    124|   40|       NSMethodSignature knows the details but has no API to return it, though it is in
    124|   41|       the debugDescription. Horribly kludgy.
    124|   42|    */
      2|   43|    NSRange range = [[self debugDescription] rangeOfString:@"is special struct return? YES"];
      2|   44|    return range.length > 0;
    124|   45|}
       |   46|
       |   47|- (NSString *)fullTypeString
      0|   48|{
      0|   49|    NSMutableString *typeString = [NSMutableString string];
      0|   50|    [typeString appendFormat:@"%s", [self methodReturnType]];
      0|   51|    for (NSUInteger i=0; i<[self numberOfArguments]; i++)
      0|   52|        [typeString appendFormat:@"%s", [self getArgumentTypeAtIndex:i]];
      0|   53|    return typeString;
      0|   54|}
       |   55|
       |   56|- (const char *)fullObjCTypes
      0|   57|{
      0|   58|    return [[self fullTypeString] UTF8String];
      0|   59|}
       |   60|
       |   61|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/NSNotificationCenter+OCMAdditions.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "NSNotificationCenter+OCMAdditions.h"
       |   18|#import "OCObserverMockObject.h"
       |   19|
       |   20|
       |   21|@implementation NSNotificationCenter(OCMAdditions)
       |   22|
       |   23|- (void)addMockObserver:(OCObserverMockObject *)notificationObserver name:(NSString *)notificationName object:(id)notificationSender
      0|   24|{
      0|   25|    [notificationObserver autoRemoveFromCenter:self];
      0|   26|	[self addObserver:notificationObserver selector:@selector(handleNotification:) name:notificationName object:notificationSender];
      0|   27|}
       |   28|
       |   29|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/NSObject+OCMAdditions.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "NSObject+OCMAdditions.h"
       |   18|#import "NSMethodSignature+OCMAdditions.h"
       |   19|#import <objc/runtime.h>
       |   20|
       |   21|@implementation NSObject(OCMAdditions)
       |   22|
       |   23|+ (IMP)instanceMethodForwarderForSelector:(SEL)aSelector
    435|   24|{
    435|   25|    // use sel_registerName() and not @selector to avoid warning
    435|   26|    SEL selectorWithNoImplementation = sel_registerName("methodWhichMustNotExist::::");
    435|   27|
    435|   28|#ifndef __arm64__
    435|   29|    static NSMutableDictionary *_OCMReturnTypeCache;
    435|   30|    
    435|   31|    if(_OCMReturnTypeCache == nil)
      1|   32|        _OCMReturnTypeCache = [[NSMutableDictionary alloc] init];
    435|   33|
    435|   34|    BOOL needsStructureReturn;
    435|   35|    void *rawCacheKey[2] = { (void *)self, aSelector };
    435|   36|    NSData *cacheKey = [NSData dataWithBytes:rawCacheKey length:sizeof(rawCacheKey)];
    435|   37|    NSNumber *cachedValue = [_OCMReturnTypeCache objectForKey:cacheKey];
    435|   38|
    435|   39|    if(cachedValue == nil)
    124|   40|    {
    124|   41|        NSMethodSignature *sig = [self instanceMethodSignatureForSelector:aSelector];
    124|   42|        needsStructureReturn = [sig usesSpecialStructureReturn];
    124|   43|        [_OCMReturnTypeCache setObject:@(needsStructureReturn) forKey:cacheKey];
    124|   44|    }
    435|   45|    else
    311|   46|    {
    311|   47|        needsStructureReturn = [cachedValue boolValue];
    311|   48|    }
    435|   49|
    435|   50|    if(needsStructureReturn)
      3|   51|        return class_getMethodImplementation_stret([NSObject class], selectorWithNoImplementation);
    435|   52|#endif
    435|   53|    
    432|   54|    return class_getMethodImplementation([NSObject class], selectorWithNoImplementation);
    435|   55|}
       |   56|
       |   57|
       |   58|+ (void)enumerateMethodsInClass:(Class)aClass usingBlock:(void (^)(Class cls, SEL sel))aBlock
     27|   59|{
     99|   60|    for(Class cls = aClass; cls != nil; cls = class_getSuperclass(cls))
     72|   61|    {
     72|   62|        Method *methodList = class_copyMethodList(cls, NULL);
     72|   63|        if(methodList == NULL)
      7|   64|            continue;
     72|   65|
  34.1k|   66|        for(Method *mPtr = methodList; *mPtr != NULL; mPtr++)
  34.0k|   67|        {
  34.0k|   68|            SEL sel = method_getName(*mPtr);
  34.0k|   69|            aBlock(cls, sel);
  34.0k|   70|        }
     65|   71|        free(methodList);
     65|   72|    }
     27|   73|}
       |   74|
       |   75|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/NSValue+OCMAdditions.m:
       |    1|/*
       |    2| *  Copyright (c) 2014-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "NSValue+OCMAdditions.h"
       |   18|
       |   19|
       |   20|@implementation NSValue(OCMAdditions)
       |   21|
       |   22|static CFNumberType OCMNumberTypeForObjCType(const char *objcType)
      0|   23|{
      0|   24|    switch (objcType[0])
      0|   25|    {
      0|   26|        case 'c': return kCFNumberCharType;
      0|   27|        case 'C': return kCFNumberCharType;
      0|   28|        case 'B': return kCFNumberCharType;
      0|   29|        case 's': return kCFNumberShortType;
      0|   30|        case 'S': return kCFNumberShortType;
      0|   31|        case 'i': return kCFNumberIntType;
      0|   32|        case 'I': return kCFNumberIntType;
      0|   33|        case 'l': return kCFNumberLongType;
      0|   34|        case 'L': return kCFNumberLongType;
      0|   35|        case 'q': return kCFNumberLongLongType;
      0|   36|        case 'Q': return kCFNumberLongLongType;
      0|   37|        case 'f': return kCFNumberFloatType;
      0|   38|        case 'd': return kCFNumberDoubleType;
      0|   39|        default:  return 0;
      0|   40|    }
      0|   41|}
       |   42|
       |   43|
       |   44|static NSNumber *OCMNumberForValue(NSValue *value)
      0|   45|{
      0|   46|#define CREATE_NUM(_type) ({ _type _v; [value getValue:&_v]; @(_v); })
      0|   47|    switch([value objCType][0])
      0|   48|    {
      0|   49|        case 'c': return CREATE_NUM(char);
      0|   50|        case 'C': return CREATE_NUM(unsigned char);
      0|   51|        case 'B': return CREATE_NUM(bool);
      0|   52|        case 's': return CREATE_NUM(short);
      0|   53|        case 'S': return CREATE_NUM(unsigned short);
      0|   54|        case 'i': return CREATE_NUM(int);
      0|   55|        case 'I': return CREATE_NUM(unsigned int);
      0|   56|        case 'l': return CREATE_NUM(long);
      0|   57|        case 'L': return CREATE_NUM(unsigned long);
      0|   58|        case 'q': return CREATE_NUM(long long);
      0|   59|        case 'Q': return CREATE_NUM(unsigned long long);
      0|   60|        case 'f': return CREATE_NUM(float);
      0|   61|        case 'd': return CREATE_NUM(double);
      0|   62|        default:  return nil;
      0|   63|    }
      0|   64|}
       |   65|
       |   66|
       |   67|- (BOOL)getBytes:(void *)outputBuf objCType:(const char *)targetType
      0|   68|{
      0|   69|    /*
      0|   70|     * See if they are similar number types, and if we can convert losslessly between them.
      0|   71|     * For the most part, we set things up to use CFNumberGetValue, which returns false if
      0|   72|     * conversion will be lossy.
      0|   73|     */
      0|   74|    CFNumberType inputType = OCMNumberTypeForObjCType([self objCType]);
      0|   75|    CFNumberType outputType = OCMNumberTypeForObjCType(targetType);
      0|   76|
      0|   77|    if(inputType == 0 || outputType == 0) // one or both are non-number types
      0|   78|        return NO;
      0|   79|
      0|   80|    NSNumber *inputNumber = [self isKindOfClass:[NSNumber class]] ? (NSNumber *)self : OCMNumberForValue(self);
      0|   81|
      0|   82|    /*
      0|   83|     * Due to some legacy, back-compatible requirements in CFNumber.c, CFNumberGetValue can return true for
      0|   84|     * some conversions which should not be allowed (by reading source, conversions from integer types to
      0|   85|     * 8-bit or 16-bit integer types).  So, check ourselves.
      0|   86|     */
      0|   87|    long long min;
      0|   88|    long long max;
      0|   89|    long long val = [inputNumber longLongValue];
      0|   90|    switch(targetType[0])
      0|   91|    {
      0|   92|        case 'B':
      0|   93|        case 'c': min =  CHAR_MIN; max =  CHAR_MAX; break;
      0|   94|        case 'C': min =         0; max = UCHAR_MAX; break;
      0|   95|        case 's': min =  SHRT_MIN; max =  SHRT_MAX; break;
      0|   96|        case 'S': min =         0; max = USHRT_MAX; break;
      0|   97|        default:  min = LLONG_MIN; max = LLONG_MAX; break;
      0|   98|    }
      0|   99|    if(val < min || val > max)
      0|  100|        return NO;
      0|  101|
      0|  102|    /* Get the number, and return NO if the value was out of range or conversion was lossy */
      0|  103|    return CFNumberGetValue((CFNumberRef)inputNumber, outputType, outputBuf);
      0|  104|}
       |  105|
       |  106|
       |  107|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCClassMockObject.m:
       |    1|/*
       |    2| *  Copyright (c) 2005-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <objc/runtime.h>
       |   18|#import "OCClassMockObject.h"
       |   19|#import "NSObject+OCMAdditions.h"
       |   20|#import "OCMFunctions.h"
       |   21|#import "OCMInvocationStub.h"
       |   22|
       |   23|@implementation OCClassMockObject
       |   24|
       |   25|#pragma mark  Initialisers, description, accessors, etc.
       |   26|
       |   27|- (id)initWithClass:(Class)aClass
     19|   28|{
     19|   29|    NSParameterAssert(aClass != nil);
     19|   30|	[super init];
     19|   31|	mockedClass = aClass;
     19|   32|    [self prepareClassForClassMethodMocking];
     19|   33|	return self;
     19|   34|}
       |   35|
       |   36|- (void)dealloc
     18|   37|{
     18|   38|	[self stopMocking];
     18|   39|	[super dealloc];
     18|   40|}
       |   41|
       |   42|- (NSString *)description
      0|   43|{
      0|   44|	return [NSString stringWithFormat:@"OCMockObject(%@)", NSStringFromClass(mockedClass)];
      0|   45|}
       |   46|
       |   47|- (Class)mockedClass
    367|   48|{
    367|   49|	return mockedClass;
    367|   50|}
       |   51|
       |   52|#pragma mark  Extending/overriding superclass behaviour
       |   53|
       |   54|- (void)stopMocking
     26|   55|{
     26|   56|    if(originalMetaClass != nil)
     11|   57|        [self restoreMetaClass];
     26|   58|    [super stopMocking];
     26|   59|}
       |   60|
       |   61|- (void)restoreMetaClass
     18|   62|{
     18|   63|    OCMSetAssociatedMockForClass(nil, mockedClass);
     18|   64|    OCMSetIsa(mockedClass, originalMetaClass);
     18|   65|    originalMetaClass = nil;
     18|   66|}
       |   67|
       |   68|- (void)addStub:(OCMInvocationStub *)aStub
     59|   69|{
     59|   70|    [super addStub:aStub];
     59|   71|    if([aStub recordedAsClassMethod])
      5|   72|        [self setupForwarderForClassMethodSelector:[[aStub recordedInvocation] selector]];
     59|   73|}
       |   74|
       |   75|
       |   76|#pragma mark  Class method mocking
       |   77|
       |   78|- (void)prepareClassForClassMethodMocking
     19|   79|{
     19|   80|    /* haven't figured out how to work around runtime dependencies on NSString, so exclude it for now */
     19|   81|    /* also weird: [[NSString class] isKindOfClass:[NSString class]] is false, hence the additional clause */
     19|   82|    if([[mockedClass class] isKindOfClass:[NSString class]] || (mockedClass == [NSString class]))
      0|   83|        return;
     19|   84|
     19|   85|    /* if there is another mock for this exact class, stop it */
     19|   86|    id otherMock = OCMGetAssociatedMockForClass(mockedClass, NO);
     19|   87|    if(otherMock != nil)
      7|   88|        [otherMock restoreMetaClass];
     19|   89|
     19|   90|    OCMSetAssociatedMockForClass(self, mockedClass);
     19|   91|
     19|   92|    /* dynamically create a subclass and use its meta class as the meta class for the mocked class */
     19|   93|    Class subclass = OCMCreateSubclass(mockedClass, mockedClass);
     19|   94|    originalMetaClass = object_getClass(mockedClass);
     19|   95|    id newMetaClass = object_getClass(subclass);
     19|   96|    OCMSetIsa(mockedClass, OCMGetIsa(subclass));
     19|   97|
     19|   98|    /* point forwardInvocation: of the object to the implementation in the mock */
     19|   99|    Method myForwardMethod = class_getInstanceMethod([self mockObjectClass], @selector(forwardInvocationForClassObject:));
     19|  100|    IMP myForwardIMP = method_getImplementation(myForwardMethod);
     19|  101|    class_addMethod(newMetaClass, @selector(forwardInvocation:), myForwardIMP, method_getTypeEncoding(myForwardMethod));
     19|  102|
     19|  103|    /* create a dummy initialize method */
     19|  104|    Method myDummyInitializeMethod = class_getInstanceMethod([self mockObjectClass], @selector(initializeForClassObject));
     19|  105|    const char *initializeTypes = method_getTypeEncoding(myDummyInitializeMethod);
     19|  106|    IMP myDummyInitializeIMP = method_getImplementation(myDummyInitializeMethod);
     19|  107|    class_addMethod(newMetaClass, @selector(initialize), myDummyInitializeIMP, initializeTypes);
     19|  108|
     19|  109|    /* adding forwarder for most class methods (instance methods on meta class) to allow for verify after run */
     19|  110|    NSArray *methodBlackList = @[@"class", @"forwardingTargetForSelector:", @"methodSignatureForSelector:", @"forwardInvocation:", @"isBlock",
     19|  111|            @"instanceMethodForwarderForSelector:", @"instanceMethodSignatureForSelector:"];
  24.6k|  112|    [NSObject enumerateMethodsInClass:originalMetaClass usingBlock:^(Class cls, SEL sel) {
  24.6k|  113|        if((cls == object_getClass([NSObject class])) || (cls == [NSObject class]) || (cls == object_getClass(cls)))
  24.6k|  114|            return;
     32|  115|        NSString *className = NSStringFromClass(cls);
     32|  116|        NSString *selName = NSStringFromSelector(sel);
     32|  117|        if(([className hasPrefix:@"NS"] || [className hasPrefix:@"UI"]) &&
      0|  118|           ([selName hasPrefix:@"_"] || [selName hasSuffix:@"_"]))
      0|  119|            return;
     32|  120|        if([methodBlackList containsObject:selName])
      0|  121|            return;
     32|  122|        @try
     32|  123|        {
     32|  124|            [self setupForwarderForClassMethodSelector:sel];
     32|  125|        }
     32|  126|        @catch(NSException *e)
     32|  127|        {
     32|  128|            // ignore for now
     32|  129|        }
     32|  130|    }];
     19|  131|}
       |  132|
       |  133|- (void)setupForwarderForClassMethodSelector:(SEL)selector
     37|  134|{
     37|  135|    SEL aliasSelector = OCMAliasForOriginalSelector(selector);
     37|  136|    if(class_getClassMethod(mockedClass, aliasSelector) != NULL)
      5|  137|        return;
     37|  138|
     32|  139|    Method originalMethod = class_getClassMethod(mockedClass, selector);
     32|  140|    IMP originalIMP = method_getImplementation(originalMethod);
     32|  141|    const char *types = method_getTypeEncoding(originalMethod);
     32|  142|
     32|  143|    Class metaClass = object_getClass(mockedClass);
     32|  144|    IMP forwarderIMP = [originalMetaClass instanceMethodForwarderForSelector:selector];
     32|  145|    class_replaceMethod(metaClass, selector, forwarderIMP, types);
     32|  146|    class_addMethod(metaClass, aliasSelector, originalIMP, types);
     32|  147|}
       |  148|
       |  149|
       |  150|- (void)forwardInvocationForClassObject:(NSInvocation *)anInvocation
      2|  151|{
      2|  152|	// in here "self" is a reference to the real class, not the mock
      2|  153|	OCClassMockObject *mock = OCMGetAssociatedMockForClass((Class) self, YES);
      2|  154|    if(mock == nil)
      0|  155|    {
      0|  156|        [NSException raise:NSInternalInconsistencyException format:@"No mock for class %@", NSStringFromClass((Class)self)];
      0|  157|    }
      2|  158|	if([mock handleInvocation:anInvocation] == NO)
      0|  159|    {
      0|  160|        [anInvocation setSelector:OCMAliasForOriginalSelector([anInvocation selector])];
      0|  161|        [anInvocation invoke];
      0|  162|    }
      2|  163|}
       |  164|
       |  165|- (void)initializeForClassObject
     27|  166|{
     27|  167|    // we really just want to have an implementation so that the superclass's is not called
     27|  168|}
       |  169|
       |  170|
       |  171|#pragma mark  Proxy API
       |  172|
       |  173|- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
     91|  174|{
     91|  175|    return [mockedClass instanceMethodSignatureForSelector:aSelector];
     91|  176|}
       |  177|
       |  178|- (Class)mockObjectClass
     63|  179|{
     63|  180|    return [super class];
     63|  181|}
       |  182|
       |  183|- (Class)class
    138|  184|{
    138|  185|    return mockedClass;
    138|  186|}
       |  187|
       |  188|- (BOOL)respondsToSelector:(SEL)selector
      0|  189|{
      0|  190|    return [mockedClass instancesRespondToSelector:selector];
      0|  191|}
       |  192|
       |  193|- (BOOL)isKindOfClass:(Class)aClass
      1|  194|{
      1|  195|    return [mockedClass isSubclassOfClass:aClass];
      1|  196|}
       |  197|
       |  198|- (BOOL)conformsToProtocol:(Protocol *)aProtocol
      0|  199|{
      0|  200|    return class_conformsToProtocol(mockedClass, aProtocol);
      0|  201|}
       |  202|
       |  203|@end
       |  204|
       |  205|
       |  206|#pragma mark  -
       |  207|
       |  208|/**
       |  209| taken from:
       |  210| `class-dump -f isNS /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.0.sdk/System/Library/Frameworks/CoreFoundation.framework`
       |  211| 
       |  212| @interface NSObject (__NSIsKinds)
       |  213| - (_Bool)isNSValue__;
       |  214| - (_Bool)isNSTimeZone__;
       |  215| - (_Bool)isNSString__;
       |  216| - (_Bool)isNSSet__;
       |  217| - (_Bool)isNSOrderedSet__;
       |  218| - (_Bool)isNSNumber__;
       |  219| - (_Bool)isNSDictionary__;
       |  220| - (_Bool)isNSDate__;
       |  221| - (_Bool)isNSData__;
       |  222| - (_Bool)isNSArray__;
       |  223| */
       |  224|
       |  225|@implementation OCClassMockObject(NSIsKindsImplementation)
       |  226|
       |  227|- (BOOL)isNSValue__
      0|  228|{
      0|  229|    return [mockedClass isKindOfClass:[NSValue class]];
      0|  230|}
       |  231|
       |  232|- (BOOL)isNSTimeZone__
      0|  233|{
      0|  234|    return [mockedClass isKindOfClass:[NSTimeZone class]];
      0|  235|}
       |  236|
       |  237|- (BOOL)isNSSet__
      0|  238|{
      0|  239|    return [mockedClass isKindOfClass:[NSSet class]];
      0|  240|}
       |  241|
       |  242|- (BOOL)isNSOrderedSet__
      0|  243|{
      0|  244|    return [mockedClass isKindOfClass:[NSOrderedSet class]];
      0|  245|}
       |  246|
       |  247|- (BOOL)isNSNumber__
      0|  248|{
      0|  249|    return [mockedClass isKindOfClass:[NSNumber class]];
      0|  250|}
       |  251|
       |  252|- (BOOL)isNSDate__
      0|  253|{
      0|  254|    return [mockedClass isKindOfClass:[NSDate class]];
      0|  255|}
       |  256|
       |  257|- (BOOL)isNSString__
      0|  258|{
      0|  259|    return [mockedClass isKindOfClass:[NSString class]];
      0|  260|}
       |  261|
       |  262|- (BOOL)isNSDictionary__
      0|  263|{
      0|  264|    return [mockedClass isKindOfClass:[NSDictionary class]];
      0|  265|}
       |  266|
       |  267|- (BOOL)isNSData__
      0|  268|{
      0|  269|    return [mockedClass isKindOfClass:[NSData class]];
      0|  270|}
       |  271|
       |  272|- (BOOL)isNSArray__
      0|  273|{
      0|  274|    return [mockedClass isKindOfClass:[NSArray class]];
      0|  275|}
       |  276|
       |  277|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMArg.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <objc/runtime.h>
       |   18|#import <OCMock/OCMArg.h>
       |   19|#import <OCMock/OCMConstraint.h>
       |   20|#import "OCMPassByRefSetter.h"
       |   21|
       |   22|@implementation OCMArg
       |   23|
       |   24|+ (id)any
      5|   25|{
      5|   26|	return [OCMAnyConstraint constraint];
      5|   27|}
       |   28|
       |   29|+ (void *)anyPointer
      0|   30|{
      0|   31|	return (void *)0x01234567;
      0|   32|}
       |   33|
       |   34|+ (id __autoreleasing *)anyObjectRef
      0|   35|{
      0|   36|    return (id *)0x01234567;
      0|   37|}
       |   38|
       |   39|+ (SEL)anySelector
      0|   40|{
      0|   41|    return NSSelectorFromString(@"aSelectorThatMatchesAnySelector");
      0|   42|}
       |   43|
       |   44|+ (id)isNil
      0|   45|{
      0|   46|	return [OCMIsNilConstraint constraint];
      0|   47|}
       |   48|
       |   49|+ (id)isNotNil
      0|   50|{
      0|   51|	return [OCMIsNotNilConstraint constraint];
      0|   52|}
       |   53|
       |   54|+ (id)isEqual:(id)value
      0|   55|{
      0|   56|    return value;
      0|   57|}
       |   58|
       |   59|+ (id)isNotEqual:(id)value
      0|   60|{
      0|   61|	OCMIsNotEqualConstraint *constraint = [OCMIsNotEqualConstraint constraint];
      0|   62|	constraint->testValue = value;
      0|   63|	return constraint;
      0|   64|}
       |   65|
       |   66|+ (id)isKindOfClass:(Class)cls
      0|   67|{
      0|   68|	return [[[OCMBlockConstraint alloc] initWithConstraintBlock:^BOOL(id obj) {
      0|   69|        return [obj isKindOfClass:cls];
      0|   70|    }] autorelease];
      0|   71|}
       |   72|
       |   73|+ (id)checkWithSelector:(SEL)selector onObject:(id)anObject
      0|   74|{
      0|   75|	return [OCMConstraint constraintWithSelector:selector onObject:anObject];
      0|   76|}
       |   77|
       |   78|+ (id)checkWithBlock:(BOOL (^)(id))block
      0|   79|{
      0|   80|	return [[[OCMBlockConstraint alloc] initWithConstraintBlock:block] autorelease];
      0|   81|}
       |   82|
       |   83|+ (id *)setTo:(id)value
      0|   84|{
      0|   85|	return (id *)[[[OCMPassByRefSetter alloc] initWithValue:value] autorelease];
      0|   86|}
       |   87|
       |   88|+ (void *)setToValue:(NSValue *)value
      0|   89|{
      0|   90|	return (id *)[[[OCMPassByRefSetter alloc] initWithValue:value] autorelease];
      0|   91|}
       |   92|
       |   93|+ (id)resolveSpecialValues:(NSValue *)value
      0|   94|{
      0|   95|	const char *type = [value objCType];
      0|   96|	if(type[0] == '^')
      0|   97|	{
      0|   98|		void *pointer = [value pointerValue];
      0|   99|		if(pointer == (void *)0x01234567)
      0|  100|			return [OCMArg any];
      0|  101|		if((pointer != NULL) && (object_getClass((id)pointer) == [OCMPassByRefSetter class]))
      0|  102|			return (id)pointer;
      0|  103|	}
      0|  104|    else if(type[0] == ':')
      0|  105|    {
      0|  106|        SEL selector;
      0|  107|        [value getValue:&selector];
      0|  108|        if(selector == NSSelectorFromString(@"aSelectorThatMatchesAnySelector"))
      0|  109|            return [OCMArg any];
      0|  110|    }
      0|  111|	return value;
      0|  112|}
       |  113|
       |  114|
       |  115|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMBlockCaller.m:
       |    1|/*
       |    2| *  Copyright (c) 2010-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCMBlockCaller.h"
       |   18|
       |   19|
       |   20|@implementation OCMBlockCaller
       |   21|
       |   22|-(id)initWithCallBlock:(void (^)(NSInvocation *))theBlock 
      5|   23|{
      5|   24|    if ((self = [super init]))
      5|   25|    {
      5|   26|        block = [theBlock copy];
      5|   27|    }
      5|   28|    
      5|   29|	return self;
      5|   30|}
       |   31|
       |   32|-(void)dealloc 
      5|   33|{
      5|   34|	[block release];
      5|   35|	[super dealloc];
      5|   36|}
       |   37|
       |   38|- (void)handleInvocation:(NSInvocation *)anInvocation
      1|   39|{
      1|   40|    if (block != nil)
      1|   41|    {
      1|   42|        block(anInvocation);
      1|   43|    }
      1|   44|}
       |   45|
       |   46|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMBoxedReturnValueProvider.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCMBoxedReturnValueProvider.h"
       |   18|#import "OCMFunctions.h"
       |   19|#import "NSValue+OCMAdditions.h"
       |   20|
       |   21|@implementation OCMBoxedReturnValueProvider
       |   22|
       |   23|- (void)handleInvocation:(NSInvocation *)anInvocation
      3|   24|{
      3|   25|	const char *returnType = [[anInvocation methodSignature] methodReturnType];
      3|   26|    NSUInteger returnTypeSize = [[anInvocation methodSignature] methodReturnLength];
      3|   27|    char valueBuffer[returnTypeSize];
      3|   28|    NSValue *returnValueAsNSValue = (NSValue *)returnValue;
      3|   29|
      3|   30|    if([self isMethodReturnType:returnType compatibleWithValueType:[returnValueAsNSValue objCType]])
      3|   31|    {
      3|   32|        [returnValueAsNSValue getValue:valueBuffer];
      3|   33|        [anInvocation setReturnValue:valueBuffer];
      3|   34|    }
      0|   35|    else if([returnValueAsNSValue getBytes:valueBuffer objCType:returnType])
      0|   36|    {
      0|   37|        [anInvocation setReturnValue:valueBuffer];
      0|   38|    }
      0|   39|    else
      0|   40|    {
      0|   41|        [NSException raise:NSInvalidArgumentException
      0|   42|                    format:@"Return value cannot be used for method; method signature declares '%s' but value is '%s'.", returnType, [returnValueAsNSValue objCType]];
      0|   43|    }
      3|   44|}
       |   45|
       |   46|
       |   47|- (BOOL)isMethodReturnType:(const char *)returnType compatibleWithValueType:(const char *)valueType
      3|   48|{
      3|   49|    /* Same types are obviously compatible */
      3|   50|    if(strcmp(returnType, valueType) == 0)
      3|   51|        return YES;
      3|   52|
      3|   53|    /* Allow void* for methods that return id, mainly to be able to handle nil */
      0|   54|    if(strcmp(returnType, @encode(id)) == 0 && strcmp(valueType, @encode(void *)) == 0)
      0|   55|        return YES;
      0|   56|
      0|   57|    return OCMEqualTypesAllowingOpaqueStructs(returnType, valueType);
      0|   58|}
       |   59|
       |   60|
       |   61|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMConstraint.m:
       |    1|/*
       |    2| *  Copyright (c) 2007-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <OCMock/OCMConstraint.h>
       |   18|
       |   19|
       |   20|@implementation OCMConstraint
       |   21|
       |   22|+ (instancetype)constraint
      5|   23|{
      5|   24|	return [[[self alloc] init] autorelease];
      5|   25|}
       |   26|
       |   27|- (BOOL)evaluate:(id)value
      0|   28|{
      0|   29|	return NO;
      0|   30|}
       |   31|
       |   32|- (id)copyWithZone:(struct _NSZone *)zone
      5|   33|{
      5|   34|    return [self retain];
      5|   35|}
       |   36|
       |   37|+ (instancetype)constraintWithSelector:(SEL)aSelector onObject:(id)anObject
      0|   38|{
      0|   39|	OCMInvocationConstraint *constraint = [OCMInvocationConstraint constraint];
      0|   40|	NSMethodSignature *signature = [anObject methodSignatureForSelector:aSelector]; 
      0|   41|	if(signature == nil)
      0|   42|		[NSException raise:NSInvalidArgumentException format:@"Unkown selector %@ used in constraint.", NSStringFromSelector(aSelector)];
      0|   43|	NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
      0|   44|	[invocation setTarget:anObject];
      0|   45|	[invocation setSelector:aSelector];
      0|   46|	constraint->invocation = invocation;
      0|   47|	return constraint;
      0|   48|}
       |   49|
       |   50|+ (instancetype)constraintWithSelector:(SEL)aSelector onObject:(id)anObject withValue:(id)aValue
      0|   51|{
      0|   52|	OCMInvocationConstraint *constraint = [self constraintWithSelector:aSelector onObject:anObject];
      0|   53|	if([[constraint->invocation methodSignature] numberOfArguments] < 4)
      0|   54|		[NSException raise:NSInvalidArgumentException format:@"Constraint with value requires selector with two arguments."];
      0|   55|	[constraint->invocation setArgument:&aValue atIndex:3];
      0|   56|	return constraint;
      0|   57|}
       |   58|
       |   59|
       |   60|@end
       |   61|
       |   62|
       |   63|
       |   64|#pragma mark  -
       |   65|
       |   66|@implementation OCMAnyConstraint
       |   67|
       |   68|- (BOOL)evaluate:(id)value
      1|   69|{
      1|   70|	return YES;
      1|   71|}
       |   72|
       |   73|@end
       |   74|
       |   75|
       |   76|
       |   77|#pragma mark  -
       |   78|
       |   79|@implementation OCMIsNilConstraint
       |   80|
       |   81|- (BOOL)evaluate:(id)value
      0|   82|{
      0|   83|	return value == nil;
      0|   84|}
       |   85|
       |   86|@end
       |   87|
       |   88|
       |   89|
       |   90|#pragma mark  -
       |   91|
       |   92|@implementation OCMIsNotNilConstraint
       |   93|
       |   94|- (BOOL)evaluate:(id)value
      0|   95|{
      0|   96|	return value != nil;
      0|   97|}
       |   98|
       |   99|@end
       |  100|
       |  101|
       |  102|
       |  103|#pragma mark  -
       |  104|
       |  105|@implementation OCMIsNotEqualConstraint
       |  106|
       |  107|- (BOOL)evaluate:(id)value
      0|  108|{
      0|  109|	return ![value isEqual:testValue];
      0|  110|}
       |  111|
       |  112|@end
       |  113|
       |  114|
       |  115|
       |  116|#pragma mark  -
       |  117|
       |  118|@implementation OCMInvocationConstraint
       |  119|
       |  120|- (BOOL)evaluate:(id)value
      0|  121|{
      0|  122|	[invocation setArgument:&value atIndex:2]; // should test if constraint takes arg
      0|  123|	[invocation invoke];
      0|  124|	BOOL returnValue;
      0|  125|	[invocation getReturnValue:&returnValue];
      0|  126|	return returnValue;
      0|  127|}
       |  128|
       |  129|@end
       |  130|
       |  131|#pragma mark  -
       |  132|
       |  133|@implementation OCMBlockConstraint
       |  134|
       |  135|- (instancetype)initWithConstraintBlock:(BOOL (^)(id))aBlock
      0|  136|{
      0|  137|    if ((self = [super init]))
      0|  138|    {
      0|  139|        block = [aBlock copy];
      0|  140|    }
      0|  141|	
      0|  142|	return self;
      0|  143|}
       |  144|
      0|  145|- (void)dealloc {
      0|  146|    [block release];
      0|  147|    [super dealloc];
      0|  148|}
       |  149|
       |  150|- (BOOL)evaluate:(id)value 
      0|  151|{
      0|  152|    return block ? block(value) : NO;
      0|  153|}
       |  154|
       |  155|
       |  156|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMExceptionReturnValueProvider.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCMExceptionReturnValueProvider.h"
       |   18|
       |   19|
       |   20|@implementation OCMExceptionReturnValueProvider
       |   21|
       |   22|- (void)handleInvocation:(NSInvocation *)anInvocation
      0|   23|{
      0|   24|	@throw returnValue;
      0|   25|}
       |   26|
       |   27|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMExpectationRecorder.m:
       |    1|/*
       |    2| *  Copyright (c) 2004-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCMExpectationRecorder.h"
       |   18|#import "OCMInvocationExpectation.h"
       |   19|
       |   20|@implementation OCMExpectationRecorder
       |   21|
       |   22|#pragma mark  Initialisers, description, accessors, etc.
       |   23|
       |   24|- (id)init
      0|   25|{
      0|   26|    self = [super init];
      0|   27|    [invocationMatcher release];
      0|   28|    invocationMatcher = [[OCMInvocationExpectation alloc] init];
      0|   29|    return self;
      0|   30|}
       |   31|
       |   32|- (OCMInvocationExpectation *)expectation
      0|   33|{
      0|   34|    return (OCMInvocationExpectation *)invocationMatcher;
      0|   35|}
       |   36|
       |   37|
       |   38|#pragma mark Modifying the expectation
       |   39|
       |   40|- (id)never
      0|   41|{
      0|   42|    [[self expectation] setMatchAndReject:YES];
      0|   43|    return self;
      0|   44|}
       |   45|
       |   46|
       |   47|#pragma mark Finishing recording
       |   48|
       |   49|- (void)forwardInvocation:(NSInvocation *)anInvocation
      0|   50|{
      0|   51|    [super forwardInvocation:anInvocation];
      0|   52|    [mockObject addExpectation:[self expectation]];
      0|   53|}
       |   54|
       |   55|
       |   56|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMFunctions.m:
       |    1|/*
       |    2| *  Copyright (c) 2014-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <objc/runtime.h>
       |   18|#import "OCMFunctions.h"
       |   19|#import "OCMLocation.h"
       |   20|#import "OCClassMockObject.h"
       |   21|#import "OCPartialMockObject.h"
       |   22|
       |   23|
       |   24|#pragma mark  Known private API
       |   25|
       |   26|@interface NSException(OCMKnownExceptionMethods)
       |   27|+ (NSException *)failureInFile:(NSString *)file atLine:(int)line withDescription:(NSString *)formatString, ...;
       |   28|@end
       |   29|
       |   30|@interface NSObject(OCMKnownTestCaseMethods)
       |   31|- (void)recordFailureWithDescription:(NSString *)description inFile:(NSString *)file atLine:(NSUInteger)line expected:(BOOL)expected;
       |   32|- (void)failWithException:(NSException *)exception;
       |   33|@end
       |   34|
       |   35|
       |   36|#pragma mark  Functions related to ObjC type system
       |   37|
       |   38|BOOL OCMIsObjectType(const char *objCType)
    147|   39|{
    147|   40|    objCType = OCMTypeWithoutQualifiers(objCType);
    147|   41|
    147|   42|    if(strcmp(objCType, @encode(id)) == 0 || strcmp(objCType, @encode(Class)) == 0)
    134|   43|        return YES;
    147|   44|
    147|   45|    // if the returnType is a typedef to an object, it has the form ^{OriginClass=#}
     13|   46|    NSString *regexString = @"^\\^\\{(.*)=#.*\\}";
     13|   47|    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regexString options:0 error:NULL];
     13|   48|    NSString *type = [NSString stringWithCString:objCType encoding:NSASCIIStringEncoding];
     13|   49|    if([regex numberOfMatchesInString:type options:0 range:NSMakeRange(0, type.length)] > 0)
      0|   50|        return YES;
     13|   51|
     13|   52|    // if the return type is a block we treat it like an object
     13|   53|    // TODO: if the runtime were to encode the block's argument and/or return types, this test would not be sufficient
     13|   54|    if(strcmp(objCType, @encode(void(^)())) == 0)
      2|   55|        return YES;
     13|   56|
     11|   57|    return NO;
     13|   58|}
       |   59|
       |   60|
       |   61|const char *OCMTypeWithoutQualifiers(const char *objCType)
    500|   62|{
    500|   63|    while(strchr("rnNoORV", objCType[0]) != NULL)
      0|   64|        objCType += 1;
    500|   65|    return objCType;
    500|   66|}
       |   67|
       |   68|
       |   69|/*
       |   70| * Sometimes an external type is an opaque struct (which will have an @encode of "{structName}"
       |   71| * or "{structName=}") but the actual method return type, or property type, will know the contents
       |   72| * of the struct (so will have an objcType of say "{structName=iiSS}".  This function will determine
       |   73| * those are equal provided they have the same structure name, otherwise everything else will be
       |   74| * compared textually.  This can happen particularly for pointers to such structures, which still
       |   75| * encode what is being pointed to.
       |   76| *
       |   77| * For some types some runtime functions throw exceptions, which is why we wrap this in an
       |   78| * exception handler just below.
       |   79| */
       |   80|static BOOL OCMEqualTypesAllowingOpaqueStructsInternal(const char *type1, const char *type2)
      0|   81|{
      0|   82|    type1 = OCMTypeWithoutQualifiers(type1);
      0|   83|    type2 = OCMTypeWithoutQualifiers(type2);
      0|   84|
      0|   85|    switch (type1[0])
      0|   86|    {
      0|   87|        case '{':
      0|   88|        case '(':
      0|   89|        {
      0|   90|            if (type2[0] != type1[0])
      0|   91|                return NO;
      0|   92|            char endChar = type1[0] == '{'? '}' : ')';
      0|   93|
      0|   94|            const char *type1End = strchr(type1, endChar);
      0|   95|            const char *type2End = strchr(type2, endChar);
      0|   96|            const char *type1Equals = strchr(type1, '=');
      0|   97|            const char *type2Equals = strchr(type2, '=');
      0|   98|
      0|   99|            /* Opaque types either don't have an equals sign (just the name and the end brace), or
      0|  100|             * empty content after the equals sign.
      0|  101|             * We want that to compare the same as a type of the same name but with the content.
      0|  102|             */
      0|  103|            BOOL type1Opaque = (type1Equals == NULL || (type1End < type1Equals) || type1Equals[1] == endChar);
      0|  104|            BOOL type2Opaque = (type2Equals == NULL || (type2End < type2Equals) || type2Equals[1] == endChar);
      0|  105|            const char *type1NameEnd = (type1Equals == NULL || (type1End < type1Equals)) ? type1End : type1Equals;
      0|  106|            const char *type2NameEnd = (type2Equals == NULL || (type2End < type2Equals)) ? type2End : type2Equals;
      0|  107|            intptr_t type1NameLen = type1NameEnd - type1;
      0|  108|            intptr_t type2NameLen = type2NameEnd - type2;
      0|  109|
      0|  110|            /* If the names are not equal, return NO */
      0|  111|            if (type1NameLen != type2NameLen || strncmp(type1, type2, type1NameLen))
      0|  112|                return NO;
      0|  113|
      0|  114|            /* If the same name, and at least one is opaque, that is close enough. */
      0|  115|            if (type1Opaque || type2Opaque)
      0|  116|                return YES;
      0|  117|
      0|  118|            /* Otherwise, compare all the elements.  Use NSGetSizeAndAlignment to walk through the struct elements. */
      0|  119|            type1 = type1Equals + 1;
      0|  120|            type2 = type2Equals + 1;
      0|  121|            while (type1[0] != endChar && type1[0] != '\0')
      0|  122|            {
      0|  123|                if (!OCMEqualTypesAllowingOpaqueStructs(type1, type2))
      0|  124|                    return NO;
      0|  125|                type1 = NSGetSizeAndAlignment(type1, NULL, NULL);
      0|  126|                type2 = NSGetSizeAndAlignment(type2, NULL, NULL);
      0|  127|            }
      0|  128|            return YES;
      0|  129|        }
      0|  130|        case '^':
      0|  131|            /* for a pointer, make sure the other is a pointer, then recursively compare the rest */
      0|  132|            if (type2[0] != type1[0])
      0|  133|                return NO;
      0|  134|            return OCMEqualTypesAllowingOpaqueStructs(type1 + 1, type2 + 1);
      0|  135|
      0|  136|        case '\0':
      0|  137|            return type2[0] == '\0';
      0|  138|
      0|  139|        default:
      0|  140|        {
      0|  141|            // Move the type pointers past the current types, then compare that region
      0|  142|            const char *afterType1 =  NSGetSizeAndAlignment(type1, NULL, NULL);
      0|  143|            const char *afterType2 =  NSGetSizeAndAlignment(type2, NULL, NULL);
      0|  144|            intptr_t type1Len = afterType1 - type1;
      0|  145|            intptr_t type2Len = afterType2 - type2;
      0|  146|
      0|  147|            return (type1Len == type2Len && (strncmp(type1, type2, type1Len) == 0));
      0|  148|        }
      0|  149|    }
      0|  150|}
       |  151|
       |  152|BOOL OCMEqualTypesAllowingOpaqueStructs(const char *type1, const char *type2)
      0|  153|{
      0|  154|    @try
      0|  155|    {
      0|  156|        return OCMEqualTypesAllowingOpaqueStructsInternal(type1, type2);
      0|  157|    }
      0|  158|    @catch (NSException *e)
      0|  159|    {
      0|  160|        /* Probably a bitfield or something that NSGetSizeAndAlignment chokes on, oh well */
      0|  161|        return NO;
      0|  162|    }
      0|  163|}
       |  164|
       |  165|
       |  166|#pragma mark  Creating classes
       |  167|
       |  168|Class OCMCreateSubclass(Class class, void *ref)
     27|  169|{
     27|  170|    const char *className = [[NSString stringWithFormat:@"%@-%p-%u", NSStringFromClass(class), ref, arc4random()] UTF8String];
     27|  171|    Class subclass = objc_allocateClassPair(class, className, 0);
     27|  172|    objc_registerClassPair(subclass);
     27|  173|    return subclass;
     27|  174|}
       |  175|
       |  176|
       |  177|#pragma mark  Directly manipulating the isa pointer (look away)
       |  178|
       |  179|void OCMSetIsa(id object, Class class)
     37|  180|{
     37|  181|    *((Class *)object) = class;
     37|  182|}
       |  183|
       |  184|Class OCMGetIsa(id object)
     19|  185|{
     19|  186|    return *((Class *)object);
     19|  187|}
       |  188|
       |  189|
       |  190|#pragma mark  Alias for renaming real methods
       |  191|
       |  192|static NSString *const OCMRealMethodAliasPrefix = @"ocmock_replaced_";
       |  193|static const char *const OCMRealMethodAliasPrefixCString = "ocmock_replaced_";
       |  194|
       |  195|BOOL OCMIsAliasSelector(SEL selector)
    541|  196|{
    541|  197|    return [NSStringFromSelector(selector) hasPrefix:OCMRealMethodAliasPrefix];
    541|  198|}
       |  199|
       |  200|SEL OCMAliasForOriginalSelector(SEL selector)
    549|  201|{
    549|  202|    char aliasName[2048];
    549|  203|    const char *originalName = sel_getName(selector);
    549|  204|    strlcpy(aliasName, OCMRealMethodAliasPrefixCString, sizeof(aliasName));
    549|  205|    strlcat(aliasName, originalName, sizeof(aliasName));
    549|  206|    return sel_registerName(aliasName);
    549|  207|}
       |  208|
       |  209|SEL OCMOriginalSelectorForAlias(SEL selector)
      0|  210|{
      0|  211|    if(!OCMIsAliasSelector(selector))
      0|  212|        [NSException raise:NSInvalidArgumentException format:@"Not an alias selector; found %@", NSStringFromSelector(selector)];
      0|  213|    NSString *string = NSStringFromSelector(selector);
      0|  214|    return NSSelectorFromString([string substringFromIndex:[OCMRealMethodAliasPrefix length]]);
      0|  215|}
       |  216|
       |  217|
       |  218|#pragma mark  Wrappers around associative references
       |  219|
       |  220|static NSString *const OCMClassMethodMockObjectKey = @"OCMClassMethodMockObjectKey";
       |  221|
       |  222|void OCMSetAssociatedMockForClass(OCClassMockObject *mock, Class aClass)
     37|  223|{
     37|  224|    if((mock != nil) && (objc_getAssociatedObject(aClass, OCMClassMethodMockObjectKey) != nil))
      0|  225|        [NSException raise:NSInternalInconsistencyException format:@"Another mock is already associated with class %@", NSStringFromClass(aClass)];
     37|  226|    objc_setAssociatedObject(aClass, OCMClassMethodMockObjectKey, mock, OBJC_ASSOCIATION_ASSIGN);
     37|  227|}
       |  228|
       |  229|OCClassMockObject *OCMGetAssociatedMockForClass(Class aClass, BOOL includeSuperclasses)
     21|  230|{
     21|  231|    OCClassMockObject *mock = nil;
     21|  232|    do
     21|  233|    {
     21|  234|        mock = objc_getAssociatedObject(aClass, OCMClassMethodMockObjectKey);
     21|  235|        aClass = class_getSuperclass(aClass);
     21|  236|    }
     21|  237|    while((mock == nil) && (aClass != nil) && includeSuperclasses);
     21|  238|    return mock;
     21|  239|}
       |  240|
       |  241|static NSString *const OCMPartialMockObjectKey = @"OCMPartialMockObjectKey";
       |  242|
       |  243|void OCMSetAssociatedMockForObject(OCClassMockObject *mock, id anObject)
     16|  244|{
     16|  245|    if((mock != nil) && (objc_getAssociatedObject(anObject, OCMPartialMockObjectKey) != nil))
      0|  246|        [NSException raise:NSInternalInconsistencyException format:@"Another mock is already associated with object %@", anObject];
     16|  247|    objc_setAssociatedObject(anObject, OCMPartialMockObjectKey, mock, OBJC_ASSOCIATION_ASSIGN);
     16|  248|}
       |  249|
       |  250|OCPartialMockObject *OCMGetAssociatedMockForObject(id anObject)
    514|  251|{
    514|  252|    return objc_getAssociatedObject(anObject, OCMPartialMockObjectKey);
    514|  253|}
       |  254|
       |  255|
       |  256|#pragma mark  Functions related to IDE error reporting
       |  257|
       |  258|void OCMReportFailure(OCMLocation *loc, NSString *description)
      0|  259|{
      0|  260|    id testCase = [loc testCase];
      0|  261|    if((testCase != nil) && [testCase respondsToSelector:@selector(recordFailureWithDescription:inFile:atLine:expected:)])
      0|  262|    {
      0|  263|        [testCase recordFailureWithDescription:description inFile:[loc file] atLine:[loc line] expected:NO];
      0|  264|    }
      0|  265|    else if((testCase != nil) && [testCase respondsToSelector:@selector(failWithException:)])
      0|  266|    {
      0|  267|        NSException *exception = nil;
      0|  268|        if([NSException instancesRespondToSelector:@selector(failureInFile:atLine:withDescription:)])
      0|  269|        {
      0|  270|            exception = [NSException failureInFile:[loc file] atLine:(int)[loc line] withDescription:description];
      0|  271|        }
      0|  272|        else
      0|  273|        {
      0|  274|            NSString *reason = [NSString stringWithFormat:@"%@:%lu %@", [loc file], (unsigned long)[loc line], description];
      0|  275|            exception = [NSException exceptionWithName:@"OCMockTestFailure" reason:reason userInfo:nil];
      0|  276|        }
      0|  277|        [testCase failWithException:exception];
      0|  278|    }
      0|  279|    else if(loc != nil)
      0|  280|    {
      0|  281|        NSLog(@"%@:%lu %@", [loc file], (unsigned long)[loc line], description);
      0|  282|        NSString *reason = [NSString stringWithFormat:@"%@:%lu %@", [loc file], (unsigned long)[loc line], description];
      0|  283|        [[NSException exceptionWithName:@"OCMockTestFailure" reason:reason userInfo:nil] raise];
      0|  284|
      0|  285|    }
      0|  286|    else
      0|  287|    {
      0|  288|        NSLog(@"%@", description);
      0|  289|        [[NSException exceptionWithName:@"OCMockTestFailure" reason:description userInfo:nil] raise];
      0|  290|    }
      0|  291|
      0|  292|}

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMIndirectReturnValueProvider.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "NSMethodSignature+OCMAdditions.h"
       |   18|#import "OCMIndirectReturnValueProvider.h"
       |   19|#import "NSInvocation+OCMAdditions.h"
       |   20|
       |   21|
       |   22|@implementation OCMIndirectReturnValueProvider
       |   23|
       |   24|- (id)initWithProvider:(id)aProvider andSelector:(SEL)aSelector
      0|   25|{
      0|   26|    if ((self = [super init]))
      0|   27|    {
      0|   28|        provider = [aProvider retain];
      0|   29|        selector = aSelector;
      0|   30|    }
      0|   31|	
      0|   32|	return self;
      0|   33|}
       |   34|
       |   35|- (void)dealloc
      0|   36|{
      0|   37|	[provider release];
      0|   38|	[super dealloc];
      0|   39|}
       |   40|
       |   41|- (void)handleInvocation:(NSInvocation *)anInvocation
      0|   42|{
      0|   43|    id originalTarget = [anInvocation target];
      0|   44|    SEL originalSelector = [anInvocation selector];
      0|   45|
      0|   46|    [anInvocation setTarget:provider];
      0|   47|	[anInvocation setSelector:selector];
      0|   48|	[anInvocation invoke];
      0|   49|
      0|   50|    [anInvocation setTarget:originalTarget];
      0|   51|    [anInvocation setSelector:originalSelector];
      0|   52|}
       |   53|
       |   54|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMInvocationExpectation.m:
       |    1|/*
       |    2| *  Copyright (c) 2014-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCMInvocationExpectation.h"
       |   18|#import "NSInvocation+OCMAdditions.h"
       |   19|
       |   20|
       |   21|@implementation OCMInvocationExpectation
       |   22|
       |   23|- (void)setMatchAndReject:(BOOL)flag
      0|   24|{
      0|   25|    matchAndReject = flag;
      0|   26|    if(matchAndReject)
      0|   27|        isSatisfied = YES;
      0|   28|}
       |   29|
       |   30|- (BOOL)isMatchAndReject
      0|   31|{
      0|   32|  return matchAndReject;
      0|   33|}
       |   34|
       |   35|- (BOOL)isSatisfied
      0|   36|{
      0|   37|    return isSatisfied;
      0|   38|}
       |   39|
       |   40|- (void)handleInvocation:(NSInvocation *)anInvocation
      0|   41|{
      0|   42|   [super handleInvocation:anInvocation];
      0|   43|
      0|   44|    if(matchAndReject)
      0|   45|    {
      0|   46|        isSatisfied = NO;
      0|   47|        [NSException raise:NSInternalInconsistencyException format:@"%@: explicitly disallowed method invoked: %@",
      0|   48|                [self description], [anInvocation invocationDescription]];
      0|   49|    }
      0|   50|    else
      0|   51|    {
      0|   52|        isSatisfied = YES;
      0|   53|    }
      0|   54|}
       |   55|
       |   56|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMInvocationMatcher.m:
       |    1|/*
       |    2| *  Copyright (c) 2014-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <objc/runtime.h>
       |   18|#import <OCMock/OCMArg.h>
       |   19|#import <OCMock/OCMConstraint.h>
       |   20|#import "OCMPassByRefSetter.h"
       |   21|#import "NSInvocation+OCMAdditions.h"
       |   22|#import "OCMInvocationMatcher.h"
       |   23|#import "OCClassMockObject.h"
       |   24|#import "OCMFunctions.h"
       |   25|
       |   26|
       |   27|@interface NSObject(HCMatcherDummy)
       |   28|- (BOOL)matches:(id)item;
       |   29|@end
       |   30|
       |   31|
       |   32|@implementation OCMInvocationMatcher
       |   33|
       |   34|- (void)dealloc
     58|   35|{
     58|   36|    [recordedInvocation release];
     58|   37|    [super dealloc];
     58|   38|}
       |   39|
       |   40|- (void)setInvocation:(NSInvocation *)anInvocation
     59|   41|{
     59|   42|    [recordedInvocation release];
     59|   43|    // When the method has a char* argument we do not retain the arguments. This makes it possible
     59|   44|    // to match char* args literally and with anyPointer. Not retaining the argument means that
     59|   45|    // in these cases tests that use their own autorelease pools may fail unexpectedly.
     59|   46|    if(![anInvocation hasCharPointerArgument])
     59|   47|        [anInvocation retainArguments];
     59|   48|    recordedInvocation = [anInvocation retain];
     59|   49|}
       |   50|
       |   51|- (void)setRecordedAsClassMethod:(BOOL)flag
      5|   52|{
      5|   53|    recordedAsClassMethod = flag;
      5|   54|}
       |   55|
       |   56|- (BOOL)recordedAsClassMethod
    165|   57|{
    165|   58|    return recordedAsClassMethod;
    165|   59|}
       |   60|
       |   61|- (void)setIgnoreNonObjectArgs:(BOOL)flag
      0|   62|{
      0|   63|    ignoreNonObjectArgs = flag;
      0|   64|}
       |   65|
       |   66|- (NSString *)description
      0|   67|{
      0|   68|    return [recordedInvocation invocationDescription];
      0|   69|}
       |   70|
       |   71|- (NSInvocation *)recordedInvocation
     47|   72|{
     47|   73|    return recordedInvocation;
     47|   74|}
       |   75|
       |   76|- (BOOL)matchesSelector:(SEL)sel
    603|   77|{
    603|   78|    if(sel == [recordedInvocation selector])
     62|   79|        return YES;
    541|   80|    if(OCMIsAliasSelector(sel) &&
      0|   81|       OCMOriginalSelectorForAlias(sel) == [recordedInvocation selector])
      0|   82|        return YES;
    541|   83|
    541|   84|    return NO;
    541|   85|}
       |   86|
       |   87|- (BOOL)matchesInvocation:(NSInvocation *)anInvocation
    413|   88|{
    413|   89|    id target = [anInvocation target];
    413|   90|    BOOL isClassMethodInvocation = (target != nil) && (target == [target class]);
    413|   91|    if(isClassMethodInvocation != recordedAsClassMethod)
     67|   92|        return NO;
    413|   93|
    346|   94|    if(![self matchesSelector:[anInvocation selector]])
    298|   95|        return NO;
    346|   96|
     48|   97|    NSMethodSignature *signature = [recordedInvocation methodSignature];
     48|   98|    NSUInteger n = [signature numberOfArguments];
     72|   99|    for(NSUInteger i = 2; i < n; i++)
     39|  100|    {
     39|  101|        if(ignoreNonObjectArgs && strcmp([signature getArgumentTypeAtIndex:i], @encode(id)))
      0|  102|        {
      0|  103|            continue;
      0|  104|        }
     39|  105|
     39|  106|        id recordedArg = [recordedInvocation getArgumentAtIndexAsObject:i];
     39|  107|        id passedArg = [anInvocation getArgumentAtIndexAsObject:i];
     39|  108|
     39|  109|        if([recordedArg isProxy])
      0|  110|        {
      0|  111|            if(![recordedArg isEqual:passedArg])
      0|  112|                return NO;
      0|  113|            continue;
      0|  114|        }
     39|  115|
     39|  116|        if([recordedArg isKindOfClass:[NSValue class]])
      0|  117|            recordedArg = [OCMArg resolveSpecialValues:recordedArg];
     39|  118|
     39|  119|        if([recordedArg isKindOfClass:[OCMConstraint class]])
      1|  120|        {
      1|  121|            if([recordedArg evaluate:passedArg] == NO)
      0|  122|                return NO;
      1|  123|        }
     38|  124|        else if([recordedArg isKindOfClass:[OCMPassByRefSetter class]])
      0|  125|        {
      0|  126|            id valueToSet = [(OCMPassByRefSetter *)recordedArg value];
      0|  127|            // side effect but easier to do here than in handleInvocation
      0|  128|            if(![valueToSet isKindOfClass:[NSValue class]])
      0|  129|                *(id *)[passedArg pointerValue] = valueToSet;
      0|  130|            else
      0|  131|                [(NSValue *)valueToSet getValue:[passedArg pointerValue]];
      0|  132|        }
     38|  133|        else if([recordedArg conformsToProtocol:objc_getProtocol("HCMatcher")])
      0|  134|        {
      0|  135|            if([recordedArg matches:passedArg] == NO)
      0|  136|                return NO;
      0|  137|        }
     38|  138|        else
     38|  139|        {
     38|  140|            if(([recordedArg class] == [NSNumber class]) &&
      0|  141|                    ([(NSNumber*)recordedArg compare:(NSNumber*)passedArg] != NSOrderedSame))
      0|  142|                return NO;
     38|  143|            if(([recordedArg isEqual:passedArg] == NO) &&
     15|  144|                    !((recordedArg == nil) && (passedArg == nil)))
     15|  145|                return NO;
     38|  146|        }
     39|  147|    }
     33|  148|    return YES;
     48|  149|}
       |  150|
       |  151|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMInvocationStub.m:
       |    1|/*
       |    2| *  Copyright (c) 2014-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCMInvocationStub.h"
       |   18|
       |   19|@implementation OCMInvocationStub
       |   20|
       |   21|- (id)init
     59|   22|{
     59|   23|    self = [super init];
     59|   24|    invocationActions = [[NSMutableArray alloc] init];
     59|   25|    return self;
     59|   26|}
       |   27|
       |   28|- (void)dealloc
     58|   29|{
     58|   30|    [invocationActions release];
     58|   31|    [super dealloc];
     58|   32|}
       |   33|
       |   34|
       |   35|- (void)addInvocationAction:(id)anAction
     59|   36|{
     59|   37|    [invocationActions addObject:anAction];
     59|   38|}
       |   39|
       |   40|- (NSArray *)invocationActions
      0|   41|{
      0|   42|    return invocationActions;
      0|   43|}
       |   44|
       |   45|
       |   46|- (void)handleInvocation:(NSInvocation *)anInvocation
     33|   47|{
     33|   48|//    if(![self matchesInvocation:anInvocation])
     33|   49|//        return NO;
     33|   50|    [invocationActions makeObjectsPerformSelector:@selector(handleInvocation:) withObject:anInvocation];
     33|   51|}
       |   52|
       |   53|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMLocation.m:
       |    1|/*
       |    2| *  Copyright (c) 2014-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCMLocation.h"
       |   18|
       |   19|@implementation OCMLocation
       |   20|
       |   21|+ (instancetype)locationWithTestCase:(id)aTestCase file:(NSString *)aFile line:(NSUInteger)aLine
      0|   22|{
      0|   23|    return [[[OCMLocation alloc] initWithTestCase:aTestCase file:aFile line:aLine] autorelease];
      0|   24|}
       |   25|
       |   26|- (instancetype)initWithTestCase:(id)aTestCase file:(NSString *)aFile line:(NSUInteger)aLine
      0|   27|{
      0|   28|    if ((self = [super init]))
      0|   29|    {
      0|   30|        testCase = aTestCase;
      0|   31|        file = [aFile retain];
      0|   32|        line = aLine;
      0|   33|    }
      0|   34|    
      0|   35|    return self;
      0|   36|}
       |   37|
       |   38|- (void)dealloc
      0|   39|{
      0|   40|    [file release];
      0|   41|    [super dealloc];
      0|   42|}
       |   43|
       |   44|- (id)testCase
      0|   45|{
      0|   46|    return testCase;
      0|   47|}
       |   48|
       |   49|- (NSString *)file
      0|   50|{
      0|   51|    return file;
      0|   52|}
       |   53|
       |   54|- (NSUInteger)line
      0|   55|{
      0|   56|    return line;
      0|   57|}
       |   58|
       |   59|@end
       |   60|
       |   61|
       |   62|OCMLocation *OCMMakeLocation(id testCase, const char *fileCString, int line)
      0|   63|{
      0|   64|    return [OCMLocation locationWithTestCase:testCase file:[NSString stringWithUTF8String:fileCString] line:line];
      0|   65|}
       |   66|

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMMacroState.m:
       |    1|/*
       |    2| *  Copyright (c) 2014-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCMMacroState.h"
       |   18|#import "OCMStubRecorder.h"
       |   19|#import "OCMockObject.h"
       |   20|#import "OCMExpectationRecorder.h"
       |   21|#import "OCMVerifier.h"
       |   22|#import "OCMInvocationMatcher.h"
       |   23|
       |   24|
       |   25|@implementation OCMMacroState
       |   26|
       |   27|static OCMMacroState *globalState;
       |   28|
       |   29|#pragma mark  Methods to begin/end macros
       |   30|
       |   31|+ (void)beginStubMacro
     51|   32|{
     51|   33|    OCMStubRecorder *recorder = [[[OCMStubRecorder alloc] init] autorelease];
     51|   34|    globalState = [[[OCMMacroState alloc] initWithRecorder:recorder] autorelease];
     51|   35|}
       |   36|
       |   37|+ (OCMStubRecorder *)endStubMacro
     51|   38|{
     51|   39|    OCMStubRecorder *recorder = (OCMStubRecorder *)[globalState recorder];
     51|   40|    globalState = nil;
     51|   41|    return recorder;
     51|   42|}
       |   43|
       |   44|
       |   45|+ (void)beginExpectMacro
      0|   46|{
      0|   47|    OCMExpectationRecorder *recorder = [[[OCMExpectationRecorder alloc] init] autorelease];
      0|   48|    globalState = [[[OCMMacroState alloc] initWithRecorder:recorder] autorelease];
      0|   49|}
       |   50|
       |   51|+ (OCMStubRecorder *)endExpectMacro
      0|   52|{
      0|   53|    return [self endStubMacro];
      0|   54|}
       |   55|
       |   56|
       |   57|+ (void)beginVerifyMacroAtLocation:(OCMLocation *)aLocation
      0|   58|{
      0|   59|    OCMVerifier *recorder = [[[OCMVerifier alloc] init] autorelease];
      0|   60|    [recorder setLocation:aLocation];
      0|   61|    globalState = [[[OCMMacroState alloc] initWithRecorder:recorder] autorelease];
      0|   62|}
       |   63|
       |   64|+ (void)endVerifyMacro
      0|   65|{
      0|   66|    globalState = nil;
      0|   67|}
       |   68|
       |   69|
       |   70|#pragma mark  Accessing global state
       |   71|
       |   72|+ (OCMMacroState *)globalState
    139|   73|{
    139|   74|    return globalState;
    139|   75|}
       |   76|
       |   77|
       |   78|#pragma mark  Init, dealloc, accessors
       |   79|
       |   80|- (id)initWithRecorder:(OCMRecorder *)aRecorder
     51|   81|{
     51|   82|    if ((self = [super init]))
     51|   83|    {
     51|   84|        recorder = [aRecorder retain];
     51|   85|    }
     51|   86|    
     51|   87|    return self;
     51|   88|}
       |   89|
       |   90|- (void)dealloc
     51|   91|{
     51|   92|    [recorder release];
     51|   93|    if(globalState == self)
      0|   94|        globalState = nil;
     51|   95|    [super dealloc];
     51|   96|}
       |   97|
       |   98|- (OCMRecorder *)recorder
    102|   99|{
    102|  100|    return recorder;
    102|  101|}
       |  102|
       |  103|
       |  104|#pragma mark  Changing the recorder
       |  105|
       |  106|- (void)switchToClassMethod
      0|  107|{
      0|  108|    [recorder classMethod];
      0|  109|}
       |  110|
       |  111|
       |  112|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMNotificationPoster.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCMNotificationPoster.h"
       |   18|
       |   19|
       |   20|@implementation OCMNotificationPoster
       |   21|
       |   22|- (id)initWithNotification:(id)aNotification
      0|   23|{
      0|   24|    if ((self = [super init]))
      0|   25|    {
      0|   26|        notification = [aNotification retain];
      0|   27|    }
      0|   28|	
      0|   29|	return self;
      0|   30|}
       |   31|
       |   32|- (void)dealloc
      0|   33|{
      0|   34|	[notification release];
      0|   35|	[super dealloc];
      0|   36|}
       |   37|
       |   38|- (void)handleInvocation:(NSInvocation *)anInvocation
      0|   39|{
      0|   40|	[[NSNotificationCenter defaultCenter] postNotification:notification];
      0|   41|}
       |   42|
       |   43|
       |   44|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMObserverRecorder.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <objc/runtime.h>
       |   18|#import <OCMock/OCMConstraint.h>
       |   19|#import "NSInvocation+OCMAdditions.h"
       |   20|#import "OCMObserverRecorder.h"
       |   21|
       |   22|@interface NSObject(HCMatcherDummy)
       |   23|- (BOOL)matches:(id)item;
       |   24|@end
       |   25|
       |   26|#pragma mark -
       |   27|
       |   28|
       |   29|@implementation OCMObserverRecorder
       |   30|
       |   31|#pragma mark  Initialisers, description, accessors, etc.
       |   32|
       |   33|- (void)dealloc
      0|   34|{
      0|   35|	[recordedNotification release];
      0|   36|	[super dealloc];
      0|   37|}
       |   38|
       |   39|
       |   40|#pragma mark  Recording
       |   41|
       |   42|- (void)notificationWithName:(NSString *)name object:(id)sender
      0|   43|{
      0|   44|	recordedNotification = [[NSNotification notificationWithName:name object:sender] retain];
      0|   45|}
       |   46|
       |   47|- (void)notificationWithName:(NSString *)name object:(id)sender userInfo:(NSDictionary *)userInfo
      0|   48|{
      0|   49|	recordedNotification = [[NSNotification notificationWithName:name object:sender userInfo:userInfo] retain];
      0|   50|}
       |   51|
       |   52|
       |   53|#pragma mark  Verification
       |   54|
       |   55|- (BOOL)matchesNotification:(NSNotification *)aNotification
      0|   56|{
      0|   57|	return [self argument:[recordedNotification name] matchesArgument:[aNotification name]] &&
      0|   58|	[self argument:[recordedNotification object] matchesArgument:[aNotification object]] &&
      0|   59|	[self argument:[recordedNotification userInfo] matchesArgument:[aNotification userInfo]];
      0|   60|}
       |   61|
       |   62|- (BOOL)argument:(id)expectedArg matchesArgument:(id)observedArg
      0|   63|{
      0|   64|	if([expectedArg isKindOfClass:[OCMConstraint class]])
      0|   65|	{	
      0|   66|		return [expectedArg evaluate:observedArg];
      0|   67|	}
      0|   68|	else if([expectedArg conformsToProtocol:objc_getProtocol("HCMatcher")])
      0|   69|	{
      0|   70|		return [expectedArg matches:observedArg];
      0|   71|	}
      0|   72|	else if (expectedArg == observedArg)
      0|   73|	{
      0|   74|		return YES;
      0|   75|	}
      0|   76|	else if (expectedArg == nil || observedArg == nil)
      0|   77|	{
      0|   78|		return NO;
      0|   79|	}
      0|   80|	else
      0|   81|	{
      0|   82|		return [expectedArg isEqual:observedArg];
      0|   83|	}
      0|   84|}
       |   85|
       |   86|
       |   87|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMPassByRefSetter.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCMPassByRefSetter.h"
       |   18|
       |   19|
       |   20|@implementation OCMPassByRefSetter
       |   21|
       |   22|- (id)initWithValue:(id)aValue
      0|   23|{
      0|   24|    if ((self = [super init]))
      0|   25|    {
      0|   26|        value = [aValue retain];
      0|   27|    }
      0|   28|	
      0|   29|	return self;
      0|   30|}
       |   31|
       |   32|- (void)dealloc
      0|   33|{
      0|   34|	[value release];
      0|   35|	[super dealloc];
      0|   36|}
       |   37|
       |   38|- (id)value
      0|   39|{
      0|   40|	return value;
      0|   41|}
       |   42|
       |   43|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMRealObjectForwarder.m:
       |    1|/*
       |    2| *  Copyright (c) 2010-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <objc/runtime.h>
       |   18|#import "OCPartialMockObject.h"
       |   19|#import "OCMRealObjectForwarder.h"
       |   20|#import "OCMFunctions.h"
       |   21|
       |   22|
       |   23|@implementation OCMRealObjectForwarder
       |   24|
       |   25|- (void)handleInvocation:(NSInvocation *)anInvocation 
      1|   26|{
      1|   27|	id invocationTarget = [anInvocation target];
      1|   28|
      1|   29|    [anInvocation setSelector:OCMAliasForOriginalSelector([anInvocation selector])];
      1|   30|	if ([invocationTarget isProxy])
      1|   31|	{
      1|   32|	    if (class_getInstanceMethod([invocationTarget mockObjectClass], @selector(realObject)))
      1|   33|	    {
      1|   34|	        // the method has been invoked on the mock, we need to change the target to the real object
      1|   35|	        [anInvocation setTarget:[(OCPartialMockObject *)invocationTarget realObject]];
      1|   36|	    }
      1|   37|	    else
      0|   38|	    {
      0|   39|	        [NSException raise:NSInternalInconsistencyException
      0|   40|	                    format:@"Method andForwardToRealObject can only be used with partial mocks and class methods."];
      0|   41|	    }
      1|   42|	}
      1|   43|
      1|   44|	[anInvocation invoke];
      1|   45|}
       |   46|
       |   47|
       |   48|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMRecorder.m:
       |    1|/*
       |    2| *  Copyright (c) 2014-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <objc/runtime.h>
       |   18|#import "OCMRecorder.h"
       |   19|#import "OCMockObject.h"
       |   20|#import "OCMInvocationMatcher.h"
       |   21|#import "OCClassMockObject.h"
       |   22|
       |   23|@implementation OCMRecorder
       |   24|
       |   25|- (instancetype)init
     59|   26|{
     59|   27|    // no super, we're inheriting from NSProxy
     59|   28|    return self;
     59|   29|}
       |   30|
       |   31|- (instancetype)initWithMockObject:(OCMockObject *)aMockObject
      8|   32|{
      8|   33|    [self init];
      8|   34|    [self setMockObject:aMockObject];
      8|   35|	return self;
      8|   36|}
       |   37|
       |   38|- (void)setMockObject:(OCMockObject *)aMockObject
     59|   39|{
     59|   40|    mockObject = aMockObject;
     59|   41|}
       |   42|
       |   43|- (void)dealloc
     59|   44|{
     59|   45|    [invocationMatcher release];
     59|   46|	[super dealloc];
     59|   47|}
       |   48|
       |   49|- (NSString *)description
      0|   50|{
      0|   51|    return [invocationMatcher description];
      0|   52|}
       |   53|
       |   54|- (OCMInvocationMatcher *)invocationMatcher
      0|   55|{
      0|   56|    return invocationMatcher;
      0|   57|}
       |   58|
       |   59|
       |   60|#pragma mark  Modifying the matcher
       |   61|
       |   62|- (id)classMethod
      5|   63|{
      5|   64|    // should we handle the case where this is called with a mock that isn't a class mock?
      5|   65|    [invocationMatcher setRecordedAsClassMethod:YES];
      5|   66|    return self;
      5|   67|}
       |   68|
       |   69|- (id)ignoringNonObjectArgs
      0|   70|{
      0|   71|    [invocationMatcher setIgnoreNonObjectArgs:YES];
      0|   72|    return self;
      0|   73|}
       |   74|
       |   75|
       |   76|#pragma mark  Recording the actual invocation
       |   77|
       |   78|- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
     59|   79|{
     59|   80|    if([invocationMatcher recordedAsClassMethod])
      5|   81|        return [[(OCClassMockObject *)mockObject mockedClass] methodSignatureForSelector:aSelector];
     59|   82|
     54|   83|    NSMethodSignature *signature = [mockObject methodSignatureForSelector:aSelector];
     54|   84|    if(signature == nil)
      0|   85|    {
      0|   86|        // if we're a working with a class mock and there is a class method, auto-switch
      0|   87|        if(([object_getClass(mockObject) isSubclassOfClass:[OCClassMockObject class]]) &&
      0|   88|           ([[(OCClassMockObject *)mockObject mockedClass] respondsToSelector:aSelector]))
      0|   89|        {
      0|   90|            [self classMethod];
      0|   91|            signature = [self methodSignatureForSelector:aSelector];
      0|   92|        }
      0|   93|    }
     54|   94|    return signature;
     59|   95|}
       |   96|
       |   97|- (void)forwardInvocation:(NSInvocation *)anInvocation
     59|   98|{
     59|   99|	[anInvocation setTarget:nil];
     59|  100|    [invocationMatcher setInvocation:anInvocation];
     59|  101|}
       |  102|
       |  103|- (void)doesNotRecognizeSelector:(SEL)aSelector
      0|  104|{
      0|  105|    [NSException raise:NSInvalidArgumentException format:@"%@: cannot stub/expect/verify method '%@' because no such method exists in the mocked class.", mockObject, NSStringFromSelector(aSelector)];
      0|  106|}
       |  107|
       |  108|
       |  109|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMReturnValueProvider.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "NSMethodSignature+OCMAdditions.h"
       |   18|#import "OCMReturnValueProvider.h"
       |   19|#import "OCMFunctions.h"
       |   20|
       |   21|
       |   22|@implementation OCMReturnValueProvider
       |   23|
       |   24|- (instancetype)initWithValue:(id)aValue
     49|   25|{
     49|   26|    if ((self = [super init]))
     49|   27|    {
     49|   28|        returnValue = [aValue retain];
     49|   29|    }
     49|   30|	
     49|   31|	return self;
     49|   32|}
       |   33|
       |   34|- (void)dealloc
     48|   35|{
     48|   36|	[returnValue release];
     48|   37|	[super dealloc];
     48|   38|}
       |   39|
       |   40|- (void)handleInvocation:(NSInvocation *)anInvocation
     28|   41|{
     28|   42|    if(!OCMIsObjectType([[anInvocation methodSignature] methodReturnType]))
      0|   43|    {
      0|   44|        @throw [NSException exceptionWithName:NSInvalidArgumentException reason:@"Expected invocation with object return type. Did you mean to use andReturnValue: instead?" userInfo:nil];
      0|   45|    }
     28|   46|    NSString *sel = NSStringFromSelector([anInvocation selector]);
     28|   47|    if([sel hasPrefix:@"alloc"] || [sel hasPrefix:@"new"] || [sel hasPrefix:@"copy"] || [sel hasPrefix:@"mutableCopy"])
      0|   48|    {
      0|   49|        // methods that "create" an object return it with an extra retain count
      0|   50|        [returnValue retain];
      0|   51|    }
     28|   52|	[anInvocation setReturnValue:&returnValue];
     28|   53|}
       |   54|
       |   55|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMStubRecorder.m:
       |    1|/*
       |    2| *  Copyright (c) 2004-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCMStubRecorder.h"
       |   18|#import "OCClassMockObject.h"
       |   19|#import "OCMReturnValueProvider.h"
       |   20|#import "OCMBoxedReturnValueProvider.h"
       |   21|#import "OCMExceptionReturnValueProvider.h"
       |   22|#import "OCMIndirectReturnValueProvider.h"
       |   23|#import "OCMNotificationPoster.h"
       |   24|#import "OCMBlockCaller.h"
       |   25|#import "OCMRealObjectForwarder.h"
       |   26|#import "OCMFunctions.h"
       |   27|#import "OCMInvocationStub.h"
       |   28|
       |   29|
       |   30|@implementation OCMStubRecorder
       |   31|
       |   32|#pragma mark  Initialisers, description, accessors, etc.
       |   33|
       |   34|- (id)init
     59|   35|{
     59|   36|    self = [super init];
     59|   37|    invocationMatcher = [[OCMInvocationStub alloc] init];
     59|   38|    return self;
     59|   39|}
       |   40|
       |   41|- (OCMInvocationStub *)stub
    118|   42|{
    118|   43|    return (OCMInvocationStub *)invocationMatcher;
    118|   44|}
       |   45|
       |   46|
       |   47|#pragma mark  Recording invocation actions
       |   48|
       |   49|- (id)andReturn:(id)anObject
     38|   50|{
     38|   51|	[[self stub] addInvocationAction:[[[OCMReturnValueProvider alloc] initWithValue:anObject] autorelease]];
     38|   52|	return self;
     38|   53|}
       |   54|
       |   55|- (id)andReturnValue:(NSValue *)aValue
     11|   56|{
     11|   57|    [[self stub] addInvocationAction:[[[OCMBoxedReturnValueProvider alloc] initWithValue:aValue] autorelease]];
     11|   58|	return self;
     11|   59|}
       |   60|
       |   61|- (id)andThrow:(NSException *)anException
      0|   62|{
      0|   63|    [[self stub] addInvocationAction:[[[OCMExceptionReturnValueProvider alloc] initWithValue:anException] autorelease]];
      0|   64|	return self;
      0|   65|}
       |   66|
       |   67|- (id)andPost:(NSNotification *)aNotification
      0|   68|{
      0|   69|    [[self stub] addInvocationAction:[[[OCMNotificationPoster alloc] initWithNotification:aNotification] autorelease]];
      0|   70|	return self;
      0|   71|}
       |   72|
       |   73|- (id)andCall:(SEL)selector onObject:(id)anObject
      0|   74|{
      0|   75|    [[self stub] addInvocationAction:[[[OCMIndirectReturnValueProvider alloc] initWithProvider:anObject andSelector:selector] autorelease]];
      0|   76|	return self;
      0|   77|}
       |   78|
       |   79|- (id)andDo:(void (^)(NSInvocation *))aBlock 
      5|   80|{
      5|   81|    [[self stub] addInvocationAction:[[[OCMBlockCaller alloc] initWithCallBlock:aBlock] autorelease]];
      5|   82|	return self;
      5|   83|}
       |   84|
       |   85|- (id)andForwardToRealObject
      5|   86|{
      5|   87|    [[self stub] addInvocationAction:[[[OCMRealObjectForwarder alloc] init] autorelease]];
      5|   88|    return self;
      5|   89|}
       |   90|
       |   91|
       |   92|#pragma mark Finishing recording
       |   93|
       |   94|- (void)forwardInvocation:(NSInvocation *)anInvocation
     59|   95|{
     59|   96|    [super forwardInvocation:anInvocation];
     59|   97|    [mockObject addStub:[self stub]];
     59|   98|}
       |   99|
       |  100|
       |  101|@end
       |  102|
       |  103|
       |  104|@implementation OCMStubRecorder (Properties)
       |  105|
       |  106|@dynamic _andReturn;
       |  107|
       |  108|- (OCMStubRecorder *(^)(NSValue *))_andReturn
     41|  109|{
     41|  110|    id (^theBlock)(id) = ^ (NSValue *aValue)
     41|  111|    {
     41|  112|        if(OCMIsObjectType([aValue objCType]))
     30|  113|        {
     30|  114|            NSValue *objValue = nil;
     30|  115|            [aValue getValue:&objValue];
     30|  116|            return [self andReturn:objValue];
     30|  117|        }
     41|  118|        else
     11|  119|        {
     11|  120|            return [self andReturnValue:aValue];
     11|  121|        }
     41|  122|    };
     41|  123|    return [[theBlock copy] autorelease];
     41|  124|}
       |  125|
       |  126|
       |  127|@dynamic _andThrow;
       |  128|
       |  129|- (OCMStubRecorder *(^)(NSException *))_andThrow
      0|  130|{
      0|  131|    id (^theBlock)(id) = ^ (NSException * anException)
      0|  132|    {
      0|  133|        return [self andThrow:anException];
      0|  134|    };
      0|  135|    return [[theBlock copy] autorelease];
      0|  136|}
       |  137|
       |  138|
       |  139|@dynamic _andPost;
       |  140|
       |  141|- (OCMStubRecorder *(^)(NSNotification *))_andPost
      0|  142|{
      0|  143|    id (^theBlock)(id) = ^ (NSNotification * aNotification)
      0|  144|    {
      0|  145|        return [self andPost:aNotification];
      0|  146|    };
      0|  147|    return [[theBlock copy] autorelease];
      0|  148|}
       |  149|
       |  150|
       |  151|@dynamic _andCall;
       |  152|
       |  153|- (OCMStubRecorder *(^)(id, SEL))_andCall
      0|  154|{
      0|  155|    id (^theBlock)(id, SEL) = ^ (id anObject, SEL aSelector)
      0|  156|    {
      0|  157|        return [self andCall:aSelector onObject:anObject];
      0|  158|    };
      0|  159|    return [[theBlock copy] autorelease];
      0|  160|}
       |  161|
       |  162|
       |  163|@dynamic _andDo;
       |  164|
       |  165|- (OCMStubRecorder *(^)(void (^)(NSInvocation *)))_andDo
      5|  166|{
      5|  167|    id (^theBlock)(void (^)(NSInvocation *)) = ^ (void (^ blockToCall)(NSInvocation *))
      5|  168|    {
      5|  169|        return [self andDo:blockToCall];
      5|  170|    };
      5|  171|    return [[theBlock copy] autorelease];
      5|  172|}
       |  173|
       |  174|
       |  175|@dynamic _andForwardToRealObject;
       |  176|
       |  177|- (OCMStubRecorder *(^)(void))_andForwardToRealObject
      5|  178|{
      5|  179|    id (^theBlock)(void) = ^ (void)
      5|  180|    {
      5|  181|        return [self andForwardToRealObject];
      5|  182|    };
      5|  183|    return [[theBlock copy] autorelease];
      5|  184|}
       |  185|
       |  186|
       |  187|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMVerifier.m:
       |    1|/*
       |    2| *  Copyright (c) 2014-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <objc/runtime.h>
       |   18|#import "OCMVerifier.h"
       |   19|#import "OCMockObject.h"
       |   20|#import "OCMLocation.h"
       |   21|#import "OCMInvocationMatcher.h"
       |   22|
       |   23|
       |   24|@implementation OCMVerifier
       |   25|
       |   26|- (id)init
      0|   27|{
      0|   28|    if ((self = [super init]))
      0|   29|    {
      0|   30|        invocationMatcher = [[OCMInvocationMatcher alloc] init];
      0|   31|    }
      0|   32|    
      0|   33|    return self;
      0|   34|}
       |   35|
       |   36|- (void)forwardInvocation:(NSInvocation *)anInvocation
      0|   37|{
      0|   38|    [super forwardInvocation:anInvocation];
      0|   39|    [mockObject verifyInvocation:invocationMatcher atLocation:self.location];
      0|   40|}
       |   41|
       |   42|- (void)dealloc
      0|   43|{
      0|   44|	[_location release];
      0|   45|	[super dealloc];
      0|   46|}
       |   47|
       |   48|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCMockObject.m:
       |    1|/*
       |    2| *  Copyright (c) 2004-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <OCMock/OCMockObject.h>
       |   18|#import "OCClassMockObject.h"
       |   19|#import "OCProtocolMockObject.h"
       |   20|#import "OCPartialMockObject.h"
       |   21|#import "OCObserverMockObject.h"
       |   22|#import "OCMStubRecorder.h"
       |   23|#import <OCMock/OCMLocation.h>
       |   24|#import "NSInvocation+OCMAdditions.h"
       |   25|#import "OCMInvocationMatcher.h"
       |   26|#import "OCMMacroState.h"
       |   27|#import "OCMFunctions.h"
       |   28|#import "OCMVerifier.h"
       |   29|#import "OCMInvocationExpectation.h"
       |   30|#import "OCMExpectationRecorder.h"
       |   31|
       |   32|
       |   33|@implementation OCMockObject
       |   34|
       |   35|#pragma mark  Class initialisation
       |   36|
       |   37|+ (void)initialize
      3|   38|{
      3|   39|	if([[NSInvocation class] instanceMethodSignatureForSelector:@selector(getArgumentAtIndexAsObject:)] == NULL)
      0|   40|		[NSException raise:NSInternalInconsistencyException format:@"** Expected method not present; the method getArgumentAtIndexAsObject: is not implemented by NSInvocation. If you see this exception it is likely that you are using the static library version of OCMock and your project is not configured correctly to load categories from static libraries. Did you forget to add the -ObjC linker flag?"];
      3|   41|}
       |   42|
       |   43|
       |   44|#pragma mark  Factory methods
       |   45|
       |   46|+ (id)mockForClass:(Class)aClass
     11|   47|{
     11|   48|	return [[[OCClassMockObject alloc] initWithClass:aClass] autorelease];
     11|   49|}
       |   50|
       |   51|+ (id)mockForProtocol:(Protocol *)aProtocol
      0|   52|{
      0|   53|	return [[[OCProtocolMockObject alloc] initWithProtocol:aProtocol] autorelease];
      0|   54|}
       |   55|
       |   56|+ (id)partialMockForObject:(NSObject *)anObject
      8|   57|{
      8|   58|	return [[[OCPartialMockObject alloc] initWithObject:anObject] autorelease];
      8|   59|}
       |   60|
       |   61|
       |   62|+ (id)niceMockForClass:(Class)aClass
     10|   63|{
     10|   64|	return [self _makeNice:[self mockForClass:aClass]];
     10|   65|}
       |   66|
       |   67|+ (id)niceMockForProtocol:(Protocol *)aProtocol
      0|   68|{
      0|   69|	return [self _makeNice:[self mockForProtocol:aProtocol]];
      0|   70|}
       |   71|
       |   72|
       |   73|+ (id)_makeNice:(OCMockObject *)mock
     10|   74|{
     10|   75|	mock->isNice = YES;
     10|   76|	return mock;
     10|   77|}
       |   78|
       |   79|
       |   80|+ (id)observerMock
      0|   81|{
      0|   82|	return [[[OCObserverMockObject alloc] init] autorelease];
      0|   83|}
       |   84|
       |   85|
       |   86|#pragma mark  Initialisers, description, accessors, etc.
       |   87|
       |   88|- (instancetype)init
     19|   89|{
     19|   90|	// no [super init], we're inheriting from NSProxy
     19|   91|	expectationOrderMatters = NO;
     19|   92|	stubs = [[NSMutableArray alloc] init];
     19|   93|	expectations = [[NSMutableArray alloc] init];
     19|   94|	exceptions = [[NSMutableArray alloc] init];
     19|   95|    invocations = [[NSMutableArray alloc] init];
     19|   96|    return self;
     19|   97|}
       |   98|
       |   99|- (void)dealloc
     18|  100|{
     18|  101|	[stubs release];
     18|  102|	[expectations release];
     18|  103|	[exceptions release];
     18|  104|    [invocations release];
     18|  105|	[super dealloc];
     18|  106|}
       |  107|
       |  108|- (NSString *)description
      0|  109|{
      0|  110|	return @"OCMockObject";
      0|  111|}
       |  112|
       |  113|- (void)addStub:(OCMInvocationStub *)aStub
     59|  114|{
     59|  115|    [stubs addObject:aStub];
     59|  116|}
       |  117|
       |  118|- (void)addExpectation:(OCMInvocationExpectation *)anExpectation
      0|  119|{
      0|  120|    [expectations addObject:anExpectation];
      0|  121|}
       |  122|
       |  123|
       |  124|#pragma mark  Public API
       |  125|
       |  126|- (void)setExpectationOrderMatters:(BOOL)flag
      0|  127|{
      0|  128|    expectationOrderMatters = flag;
      0|  129|}
       |  130|
       |  131|- (void)stopMocking
     26|  132|{
     26|  133|    // no-op for mock objects that are not class object or partial mocks
     26|  134|}
       |  135|
       |  136|
       |  137|- (id)stub
      8|  138|{
      8|  139|	return [[[OCMStubRecorder alloc] initWithMockObject:self] autorelease];
      8|  140|}
       |  141|
       |  142|- (id)expect
      0|  143|{
      0|  144|    return [[[OCMExpectationRecorder alloc] initWithMockObject:self] autorelease];
      0|  145|}
       |  146|
       |  147|- (id)reject
      0|  148|{
      0|  149|	return [[self expect] never];
      0|  150|}
       |  151|
       |  152|
       |  153|- (id)verify
      0|  154|{
      0|  155|    return [self verifyAtLocation:nil];
      0|  156|}
       |  157|
       |  158|- (id)verifyAtLocation:(OCMLocation *)location
      0|  159|{
      0|  160|    NSMutableArray *unsatisfiedExpectations = [NSMutableArray array];
      0|  161|    for(OCMInvocationExpectation *e in expectations)
      0|  162|    {
      0|  163|        if(![e isSatisfied])
      0|  164|            [unsatisfiedExpectations addObject:e];
      0|  165|    }
      0|  166|
      0|  167|	if([unsatisfiedExpectations count] == 1)
      0|  168|	{
      0|  169|        NSString *description = [NSString stringWithFormat:@"%@: expected method was not invoked: %@",
      0|  170|         [self description], [[unsatisfiedExpectations objectAtIndex:0] description]];
      0|  171|        OCMReportFailure(location, description);
      0|  172|	}
      0|  173|	else if([unsatisfiedExpectations count] > 0)
      0|  174|	{
      0|  175|		NSString *description = [NSString stringWithFormat:@"%@: %@ expected methods were not invoked: %@",
      0|  176|         [self description], @([unsatisfiedExpectations count]), [self _stubDescriptions:YES]];
      0|  177|        OCMReportFailure(location, description);
      0|  178|	}
      0|  179|
      0|  180|	if([exceptions count] > 0)
      0|  181|	{
      0|  182|        NSString *description = [NSString stringWithFormat:@"%@: %@ (This is a strict mock failure that was ignored when it actually occured.)",
      0|  183|         [self description], [[exceptions objectAtIndex:0] description]];
      0|  184|        OCMReportFailure(location, description);
      0|  185|	}
      0|  186|
      0|  187|    return [[[OCMVerifier alloc] initWithMockObject:self] autorelease];
      0|  188|}
       |  189|
       |  190|
       |  191|- (void)verifyWithDelay:(NSTimeInterval)delay
      0|  192|{
      0|  193|    [self verifyWithDelay:delay atLocation:nil];
      0|  194|}
       |  195|
       |  196|- (void)verifyWithDelay:(NSTimeInterval)delay atLocation:(OCMLocation *)location
      0|  197|{
      0|  198|    NSTimeInterval step = 0.01;
      0|  199|    while(delay > 0)
      0|  200|    {
      0|  201|        if([expectations count] == 0)
      0|  202|            break;
      0|  203|        [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:step]];
      0|  204|        delay -= step;
      0|  205|        step *= 2;
      0|  206|    }
      0|  207|    [self verifyAtLocation:location];
      0|  208|}
       |  209|
       |  210|
       |  211|#pragma mark Verify after running
       |  212|
       |  213|- (void)verifyInvocation:(OCMInvocationMatcher *)matcher
      0|  214|{
      0|  215|    [self verifyInvocation:matcher atLocation:nil];
      0|  216|}
       |  217|
       |  218|- (void)verifyInvocation:(OCMInvocationMatcher *)matcher atLocation:(OCMLocation *)location
      0|  219|{
      0|  220|    for(NSInvocation *invocation in invocations)
      0|  221|    {
      0|  222|        if([matcher matchesInvocation:invocation])
      0|  223|            return;
      0|  224|    }
      0|  225|    NSString *description = [NSString stringWithFormat:@"%@: Method %@ was not invoked.",
      0|  226|     [self description], [matcher description]];
      0|  227|
      0|  228|    OCMReportFailure(location, description);
      0|  229|}
       |  230|
       |  231|
       |  232|#pragma mark  Handling invocations
       |  233|
       |  234|- (id)forwardingTargetForSelector:(SEL)aSelector
     88|  235|{
     88|  236|    if([OCMMacroState globalState] != nil)
     51|  237|    {
     51|  238|        OCMRecorder *recorder = [[OCMMacroState globalState] recorder];
     51|  239|        [recorder setMockObject:self];
     51|  240|        return recorder;
     51|  241|    }
     37|  242|    return nil;
     88|  243|}
       |  244|
       |  245|
       |  246|- (BOOL)handleSelector:(SEL)sel
     80|  247|{
     80|  248|    for(OCMInvocationStub *recorder in stubs)
    257|  249|        if([recorder matchesSelector:sel])
     14|  250|            return YES;
     80|  251|
     66|  252|    return NO;
     80|  253|}
       |  254|
       |  255|- (void)forwardInvocation:(NSInvocation *)anInvocation
     37|  256|{
     37|  257|    @try
     37|  258|    {
     37|  259|        if([self handleInvocation:anInvocation] == NO)
     20|  260|            [self handleUnRecordedInvocation:anInvocation];
     37|  261|    }
     37|  262|    @catch(NSException *e)
     37|  263|    {
     37|  264|        [exceptions addObject:e];
     37|  265|        [e raise];
     37|  266|    }
     37|  267|}
       |  268|
       |  269|- (BOOL)handleInvocation:(NSInvocation *)anInvocation
    119|  270|{
    119|  271|    [invocations addObject:anInvocation];
    119|  272|
    119|  273|    OCMInvocationStub *stub = nil;
    119|  274|    for(stub in stubs)
    413|  275|    {
    413|  276|        // If the stub forwards its invocation to the real object, then we don't want to do handleInvocation: yet, since forwarding the invocation to the real object could call a method that is expected to happen after this one, which is bad if expectationOrderMatters is YES
    413|  277|        if([stub matchesInvocation:anInvocation])
     33|  278|            break;
    413|  279|    }
    119|  280|    // Retain the stub in case it ends up being removed from stubs and expectations, since we still have to call handleInvocation on the stub at the end
    119|  281|    [stub retain];
    119|  282|    if(stub == nil)
     86|  283|        return NO;
    119|  284|
     33|  285|     if([expectations containsObject:stub])
      0|  286|     {
      0|  287|          OCMInvocationExpectation *expectation = [self _nextExptectedInvocation];
      0|  288|          if(expectationOrderMatters && (expectation != stub))
      0|  289|          {
      0|  290|               [NSException raise:NSInternalInconsistencyException format:@"%@: unexpected method invoked: %@\n\texpected:\t%@",
      0|  291|                            [self description], [stub description], [[expectations objectAtIndex:0] description]];
      0|  292|          }
      0|  293|
      0|  294|          // We can't check isSatisfied yet, since the stub won't be satisfied until we call handleInvocation:, and we don't want to call handleInvocation: yes for the reason in the comment above, since we'll still have the current expectation in the expectations array, which will cause an exception if expectationOrderMatters is YES and we're not ready for any future expected methods to be called yet
      0|  295|          if(![(OCMInvocationExpectation *)stub isMatchAndReject])
      0|  296|          {
      0|  297|               [expectations removeObject:stub];
      0|  298|               [stubs removeObject:stub];
      0|  299|          }
      0|  300|     }
     33|  301|     [stub handleInvocation:anInvocation];
     33|  302|     [stub release];
     33|  303|
     33|  304|     return YES;
    119|  305|}
       |  306|
       |  307|
       |  308|- (OCMInvocationExpectation *)_nextExptectedInvocation
      0|  309|{
      0|  310|    for(OCMInvocationExpectation *expectation in expectations)
      0|  311|        if(![expectation isMatchAndReject])
      0|  312|            return expectation;
      0|  313|    return nil;
      0|  314|}
       |  315|
       |  316|- (void)handleUnRecordedInvocation:(NSInvocation *)anInvocation
      2|  317|{
      2|  318|	if(isNice == NO)
      0|  319|	{
      0|  320|		[NSException raise:NSInternalInconsistencyException format:@"%@: unexpected method invoked: %@ %@",
      0|  321|                        [self description], [anInvocation invocationDescription], [self _stubDescriptions:NO]];
      0|  322|	}
      2|  323|}
       |  324|
       |  325|- (void)doesNotRecognizeSelector:(SEL)aSelector __unused
      0|  326|{
      0|  327|    if([OCMMacroState globalState] != nil)
      0|  328|    {
      0|  329|        // we can't do anything clever with the macro state because we must raise an exception here
      0|  330|        [NSException raise:NSInvalidArgumentException format:@"%@: Cannot stub/expect/verify method '%@' because no such method exists in the mocked class.",
      0|  331|                        [self description], NSStringFromSelector(aSelector)];
      0|  332|    }
      0|  333|    else
      0|  334|    {
      0|  335|        [NSException raise:NSInvalidArgumentException format:@"-[%@ %@]: unrecognized selector sent to instance %p",
      0|  336|                        [self description], NSStringFromSelector(aSelector), (void *)self];
      0|  337|    }
      0|  338|}
       |  339|
       |  340|
       |  341|#pragma mark  Helper methods
       |  342|
       |  343|- (NSString *)_stubDescriptions:(BOOL)onlyExpectations
      0|  344|{
      0|  345|	NSMutableString *outputString = [NSMutableString string];
      0|  346|    for(OCMStubRecorder *stub in stubs)
      0|  347|    {
      0|  348|		NSString *prefix = @"";
      0|  349|		
      0|  350|		if(onlyExpectations)
      0|  351|		{
      0|  352|			if([expectations containsObject:stub] == NO)
      0|  353|				continue;
      0|  354|		}
      0|  355|		else
      0|  356|		{
      0|  357|			if([expectations containsObject:stub])
      0|  358|				prefix = @"expected:\t";
      0|  359|			else
      0|  360|				prefix = @"stubbed:\t";
      0|  361|		}
      0|  362|		[outputString appendFormat:@"\n\t%@%@", prefix, [stub description]];
      0|  363|	}
      0|  364|	return outputString;
      0|  365|}
       |  366|
       |  367|
       |  368|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCObserverMockObject.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import "OCObserverMockObject.h"
       |   18|#import "OCMObserverRecorder.h"
       |   19|#import "OCMLocation.h"
       |   20|#import "OCMFunctions.h"
       |   21|
       |   22|
       |   23|@implementation OCObserverMockObject
       |   24|
       |   25|#pragma mark  Initialisers, description, accessors, etc.
       |   26|
       |   27|- (id)init
      0|   28|{
      0|   29|    if ((self = [super init]))
      0|   30|    {
      0|   31|        recorders = [[NSMutableArray alloc] init];
      0|   32|        centers = [[NSMutableArray alloc] init];
      0|   33|    }
      0|   34|	
      0|   35|	return self;
      0|   36|}
       |   37|
       |   38|- (id)retain
      0|   39|{
      0|   40|    return [super retain];
      0|   41|}
       |   42|
       |   43|- (void)dealloc
      0|   44|{
      0|   45|    for(NSNotificationCenter *c in centers)
      0|   46|        [c removeObserver:self];
      0|   47|    [centers release];
      0|   48|	[recorders release];
      0|   49|	[super dealloc];
      0|   50|}
       |   51|
       |   52|- (NSString *)description
      0|   53|{
      0|   54|	return @"OCMockObserver";
      0|   55|}
       |   56|
       |   57|- (void)setExpectationOrderMatters:(BOOL)flag
      0|   58|{
      0|   59|    expectationOrderMatters = flag;
      0|   60|}
       |   61|
       |   62|- (void)autoRemoveFromCenter:(NSNotificationCenter *)aCenter
      0|   63|{
      0|   64|    [centers addObject:aCenter];
      0|   65|}
       |   66|
       |   67|
       |   68|#pragma mark  Public API
       |   69|
       |   70|- (id)expect
      0|   71|{
      0|   72|	OCMObserverRecorder *recorder = [[[OCMObserverRecorder alloc] init] autorelease];
      0|   73|	[recorders addObject:recorder];
      0|   74|	return recorder;
      0|   75|}
       |   76|
       |   77|- (void)verify
      0|   78|{
      0|   79|    [self verifyAtLocation:nil];
      0|   80|}
       |   81|
       |   82|- (void)verifyAtLocation:(OCMLocation *)location
      0|   83|{
      0|   84|    if([recorders count] == 1)
      0|   85|    {
      0|   86|        NSString *description = [NSString stringWithFormat:@"%@: expected notification was not observed: %@",
      0|   87|         [self description], [[recorders lastObject] description]];
      0|   88|        OCMReportFailure(location, description);
      0|   89|    }
      0|   90|    else if([recorders count] > 0)
      0|   91|    {
      0|   92|        NSString *description = [NSString stringWithFormat:@"%@ : %@ expected notifications were not observed.",
      0|   93|         [self description], @([recorders count])];
      0|   94|        OCMReportFailure(location, description);
      0|   95|    }
      0|   96|}
       |   97|
       |   98|
       |   99|#pragma mark  Receiving recording requests via macro
       |  100|
       |  101|- (void)notificationWithName:(NSString *)name object:(id)sender
      0|  102|{
      0|  103|    [[self expect] notificationWithName:name object:sender];
      0|  104|}
       |  105|
       |  106|
       |  107|#pragma mark  Receiving notifications
       |  108|
       |  109|- (void)handleNotification:(NSNotification *)aNotification
      0|  110|{
      0|  111|	NSUInteger i, limit;
      0|  112|	
      0|  113|	limit = expectationOrderMatters ? 1 : [recorders count];
      0|  114|	for(i = 0; i < limit; i++)
      0|  115|	{
      0|  116|		if([[recorders objectAtIndex:i] matchesNotification:aNotification])
      0|  117|		{
      0|  118|			[recorders removeObjectAtIndex:i];
      0|  119|			return;
      0|  120|		}
      0|  121|	}
      0|  122|	[NSException raise:NSInternalInconsistencyException format:@"%@: unexpected notification observed: %@", [self description], 
      0|  123|	  [aNotification description]];
      0|  124|}
       |  125|
       |  126|
       |  127|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCPartialMockObject.m:
       |    1|/*
       |    2| *  Copyright (c) 2009-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <objc/runtime.h>
       |   18|#import "OCMockObject.h"
       |   19|#import "OCPartialMockObject.h"
       |   20|#import "NSMethodSignature+OCMAdditions.h"
       |   21|#import "NSObject+OCMAdditions.h"
       |   22|#import "OCMFunctions.h"
       |   23|#import "OCMInvocationStub.h"
       |   24|
       |   25|
       |   26|@implementation OCPartialMockObject
       |   27|
       |   28|#pragma mark  Initialisers, description, accessors, etc.
       |   29|
       |   30|- (id)initWithObject:(NSObject *)anObject
      8|   31|{
      8|   32|    NSParameterAssert(anObject != nil);
      8|   33|    [self assertClassIsSupported:[anObject class]];
      8|   34|	[super initWithClass:[anObject class]];
      8|   35|	realObject = [anObject retain];
      8|   36|    [self prepareObjectForInstanceMethodMocking];
      8|   37|	return self;
      8|   38|}
       |   39|
       |   40|- (void)dealloc
      8|   41|{
      8|   42|	[self stopMocking];
      8|   43|	[realObject release];
      8|   44|	[super dealloc];
      8|   45|}
       |   46|
       |   47|- (NSString *)description
      0|   48|{
      0|   49|	return [NSString stringWithFormat:@"OCPartialMockObject(%@)", NSStringFromClass(mockedClass)];
      0|   50|}
       |   51|
       |   52|- (NSObject *)realObject
    404|   53|{
    404|   54|	return realObject;
    404|   55|}
       |   56|
       |   57|#pragma mark  Helper methods
       |   58|
       |   59|- (void)assertClassIsSupported:(Class)class
      8|   60|{
      8|   61|    NSString *classname = NSStringFromClass(class);
      8|   62|    NSString *reason = nil;
      8|   63|    if([classname hasPrefix:@"__NSTagged"] || [classname hasPrefix:@"NSTagged"])
      0|   64|        reason = [NSString stringWithFormat:@"OCMock does not support partially mocking tagged classes; got %@", classname];
      8|   65|    else if([classname hasPrefix:@"__NSCF"])
      0|   66|        reason = [NSString stringWithFormat:@"OCMock does not support partially mocking toll-free bridged classes; got %@", classname];
      8|   67|
      8|   68|    if(reason != nil)
      0|   69|        [[NSException exceptionWithName:NSInvalidArgumentException reason:reason userInfo:nil] raise];
      8|   70|}
       |   71|
       |   72|
       |   73|#pragma mark  Extending/overriding superclass behaviour
       |   74|
       |   75|- (void)stopMocking
     16|   76|{
     16|   77|    if(realObject != nil)
      8|   78|    {
      8|   79|        OCMSetAssociatedMockForObject(nil, realObject);
      8|   80|        object_setClass(realObject, [self mockedClass]);
      8|   81|        [realObject release];
      8|   82|        realObject = nil;
      8|   83|    }
     16|   84|    [super stopMocking];
     16|   85|}
       |   86|
       |   87|- (void)addStub:(OCMInvocationStub *)aStub
     47|   88|{
     47|   89|    [super addStub:aStub];
     47|   90|    if(![aStub recordedAsClassMethod])
     42|   91|        [self setupForwarderForSelector:[[aStub recordedInvocation] selector]];
     47|   92|}
       |   93|
       |   94|- (void)handleUnRecordedInvocation:(NSInvocation *)anInvocation
     18|   95|{
     18|   96|	[anInvocation invokeWithTarget:realObject];
     18|   97|}
       |   98|
       |   99|
       |  100|#pragma mark  Subclass management
       |  101|
       |  102|- (void)prepareObjectForInstanceMethodMocking
      8|  103|{
      8|  104|    OCMSetAssociatedMockForObject(self, realObject);
      8|  105|
      8|  106|    /* dynamically create a subclass and set it as the class of the object */
      8|  107|    Class subclass = OCMCreateSubclass(mockedClass, realObject);
      8|  108|	object_setClass(realObject, subclass);
      8|  109|
      8|  110|    /* point forwardInvocation: of the object to the implementation in the mock */
      8|  111|	Method myForwardMethod = class_getInstanceMethod([self mockObjectClass], @selector(forwardInvocationForRealObject:));
      8|  112|	IMP myForwardIMP = method_getImplementation(myForwardMethod);
      8|  113|    class_addMethod(subclass, @selector(forwardInvocation:), myForwardIMP, method_getTypeEncoding(myForwardMethod));
      8|  114|
      8|  115|    /* do the same for forwardingTargetForSelector, remember existing imp with alias selector */
      8|  116|    Method myForwardingTargetMethod = class_getInstanceMethod([self mockObjectClass], @selector(forwardingTargetForSelectorForRealObject:));
      8|  117|    IMP myForwardingTargetIMP = method_getImplementation(myForwardingTargetMethod);
      8|  118|    IMP originalForwardingTargetIMP = [mockedClass instanceMethodForSelector:@selector(forwardingTargetForSelector:)];
      8|  119|    class_addMethod(subclass, @selector(forwardingTargetForSelector:), myForwardingTargetIMP, method_getTypeEncoding(myForwardingTargetMethod));
      8|  120|    class_addMethod(subclass, @selector(ocmock_replaced_forwardingTargetForSelector:), originalForwardingTargetIMP, method_getTypeEncoding(myForwardingTargetMethod));
      8|  121|
      8|  122|    /* We also override the -class method to return the original class */
      8|  123|    Method myObjectClassMethod = class_getInstanceMethod([self mockObjectClass], @selector(classForRealObject));
      8|  124|    const char *objectClassTypes = method_getTypeEncoding(myObjectClassMethod);
      8|  125|    IMP myObjectClassImp = method_getImplementation(myObjectClassMethod);
      8|  126|    class_addMethod(subclass, @selector(class), myObjectClassImp, objectClassTypes);
      8|  127|
      8|  128|    /* Adding forwarder for most instance methods to allow for verify after run */
      8|  129|    NSArray *methodBlackList = @[@"class", @"forwardingTargetForSelector:", @"methodSignatureForSelector:", @"forwardInvocation:",
      8|  130|            @"allowsWeakReference", @"retainWeakReference", @"isBlock"];
  9.35k|  131|    [NSObject enumerateMethodsInClass:mockedClass usingBlock:^(Class cls, SEL sel) {
  9.35k|  132|        if((cls == [NSObject class]) || (cls == [NSProxy class]))
  8.95k|  133|            return;
    403|  134|        NSString *className = NSStringFromClass(cls);
    403|  135|        NSString *selName = NSStringFromSelector(sel);
    403|  136|        if(([className hasPrefix:@"NS"] || [className hasPrefix:@"UI"]) &&
      0|  137|           ([selName hasPrefix:@"_"] || [selName hasSuffix:@"_"]))
      0|  138|            return;
    403|  139|        if([methodBlackList containsObject:selName])
      0|  140|            return;
    403|  141|        @try
    403|  142|        {
    403|  143|            [self setupForwarderForSelector:sel];
    403|  144|        }
    403|  145|        @catch(NSException *e)
    403|  146|        {
    403|  147|            // ignore for now
    403|  148|        }
    403|  149|    }];
      8|  150|}
       |  151|
       |  152|- (void)setupForwarderForSelector:(SEL)sel
    445|  153|{
    445|  154|    SEL aliasSelector = OCMAliasForOriginalSelector(sel);
    445|  155|    if(class_getInstanceMethod(object_getClass(realObject), aliasSelector) != NULL)
     42|  156|        return;
    445|  157|
    403|  158|    Method originalMethod = class_getInstanceMethod(mockedClass, sel);
    403|  159|	IMP originalIMP = method_getImplementation(originalMethod);
    403|  160|    const char *types = method_getTypeEncoding(originalMethod);
    403|  161|    /* Might be NULL if the selector is forwarded to another class */
    403|  162|    // TODO: check the fallback implementation is actually sufficient
    403|  163|    if(types == NULL)
      0|  164|        types = ([[mockedClass instanceMethodSignatureForSelector:sel] fullObjCTypes]);
    403|  165|
    403|  166|    Class subclass = object_getClass([self realObject]);
    403|  167|    IMP forwarderIMP = [mockedClass instanceMethodForwarderForSelector:sel];
    403|  168|    class_replaceMethod(subclass, sel, forwarderIMP, types);
    403|  169|	class_addMethod(subclass, aliasSelector, originalIMP, types);
    403|  170|}
       |  171|
       |  172|
       |  173|// Implementation of the -class method; return the Class that was reported with [realObject class] prior to mocking
       |  174|- (Class)classForRealObject
    354|  175|{
    354|  176|    // in here "self" is a reference to the real object, not the mock
    354|  177|    OCPartialMockObject *mock = OCMGetAssociatedMockForObject(self);
    354|  178|    if(mock == nil)
      0|  179|        [NSException raise:NSInternalInconsistencyException format:@"No partial mock for object %p", self];
    354|  180|    return [mock mockedClass];
    354|  181|}
       |  182|
       |  183|
       |  184|- (id)forwardingTargetForSelectorForRealObject:(SEL)sel
     80|  185|{
     80|  186|	// in here "self" is a reference to the real object, not the mock
     80|  187|    OCPartialMockObject *mock = OCMGetAssociatedMockForObject(self);
     80|  188|    if(mock == nil)
      0|  189|        [NSException raise:NSInternalInconsistencyException format:@"No partial mock for object %p", self];
     80|  190|    if([mock handleSelector:sel])
     14|  191|        return self;
     80|  192|
     66|  193|    return [self ocmock_replaced_forwardingTargetForSelector:sel];
     80|  194|}
       |  195|
       |  196|//  Make the compiler happy in -forwardingTargetForSelectorForRealObject: because it can't find the message
       |  197|- (id)ocmock_replaced_forwardingTargetForSelector:(SEL)sel
      0|  198|{
      0|  199|    return nil;
      0|  200|}
       |  201|
       |  202|
       |  203|- (void)forwardInvocationForRealObject:(NSInvocation *)anInvocation
     80|  204|{
     80|  205|	// in here "self" is a reference to the real object, not the mock
     80|  206|    OCPartialMockObject *mock = OCMGetAssociatedMockForObject(self);
     80|  207|    if(mock == nil)
      0|  208|        [NSException raise:NSInternalInconsistencyException format:@"No partial mock for object %p", self];
     80|  209|
     80|  210|	if([mock handleInvocation:anInvocation] == NO)
     66|  211|    {
     66|  212|        [anInvocation setSelector:OCMAliasForOriginalSelector([anInvocation selector])];
     66|  213|        [anInvocation invoke];
     66|  214|    }
     80|  215|}
       |  216|
       |  217|
       |  218|@end

/Users/Sal/Sites/paperlesspost/paperless-ios/Pods/OCMock/Source/OCMock/OCProtocolMockObject.m:
       |    1|/*
       |    2| *  Copyright (c) 2005-2015 Erik Doernenburg and contributors
       |    3| *
       |    4| *  Licensed under the Apache License, Version 2.0 (the "License"); you may
       |    5| *  not use these files except in compliance with the License. You may obtain
       |    6| *  a copy of the License at
       |    7| *
       |    8| *      http://www.apache.org/licenses/LICENSE-2.0
       |    9| *
       |   10| *  Unless required by applicable law or agreed to in writing, software
       |   11| *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
       |   12| *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
       |   13| *  License for the specific language governing permissions and limitations
       |   14| *  under the License.
       |   15| */
       |   16|
       |   17|#import <objc/runtime.h>
       |   18|#import "NSMethodSignature+OCMAdditions.h"
       |   19|#import "OCProtocolMockObject.h"
       |   20|
       |   21|@implementation OCProtocolMockObject
       |   22|
       |   23|#pragma mark  Initialisers, description, accessors, etc.
       |   24|
       |   25|- (id)initWithProtocol:(Protocol *)aProtocol
      0|   26|{
      0|   27|    NSParameterAssert(aProtocol != nil);
      0|   28|	[super init];
      0|   29|	mockedProtocol = aProtocol;
      0|   30|	return self;
      0|   31|}
       |   32|
       |   33|- (NSString *)description
      0|   34|{
      0|   35|    const char* name = protocol_getName(mockedProtocol);
      0|   36|    return [NSString stringWithFormat:@"OCMockObject(%s)", name];
      0|   37|}
       |   38|
       |   39|#pragma mark  Proxy API
       |   40|
       |   41|- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
      0|   42|{
      0|   43|    struct { BOOL isRequired; BOOL isInstance; } opts[4] = { {YES, YES}, {NO, YES}, {YES, NO}, {NO, NO} };
      0|   44|    for(int i = 0; i < 4; i++)
      0|   45|    {
      0|   46|        struct objc_method_description methodDescription = protocol_getMethodDescription(mockedProtocol, aSelector, opts[i].isRequired, opts[i].isInstance);
      0|   47|        if(methodDescription.name != NULL)
      0|   48|            return [NSMethodSignature signatureWithObjCTypes:methodDescription.types];
      0|   49|    }
      0|   50|    return nil;
      0|   51|}
       |   52|
       |   53|- (BOOL)conformsToProtocol:(Protocol *)aProtocol
      0|   54|{
      0|   55|    return protocol_conformsToProtocol(mockedProtocol, aProtocol);
      0|   56|}
       |   57|
       |   58|- (BOOL)respondsToSelector:(SEL)selector
      0|   59|{
      0|   60|    return ([self methodSignatureForSelector:selector] != nil);
      0|   61|}
       |   62|
       |   63|@end

